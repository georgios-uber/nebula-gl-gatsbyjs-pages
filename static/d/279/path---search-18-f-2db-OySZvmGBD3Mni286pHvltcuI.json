{"pageContext":{"isCreatedByStatefulCreatePages":false,"data":[{"excerpt":"Hello World","rawMarkdownBody":"# Hello World\n\n\n\n","slug":"docs","title":"Hello World"},{"excerpt":"FAQWill this replace ?No.","rawMarkdownBody":"# FAQ\n\n\n#### Will this replace `deck.gl`?\n\nNo.\n\n\n","slug":"docs/faq","title":"FAQ"},{"excerpt":"Overviewnebula.gl provides editable and interactive map overlay layers, built using the power of deck.gl.Design Goalsnebula.gl aspires to be…","rawMarkdownBody":"# Overview\n\n[nebula.gl](https://neb.gl) provides editable and interactive map overlay layers, built using the power of [deck.gl](https://uber.github.io/deck.gl).\n\n## Design Goals\n\nnebula.gl aspires to be an ultra-performant, fully 3D-enabled GeoJSON editing system primarily focused on geospatial editing use cases.\n\n* Maximal rendering and editing performance, without need for complex application logic (such as splitting data into subgroups etc).\n* Target performance: Editing at 60fps (e.g. dragging sub objects) in GeoJSON payloads with 100K features (points, lines or polygons).\n* Handles GeoJSON corner cases, e.g. automatically changing object types from `Polygon` to `MultiPolygon` when addition polygons are added.\n* Fully 3D enabled (Can e.g. use WebGL z-buffer so that lines being rendered are properly occluded by other geometry).\n* Seamless integration with deck.gl and all geospatial deck.gl layers, allowing for GeoJSON editing to be interleaved with rich 3D visualizations.\n* Handle all aspects of event handling, including touch screen support.\n\n\n## Why nebula.gl?\n\nYou should strongly consider nebula.gl:\n\n* You want a full-featured, ultra-high-performance editing solution for GeoJson.\n* You are already using e.g. `deck.gl` or `react-map-gl`.\n\nYou may want to look at alternatives if:\n\n* If you have very simple editing requirements (just a simple polygon etc)\n\nIf nebula.gl is more than what you need (e.g. in terms of bundle size), and you may want to look at other solutions, e.g. the simple polygon editor overlay being developed in react-map-gl.\n\nThat said, if you are already using `deck.gl` the additional overhead of nebula.gl is small, and the seamless integration with deck.gl should be valuable.\n\n\n## Quick Overview of the nebula.gl API\n\n### EditableGeoJsonLayer\n\n[EditableGeoJsonLayer](./api-reference/layers/editable-geojson-layer.md) is implemented as a deck.gl layer. It provides the ability to view and edit multiple types of geometry formatted as [GeoJSON](https://tools.ietf.org/html/rfc7946) (an open standard format for geometry).\n\n### Nebula Layers\n\nnebula.gl includes a react component. In order to use it you need to put it inside `MapGL` and provide\n`viewport` and `layers`. `layers` is an array, there are multiple types of layers.\n\nThese are the **native** type of layers for nebula.gl. There are multiple examples here.\nThey may just display objects or display and allow you to edit objects.\nThese layers are rendered using ```WebGL```.\n\n### Callbacks\n\nWhen there is the ability to edit, callbacks are provided to inform you of edits.\nMore details in [Using Editable Layers](documentation/developer-guide/using-editable-layers)\n\n### Deck.gl Layers\n\nYou can use Deck.gl layers inside nebula.gl. These layers would work the same way as in Deck.gl.\nThis way you can combine both types of layers for maximum flexibility.\nThese layers are rendered using `WebGL`.\n\n### Overlays\n\nThese layers are based on HTML and rendered by the browser. You can use them\nfor complicated objects that follow map points. They are less performant\nbut more flexible. For more details see [Using Html Overlays](documentation/developer-guide/using-html-overlays)\n","slug":"docs/overview","title":"Overview"},{"excerpt":"Roadmapv1.0Maximize performance in all use cases: target is 100k objects being edited at 60fps.More editing capabilities.Better…","rawMarkdownBody":"# Roadmap\n\n\n## v1.0\n\n- Maximize performance in all use cases: target is 100k objects being edited at 60fps.\n- More editing capabilities.\n- Better documentation\n- More examples\n- High unit test coverage and build status on homepage\n\n\n## v2.0\n\n- TBD","slug":"docs/roadmap","title":"Roadmap"},{"excerpt":"Configuring NebulaWhile deck.gl v5.2 can be used without React, Nebula.gl is currently React only.To use Nebula.gl, you instantiate the…","rawMarkdownBody":"# Configuring Nebula\n\n> While deck.gl v5.2 can be used without React, Nebula.gl is currently React only.\n\nTo use Nebula.gl, you instantiate the Nebula React component, usually.\n\n```js\nrender() {\n  const { editablePolygonsLayer, state } = this;\n  let { viewport } = state;\n\n  const layers = [editablePolygonsLayer];\n\n  return (\n    <div>\n      <MapGL {...viewport} onChangeViewport={this._onChangeViewport}>\n        <Nebula\n          ref={nebula => (this.nebula = nebula || this.nebula)}\n          {...{ layers, viewport }}\n        />\n      </MapGL>\n    </div>\n  );\n}\n\n_onChangeViewport = (viewport: Object) => {\n  this.setState({\n    viewport: { ...this.state.viewport, ...viewport }\n  });\n};\n```\n","slug":"docs/developer-guide/configuring-nebula","title":"Configuring Nebula"},{"excerpt":"LayersCommon layer APIEach layer takes a  in the constructor. This  must contain:: A function that returns an  of  that need rendering.: A…","rawMarkdownBody":"# Layers\n\n## Common layer API\n\nEach layer takes a `config Object` in the constructor. This `Object` must contain:\n- `getData`: A function that returns an `array` of `objects` that need rendering.\n- `toNebulaFeature`: A function that converts any object in the array into `Feature`.\n\n\n\n### Callbacks\nThe following mouse events are emitted:\n- click\n- dblclick\n- mousemove\n- mouseup\n- mousedown\n\nEach of them provides a `LayerMouseEvent` parameter.\n\n\n## Editable layers additional APIs\n\n\n### Editable layers additional callbacks\n- editStart\n- editUpdate\n- editEnd\n\nThese provide a `LayerMouseEvent` parameter and an additional `object` parameter.\n\n\n","slug":"docs/developer-guide/editable-layers","title":"Layers"},{"excerpt":"Using Html OverlaysHTML overlays are very easy to use and take advantage of react's architecture.Checkout the basic overlay exampleYou need…","rawMarkdownBody":"# Using Html Overlays\n\nHTML overlays are very easy to use and take advantage of [react's architecture](https://reactjs.org/docs/).\n\nCheckout the [basic overlay example](examples/overlays/basic)\n\n\n\n```js\nclass YourClassName extends HtmlOverlay {\n  getItems() {\n    return [\n      <HtmlOverlayItem\n        style={{ ...your style here... }}\n        key={ ... unique key... }\n        coordinates={[-122.41914, 37.77919]}\n      >\n        You can have text and children like <div>...</div>\n      </HtmlOverlayItem>\n    ];\n  }\n}\n```\n\nYou need to extend `HtmlOverlay` and override `getItems`, where you\nreturn an array of `HtmlOverlayItem`.\n\nYou need to provide a unique `key` and `coordinates` for each item.\n\nSee [Html Overlay Item docs](documentation/api-reference/htmloverlayitem) for more details.\n\n\n","slug":"docs/developer-guide/html-overlays","title":"Using Html Overlays"},{"excerpt":"Nebula (React Components)The  class is a subclass of the React Component class that you can use as the main class.UsageDefine a composite…","rawMarkdownBody":"# Nebula (React Components)\n\nThe `Nebula` class is a subclass of the React [Component] class that you can use as the main class.\n\n\n## Usage\n\nDefine a composite layer that renders a set of sublayers.\n\n```jsx\n<Nebula\n  viewport={viewport}\n  layers={layers}\n  selectionType={selectionType}\n  onSelection={onSelection}\n  onMapMouseEvent={onMapMouseEvent}\n  logger={logger}\n/>\n```\n\n\n## Properties\n\n### viewport\nThe viewport as explained in [react-map-gl docs](https://uber.github.io/react-map-gl/#/Documentation/getting-started/state-management)\n\n### layers\nAn array of layers you want to render.\nInclude Deck.gl or Nebula.gl layers but not overlays. The order matters.\n\n### selectionType\nValue of ```SELECTION_TYPE```. The default is ```NONE```.\nSet it to a different value to start selection of objects.\n\n### onSelection\nCallback. Called when user object selection is completed.\nYou can set ```selectionType``` to ```NONE``` in this callback if you are done selecting objects.\n\n### onMapMouseEvent\nCallback. Called when mouse is moved over the map.\n\n### logger\nOptional. Pass an object that will be used to log messages like ```console```.\n\n\n\n## Methods\n\n##### `updateAllDeckObjects`\n\nUpdate all objects in all layers and re-render.\n\nParameters: None.\n\n##### `updateDeckObjectsByIds`\n\nUpdate objects with specified ids in all layers and re-render.\n\nParameters:\n\n- `ids` (Array)\n  * Array of strings with ids that need updating.\n","slug":"docs/api-reference/nebula","title":"Nebula (React Components)"},{"excerpt":"Basic usageImport Nebula, Layers and MapGLCreate a Layer and Provide CallbacksRender","rawMarkdownBody":"# Basic usage\n\n## Import Nebula, Layers and MapGL\n```js\nimport {Feature, EditablePolygonsLayer, Nebula} from 'nebula.gl';\nimport MapGL from 'react-map-gl';\n```\n\n## Create a Layer and Provide Callbacks\n```js\nthis.editablePolygonsLayer = new EditablePolygonsLayer({\n  getData: () => [], // Your data here, data has to be objects with unique `id` field\n  toNebulaFeature: data =>\n    new Feature(data, {\n      // Replace with your colors\n      fillColor: [0, 0, 0, 0.4],\n      outlineColor: [0.5, 0.5, 0.5, 1],\n      lineWidthMeters: 10\n    }),\n  on: {\n    mousedown: event => {\n      // select the polygon you want to edit\n      this.editablePolygonsLayer.selectedPolygonId = event.data.id;\n      this.editablePolygonsLayer.selectedSubPolygonIndex = event.metadata.index;\n      this.nebula.updateAllDeckObjects();\n    },\n    editEnd: (event, info) => {\n      // Use resulting data\n      console.log(info.feature.geoJson.geometry.coordinates);\n    }\n  }\n});\n```\n\n## Render\n```js\nrender() {\n  const { editablePolygonsLayer, state } = this;\n  let { viewport } = state;\n\n  const layers = [editablePolygonsLayer];\n\n  return (\n    <div>\n      <MapGL {...viewport} onChangeViewport={this._onChangeViewport}>\n        <Nebula\n          ref={nebula => (this.nebula = nebula || this.nebula)}\n          {...{ layers, viewport }}\n        />\n      </MapGL>\n    </div>\n  );\n}\n\n_onChangeViewport = (viewport: Object) => {\n  this.setState({\n    viewport: { ...this.state.viewport, ...viewport }\n  });\n};\n```\n","slug":"docs/get-started/basic-usage","title":"Basic usage"},{"excerpt":"Unesco World HeritageWait for list to load. You can observe the automatic clustering.\nThere is a more advanced example inside .Sourcehttps…","rawMarkdownBody":"# Unesco World Heritage\n\nWait for list to load. You can observe the automatic clustering.\nThere is a more advanced example inside `examples/overlays`.\n\n\n[codesandbox](embedded-codesandbox://world-heritage)\n\n\n### Source\nhttps://github.com/uber/nebula.gl/blob/master/docs/examples/examples.js\n","slug":"docs/interactive-examples/world-heritage","title":"Unesco World Heritage"},{"excerpt":"Installationnebula.gl will automatically install a compatible version of deck.gl.","rawMarkdownBody":"# Installation\n\n\n```\nyarn add nebula.gl\n```\n\nnebula.gl will automatically install a compatible version of deck.gl.\n","slug":"docs/get-started/installing","title":"Installation"},{"excerpt":"EditableGeoJsonLayerThe Editable GeoJSON layer accepts a GeoJSON  and renders the features as editable polygons, lines, and points…","rawMarkdownBody":"# EditableGeoJsonLayer\n\nThe Editable GeoJSON layer accepts a [GeoJSON](http://geojson.org) `FeatureCollection` and renders the features as editable polygons, lines, and points.\n\n```js\nimport DeckGL from 'deck.gl';\nimport { EditableGeoJsonLayer } from 'nebula.gl';\n\nconst myFeatureCollection = {\n  type: 'FeatureCollection',\n  features: [\n    /* insert features here */\n  ]\n};\n\nclass App extends React.Component {\n  state = {\n    mode: 'modify',\n    selectedFeatureIndexes: [0],\n    data: myFeatureCollection\n  };\n\n  render() {\n    const layer = new EditableGeoJsonLayer({\n      id: 'geojson-layer',\n      data: this.state.data,\n      mode: this.state.mode,\n      selectedFeatureIndexes: this.state.selectedFeatureIndexes,\n\n      onEdit: ({ updatedData }) => {\n        this.setState({\n          data: updatedData,\n        });\n      }\n    });\n\n    return <DeckGL {...this.props.viewport} layers={[layer]} />;\n  }\n}\n```\n\n## Properties\n\nInherits all [deck.gl's Base Layer](https://uber.github.io/deck.gl/#/documentation/deckgl-api-reference/layers/layer) properties.\n\n#### `data` (Object, optional)\n\n* Default: `null`\n\nA [GeoJSON](http://geojson.org) `FeatureCollection` object. The following types of geometry are supported:\n\n* `Point`\n* `LineString`\n* `Polygon`\n* `MultiPoint`\n* `MultiLineString`\n* `MultiPolygon`\n* `GeometryCollection` is not supported.\n\n_Note: passing a single `Feature` is not supported. However, you can pass a `FeatureCollection` containing a single `Feature` and pass `selectedFeatureIndexes: [0]` to achieve the same result._\n\n#### `mode` (String, optional)\n\n* Default: `modify`\n\nThe `mode` property dictates which `ModeHandler` from the `modeHandlers` prop will be used to handle user interaction events (e.g. pointer events) in order to accomplish edits. See [mode handlers overview](../mode-handlers/overview.md) for a description of the built-in modes.\n\n#### `modeConfig` (Object, optional)\n\n* Default: `null`\n\nAn arbitrary object used to further configure the current `ModeHandler`.\n\nSnapping-related `modeConfig` properties:\n\n* `enableSnapping` (Boolean, optional) - Enables snapping for modes that support snapping such as translate mode.\n* `additionalSnapTargets` (Object[], optional) - An array of GeoJSON Features that can be snapped to. This property only needs to be specified if you want to snap to features in other deck.gl layers. All features in this `EditableGeoJsonLayer` will be snap targets.\n\n#### `modeHandlers` (Object, optional)\n\n* Default: see [mode handlers overview](../mode-handlers/overview.md)\n\nA object containing a mapping of mode name (string) to an instance of a `ModeHandler`.\n\n##### Example\n\nFor example, you can use this to provide your own custom `ModeHandler`:\n\n```javascript\n{\n  //...\n  modeHandlers: {\n    ...EditableGeoJsonLayer.defaultProps.modeHandlers,\n    myCustomMode: new MyCustomModeHandler()\n  }\n}\n```\n\n#### `selectedFeatureIndexes` (Array, optional)\n\n* Default: `[]`\n\nThe `selectedFeatureIndexes` property distinguishes which features to treat as selected.\n\n* Features are identified by their index in the collection.\n\n* Selection of a feature causes style accessors to render a different style, defined in function such as `getLineColor` and `getFillColor`.\n\n* Selected features in mode `modify` will render edit handles. Only one feature may be selected while in mode `drawLineString` or `drawPolygon` to draw a feature.\n\n#### `onEdit` (Function, optional)\n\nThe `onEdit` event is the core event provided by this layer and must be handled in order to accept and render edits. The `event` argument includes the following properties:\n\n* `updatedData` (Object): A new `FeatureCollection` with the edit applied.\n\n  * To accept the edit as is, supply this object into the `data` prop on the next render cycle (e.g. by calling React's `setState` function)\n\n  * To reject the edit, do nothing\n\n  * You may also supply a modified version of this object into the `data` prop on the next render cycle (e.g. if you have your own snapping logic).\n\n* `editType` (String): The type of edit requested. One of:\n\n  * `movePosition`: A position was moved.\n\n  * `addPosition`: A position was added (either at the beginning, middle, or end of a feature's coordinates).\n\n  * `removePosition`: A position was removed. Note: it may result in multiple positions being removed in order to maintain valid GeoJSON (e.g. removing a point from a triangular hole will remove the hole entirely).\n\n  * `addFeature`: A new feature was added. Its index is reflected in `featureIndexes`\n\n  * `finishMovePosition`: A position finished moving (e.g. user finished dragging).\n\n  * `scaling`: A feature is being scaled.\n\n  * `scaled`: A feature finished scaling (increase/decrease) (e.g. user finished dragging).\n\n  * `rotating`: A feature is being rotated.\n\n  * `rotated`: A feature finished rotating (e.g. user finished dragging).\n\n  * `translating`: A feature is being translated.\n\n  * `translated`: A feature finished translating (e.g. user finished dragging).\n\n  * `startExtruding`: An edge started extruding (e.g. user started dragging).\n\n  * `extruding`: An edge is extruding.\n\n  * `extruded`: An edge finished extruding (e.g. user finished dragging).\n\n  * `split`: A feature finished splitting.\n\n* `featureIndexes` (Array&lt;number&gt;): The indexes of the edited/added features.\n\n* `editContext` (Object): `null` or an object containing additional context about the edit. This is populated by the active mode handler, see [mode handlers overview](../mode-handlers/overview.md).\n\n##### Example\n\nConsider the user removed the third position from a `Polygon`'s first ring, and that `Polygon` was the fourth feature in the `FeatureCollection`. The `event` argument would look like:\n\n```js\n{\n  updatedData: {...},\n  editType: 'removePosition',\n  featureIndexes: [3],\n  editContext: {\n    positionIndexes: [1, 2],\n    position: null\n  }\n}\n```\n\n#### `pickable` (Boolean, optional)\n\n* Default: `true`\n\nDefaulted to `true` for interactivity.\n\n#### `pickingRadius` (Number, optional)\n\n* Default: `10`\n\nNumber of pixels around the mouse cursor used for picking. This value determines, for example, what feature is considered to be clicked and what is close enough to be snapped to.\n\n#### `pickingDepth` (Number, optional)\n\n* Default: `5`\n\nNumber of layers of overlapping features that will be picked. Useful in cases where features overlap.\n\n### GeoJsonLayer Options\n\nThe following properties from [GeoJsonLayer](https://uber.github.io/deck.gl/#/documentation/deckgl-api-reference/layers/geojson-layer) are supported and function the same:\n\n* `filled`\n* `stroked`\n* `lineWidthScale`\n* `lineWidthMinPixels`\n* `lineWidthMaxPixels`\n* `lineWidthUnits`\n* `lineJointRounded`\n* `lineMiterLimit`\n* `pointRadiusScale`\n* `pointRadiusMinPixels`\n* `pointRadiusMaxPixels`\n* `lineDashJustified`\n* `fp64`\n\nThe following accessors function the same, but can accept additional arguments:\n\n* `getLineColor`\n* `getFillColor`\n* `getRadius`\n* `getLineWidth`\n* `getLineDashArray`\n\nThe additional arguments (in order) are:\n\n* `feature`: the given feature\n* `isSelected`: indicates if the given feature is a selected feature\n* `mode`: the current value of the `mode` prop\n\n### Tentative Features\n\nWhile creating a new feature in any of the `draw` modes, portion of a feature which has not been \"committed\" yet can hold its own props. For example, in `drawLineString` mode, the tentative feature is the last line segment moving under the mouse. For polygons and ellipses, this would be the whole feature during drawing. Define the properties with the following accessors:\n\n* `getTentativeLineColor`\n* `getTentativeFillColor`\n* `getTentativeLineWidth`\n* `getTentativeLineDashArray`\n\nThe following accessors default to the same values as the existing feature accessors above. The arguments in order:\n\n* `feature`: the segment/polygon that represents the tentative feature\n* `mode`: the current value of the `mode` prop\n\n### Edit Handles\n\nEdit handles are the points rendered on a feature to indicate interactive capabilities (e.g. vertices that can be moved).\n\n* `type` (String): either `existing` for existing positions or `intermediate` for positions half way between two other positions.\n\n#### `editHandleType` (String, optional)\n\n* Default: `point`\n\n* `point`: Edit handles endered as points\n\n* `icons`: Edit handles rendered as provided icons\n\nEdit handle objects can be represented by either points or icons. `editHandlePoint...` are proxies for the [`ScatterplotLayer`](https://github.com/uber/deck.gl/blob/master/docs/layers/scatterplot-layer.md#properties) props, and `editHandleIcon...` are proxies for the [`IconLayer`](https://github.com/uber/deck.gl/blob/master/docs/layers/icon-layer.md#properties) props.\n\n#### `editHandleParameters` (Object, optional)\n\n* Default: `{}`\n\n* Set luma.gl parameters for handles (eg. depthTest, blend)\n\n#### `editHandlePointRadiusScale` (Number, optional)\n\n* Default: `1`\n\n#### `editHandlePointOutline` (Boolean, optional)\n\n* Default: `false`\n\n#### `editHandlePointStrokeWidth` (Number, optional)\n\n* Default: `1`\n\n#### `editHandlePointRadiusMinPixels` (Number, optional)\n\n* Default: `4`\n\n#### `editHandlePointRadiusMaxPixels` (Number, optional)\n\n* Default: `Number.MAX_SAFE_INTEGER`\n\n#### `getEditHandlePointColor` (Function | Array, optional)\n\n* Default: `handle => handle.type === 'existing' ? [0xc0, 0x0, 0x0, 0xff] : [0x0, 0x0, 0x0, 0x80]`\n\n#### `getEditHandlePointRadius` (Function | Number, optional)\n\n* Default: `handle => (handle.type === 'existing' ? 5 : 3)`\n\n#### `editHandleIconAtlas` (Texture2D | String, optional)\n\n* Default: `null`\n\nAtlas image url or texture.\n\n#### `editHandleIconMapping` (Object | String, optional)\n\n* Default: `null`\n\nIcon names mapped to icon definitions. See [`Icon Layer`](https://github.com/uber/deck.gl/blob/master/docs/layers/icon-layer.md#iconmapping-object--string-required).\n\n#### `editHandleIconSizeScale` (Number | optional)\n\n* Default: `null`\n\nEdit handle icon size multiplier.\n\n#### `getEditHandleIcon` (Function, optional)\n\n* Default: `handle => handle.type`\n\nMethod called to retrieve the icon name of each edit handle, returns string.\n\n#### `getEditHandleIconSize` (Function | Number, optional)\n\n* Default: `10`\n\nThe height of each edit handle, in pixels.\n\n#### `getEditHandleIconColor` (Function | Array, optional)\n\n* Default: `handle => handle.type === 'existing' ? [0xc0, 0x0, 0x0, 0xff] : [0x0, 0x0, 0x0, 0x80]`\n\n#### `getEditHandleIconAngle` (Function | Number, optional)\n\n* Default: `0`\n\nThe rotating angle of each object, in degrees.\n\n## Methods\n\nThese methods can be overridden in a derived class in order to customize event handling.\n\n### `onLayerClick`\n\nThe pointer went down and up without dragging. This method is called regardless if something was picked.\n\n#### `event` argument\n\n* `picks` (Array): An array containing [deck.gl Picking Info Objects](https://uber.github.io/deck.gl/#/documentation/developer-guide/adding-interactivity?section=what-can-be-picked-) for all objects that were under the pointer when clicked, or an empty array if nothing from this layer was under the pointer.\n* `screenCoords` (Array): `[x, y]` screen pixel coordinates relative to the deck.gl canvas.\n* `groundCoords` (Array): `[lng, lat]` ground coordinates.\n\n### `onStartDragging`\n\nThe pointer went down on something rendered by this layer and the pointer started to move.\n\n* `picks` (Array): An array containing [deck.gl Picking Info Objects](https://uber.github.io/deck.gl/#/documentation/developer-guide/adding-interactivity?section=what-can-be-picked-) for all objects that were under the pointer when it went down.\n* `screenCoords` (Array): `[x, y]` screen pixel coordinates relative to the deck.gl canvas where the pointer was when it was considered to start dragging (should be very close to `pointerDownScreenCoords`).\n* `groundCoords` (Array): `[lng, lat]` ground coordinates where the pointer was when it was considered to start dragging (should be very close to `pointerDownGroundCoords`).\n* `pointerDownScreenCoords` (Array): `[x, y]` screen pixel coordinates relative to the deck.gl canvas where the pointer went down.\n* `pointerDownGroundCoords` (Array): `[lng, lat]` ground coordinates where the pointer went down.\n\n_Note: this method is not called if nothing was picked when the pointer went down_\n\n### `onStopDragging`\n\nThe pointer went down on something rendered by this layer, the pointer moved, and now the pointer is up.\n\n* `picks` (Array): An array containing [deck.gl Picking Info Objects](https://uber.github.io/deck.gl/#/documentation/developer-guide/adding-interactivity?section=what-can-be-picked-) for all objects that were under the pointer when it went down.\n* `screenCoords` (Array): `[x, y]` screen pixel coordinates relative to the deck.gl canvas where the pointer went up.\n* `groundCoords` (Array): `[lng, lat]` ground coordinates where the pointer went up.\n* `pointerDownScreenCoords` (Array): `[x, y]` screen pixel coordinates relative to the deck.gl canvas where the pointer went down.\n* `pointerDownGroundCoords` (Array): `[lng, lat]` ground coordinates where the pointer went down.\n\n### `onPointerMove`\n\nThe pointer moved, regardless of whether the pointer is down, up, and whether or not something was picked\n\n* `screenCoords` (Array): `[x, y]` screen pixel coordinates relative to the deck.gl canvas where the pointer is now.\n* `groundCoords` (Array): `[lng, lat]` ground coordinates where the pointer is now.\n* `picks` (Array): An array containing [deck.gl Picking Info Objects](https://uber.github.io/deck.gl/#/documentation/developer-guide/adding-interactivity?section=what-can-be-picked-) for all objects that are under the pointer now.\n* `isDragging` (Boolean): `true` if the pointer went down and has moved enough to consider the movement a drag gesture, otherwise `false`.\n* `pointerDownPicks` (Array): An array containing [deck.gl Picking Info Objects](https://uber.github.io/deck.gl/#/documentation/developer-guide/adding-interactivity?section=what-can-be-picked-) for all objects that were under the pointer when it went down, if any. This will be populated even if the pointer hasn't yet moved enough to set `isDragging` to `true`.\n* `pointerDownScreenCoords` (Array): `[x, y]` screen pixel coordinates relative to the deck.gl canvas where the pointer went down.\n* `pointerDownGroundCoords` (Array): `[lng, lat]` ground coordinates where the pointer went down.\n","slug":"docs/api-reference/layers/editable-geojson-layer","title":"EditableGeoJsonLayer"},{"excerpt":"Mode Handlerss provide a way of handling user interactions in order to manipulate GeoJSON features and geometries.The following are the…","rawMarkdownBody":"# Mode Handlers\n\n`ModeHandler`s provide a way of handling user interactions in order to manipulate GeoJSON features and geometries.\n\nThe following are the built-in, and default `ModeHandler`s provided by nebula.gl:\n\n## [ViewHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/view-handler.js)\n\n* Mode name: `view`\n\nNo edits are possible, but selection is still possible.\n\n## [ModifyHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/modify-handler.js)\n\n* Mode name: `modify`\n\nUser can move existing points, add intermediate points along lines, and remove points.\n\n### Edit Context\n\n`editContext` argument to the `onEdit` callback contains the following properties:\n\n* `positionIndexes` (Array): An array of numbers representing the indexes of the edited position within the feature's `coordinates` array\n\n* `position` (Array): An array containing the ground coordinates (i.e. [lng, lat]) of the edited position\n\n## [ExtrudeHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/extrude-handler.js)\n\n* Mode name: `extrude`\n\nUser can move edge. Click and drag from anywhere between 2 points in edge.\n\n## [ScaleHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/scale-handler.js)\n\n* Mode name: `scale`\n\nUser can scale a feature about its centroid by clicking and dragging (inward or outward) the selected geometry. This mode supports multiple selections.\n\n## [RotateHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/rotate-handler.js)\n\n* Mode name: `rotate`\n\nUser can rotate a feature about its centroid by clicking and dragging the selected geometry. This mode supports multiple selections.\n\n## [TranslateHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/translate-handler.js)\n\n* Mode name: `translate`\n\nThe user can move a feature by selecting one or more features and dragging anywhere within the screen.\n_Additionally, the user can initiate snapping by clicking and dragging the selected feature's vertex handles. If the vertex handle is close enough to another feature's vertex, the two features will snap together._\n\n## [DuplicateHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/duplicate-handler.js)\n\n* Mode name: `duplicate`\n\nUser can duplicate and translate a feature by clicking selected feature and dragging anywhere on the screen.\nThis mode is extends TranslateHandler. This mode supports multiple selections.\n\n## [DrawPointHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-point-handler.js)\n\n* Mode name: `drawPoint`\n\nUser can draw a new `Point` feature by clicking where the point is to be.\n\n## [DrawLineStringHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-line-string-handler.js)\n\n* Mode name: `drawLineString`\n\nUser can draw a new `LineString` feature by clicking positions to add.\n\n* If a `LineString` feature is selected, clicking will add a position to it.\n\n* If no feature is selected, a new `LineString` feature will be added. *Note*: you must select the new feature (via the `onEdit` callback) in order to start extending it.\n\n* If multiple features are selected, or a non-`LineString` is selected, the user will be prevented from drawing.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `drawAtFront` (optional):  `<boolean>`\n  * If `true`, will render the tentative feature at the \"beginning\" of the line, i.e. relative to the start of the coordinates array.\n\n### Edit Context\n\n`editContext` argument to the `onEdit` callback contains the following properties:\n\n* `positionIndexes` (Array): An array of numbers representing the indexes of the added position within the feature's `coordinates` array\n\n* `position` (Array): An array containing the ground coordinates (i.e. [lng, lat]) of the added position\n\n## [DrawPolygonHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-polygon-handler.js)\n\n* Mode name: `drawPolygon`\n\nUser can draw a new `Polygon` feature by clicking positions to add then closing the polygon (or double-clicking).\n\n### Edit Context\n\n`editContext` argument to the `onEdit` callback contains the following properties:\n\n* `positionIndexes` (Array): An array of numbers representing the indexes of the added position within the feature's `coordinates` array\n\n* `position` (Array): An array containing the ground coordinates (i.e. [lng, lat]) of the added position\n\n## [Draw90DegreePolygonHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-90degree-polygon-handler.js)\n\n* Mode name: `draw90DegreePolygon`\n\nUser can draw a new `Polygon` feature with 90 degree corners (right angle) by clicking positions to add then closing the polygon (or double-clicking). After clicking the 2 points, the draw mode guides/allows to have right angle polygon.\n\n## [DrawRectangleHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-rectangle-handler.js)\n\n* Mode name: `drawRectangle`\n\nUser can draw a new rectangular `Polygon` feature by clicking two opposing corners of the rectangle.\n\n## [DrawRectangleUsingThreePointsHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-rectangle-using-three-points-handler.js)\n\n* Mode name: `drawRectangleUsing3Points`\n\nUser can draw a new rectangular `Polygon` feature by clicking three corners of the rectangle.\n\n## [DrawCircleFromCenterHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-circle-from-center-handler.js)\n\n* Mode name: `drawCircleFromCenter`\n\nUser can draw a new circular `Polygon` feature by clicking the center then along the ring.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `steps` (optional):  `x <number>`\n  * If steps: `x` means the circle will be drawn using `x` number of points.\n\n## [DrawCircleByBoundingBoxHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-circle-by-bounding-box-handler.js)\n\n* Mode name: `drawCircleByBoundingBox`\n\nUser can draw a new circular `Polygon` feature by clicking the two corners of bounding box.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `steps` (optional):  `x <number>`\n  * If steps: `x` means the circle will be drawn using `x` number of points.\n\n## [DrawEllipseByBoundingBoxHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-ellipse-by-bounding-box-handler.js)\n\n* Mode name: `drawEllipseByBoundingBox`\n\nUser can draw a new ellipse shape `Polygon` feature by clicking two corners of bounding box.\n\n## [DrawEllipseUsingThreePointsHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/draw-ellipse-using-three-points-handler.js)\n\n* Mode name: `drawEllipseUsing3Points`\n\nUser can draw a new ellipse shape `Polygon` feature by clicking center and two corners of the ellipse.\n\n## [SplitPolygonHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/split-polygon-handler.js)\n\n* Mode name: `split`\n\nUser can split a polygon by drawing a new `LineString` feature on top of the polygon.\n\n* If the first and the last click is outside the polygon, it will split the polygon\n\n* If the clicked position is inside the polygon, it will not split the polygon\n\n## [ElevationHandler](https://github.com/uber/nebula.gl/blob/master/modules/layers/src/mode-handlers/elevation-handler.js)\n\n* Mode name: `elevation`\n\nUser can move a point up and down.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `minElevation` (Number, optional)\n  * The minimum elevation to allow\n  * Default: `0`\n\n* `maxElevation` (Number, optional)\n  * The maximum elevation to allow\n  * Default: `20000`\n\n* `calculateElevationChange` (Function, optional)\n  * A function to use to calculate the elevation change in response to mouse movement\n  * Default: `10 * <vertical movement in pixels>`\n  * Configure to use movement based on viewport:\n\n```javascript\nif (mode === 'elevation') {\n  modeConfig.calculateElevationChange = (opts) =>\n    ElevationHandler.calculateElevationChangeWithViewport(viewport, opts);\n}\n```\n\n## Boolean Operations\n\nFor all polygon drawing modes, the following options can be provided in the `modeConfig` object:\n\n* `booleanOperation` (optional):  `null|'union'|'difference'|'intersection'`\n  * If non-null, requires a single `Polygon` or `MultiPolygon` selection\n  * If `null`, the drawn `Polygon` is added as a new feature regardless of selection\n  * If `union`, the drawn `Polygon` is unioned with the selected geometry\n  * If `difference`, the drawn `Polygon` is subtracted from the selected geometry\n  * If `intersection`, the drawn `Polygon` is intersected with the selected geometry\n\n## Composite Mode Handler\n\nUse `CompositeModeHandler` to combine multiple handlers.\n_Not all combinations are guaranteed to work._\n\n### Constructor\n\n`new CompositeModeHandler(handlers, options = {})`\n\n* `handlers`: `Array<ModeHandler>` Handlers you want to combine. **Order is very important.**\n* `options` (optional): Options to be added later.\n\n### Example\n\n```\nconst modeHandlers = Object.assign(\n  {\n    'drawLineString+modify': new CompositeModeHandler([\n      new DrawLineStringHandler(),\n      new ModifyHandler()\n    ])\n  },\n  EditableGeoJsonLayer.defaultProps.modeHandlers\n);\n```\n","slug":"docs/api-reference/mode-handlers/overview","title":"Mode Handlers"},{"excerpt":"HtmlOverlayItemThis is an HTML item that will be rendered inside\nHtmlOverlay or\nHtmlClusterOverlay.PropscoordinatesArray of two numbers…","rawMarkdownBody":"# HtmlOverlayItem\n\nThis is an HTML item that will be rendered inside\n[HtmlOverlay](documentation/api-reference/htmloverlay) or\n[HtmlClusterOverlay](documentation/api-reference/htmlclusteroverlay).\n\n\n```js\nreturn (\n  <HtmlOverlayItem\n    style={{\n      transform: 'translate(-50%,-50%)',\n      pointerEvents: 'all'\n    }}\n    coordinates={coordinates}\n    key={key}\n  >\n    YOUR CONTENT HERE.\n  </HtmlOverlayItem>\n);\n```\n\n## Props\n### coordinates\nArray of two numbers where this will be displayed.\n\n## Best practices\n\n### Anchor point\nBy default the top-left corner will align with the provided `coordinates`.\nYou can use CSS to change the **anchor point**.\nFor example use `transform: 'translate(-50%,-50%)'` to center.\n\n\n### Mouse events\nBy default this will not receive any mouse events.\nUse `pointerEvents: 'all'` to receive events.\n\n\n### Key property\nBecause this is used inside an array of `react components` you\nneed to provide a unique `key`. See the [React docs](https://reactjs.org/docs/lists-and-keys.html)\n\n","slug":"docs/api-reference/overlays/html-overlay-item","title":"HtmlOverlayItem"},{"excerpt":"SelectionLayerThis layer can be used to select deck.gl objects using mouse drawing.PropertiesInherits all deck.gl's Base Layer properties…","rawMarkdownBody":"# SelectionLayer\n\nThis layer can be used to select deck.gl objects using mouse drawing.\n\n```js\nlayers.push(\n  new SelectionLayer({\n    id: 'selection',\n    selectionType: this.state.selectionTool,\n    onSelect: ({ pickingInfos }) => {\n      this.setState({ selectedFeatureIndexes: pickingInfos.map(pi => pi.index) });\n    },\n    layerIds: ['geojson'],\n\n    getTentativeFillColor: () => [255, 0, 255, 100],\n    getTentativeLineColor: () => [0, 0, 255, 255],\n    getTentativeLineDashArray: () => [0, 0],\n    lineWidthMinPixels: 3\n  })\n);\n```\n\n\n## Properties\n\nInherits all [deck.gl's Base Layer](https://uber.github.io/deck.gl/#/documentation/deckgl-api-reference/layers/layer) properties.\n\nAlso inherites **some** EditableGeoJsonLayer properties.\n\n> Note: do not pass a data property.\n\n#### `selectionType` (String, required)\n\n* Default: `null`\n\nSELECTION_TYPE.RECTANGLE or SELECTION_TYPE.POLYGON\n\n#### `onSelect` (Function, required)\n\nCalled when selection is completed.\n\n#### `layerIds` (String[], required)\n\nArray of layer ids where we will search.\n\n","slug":"docs/api-reference/layers/selection-layer","title":"SelectionLayer"},{"excerpt":"HtmlClusterOverlayUse this class if you have HTML items that need to be displayed at specific geo coordinates on the map\nand cluster based…","rawMarkdownBody":"# HtmlClusterOverlay\n\nUse this class if you have HTML items that need to be displayed at specific geo coordinates on the map\nand cluster based on the zoom level.\n**You need to subclass this class**. Then use it as a `react component` inside `Nebula`.\n\n\n```js\n<Nebula\n  ref={nebula => (this.nebula = nebula || this.nebula)}\n  {...{ layers, viewport }}\n>\n  <YourNewClass />\n</Nebula>\n```\n\n\n## Methods to override\n### getAllObjects()\nOverride to provide an array of `Objects` that need clustering.\nIf the items have not changed please provide the same array to avoid\nregeneration of the cluster which causes performance issues.\n\n### getObjectCoordinates(object)\nOverride to provide coordinates for each object of getAllObjects().\nReturn array of two numbers.\n\n### renderObject(coordinates, object)\nOverride to return an `HtmlOverlayItem` for the single `object` at `coordinates`.\n\n### renderCluster(coordinates, clusterId, pointCount)\nOverride to return an HtmlOverlayItem for the `cluster` at `coordinates`.\n`pointCount` is the number of objects that are represented by that cluster.\nUse `getClusterObjects(clusterId)` to get cluster contents.\n\n\n\n## Methods\n\n### getClusterObjects(clusterId)\nReturns an array of objects.\n\n### getClusterOptions()\nOverride to return options used when instantiating the overlay and thus the \nunderlying [supercluster](https://www.npmjs.com/package/supercluster#options) object.\n\n\n","slug":"docs/api-reference/overlays/html-cluster-overlay","title":"HtmlClusterOverlay"},{"excerpt":"HtmlOverlayUse this class if you have HTML items that need to be displayed at specific geo coordinates on the map.\nIf you need clustering…","rawMarkdownBody":"# HtmlOverlay\n\nUse this class if you have HTML items that need to be displayed at specific geo coordinates on the map.\nIf you need clustering see [HtmlClusterOverlay](documentation/api-reference/htmlclusteroverlay).\n**You need to subclass this class.** Then use it as a `react component` inside `Nebula`.\n\n\n```js\n<Deck ...>\n  <YourNewClass />\n</Deck>\n```\n\n## Properties\n### zIndex\n\nDefault is `1`. Set to `0` to move items _under_ deck.gl layer.\n\n## Methods to override\n### getItems()\nProvide an array of [HtmlOverlayItem](documentation/api-reference/htmloverlayitem).\n\n\n","slug":"docs/api-reference/overlays/html-overlay","title":"HtmlOverlay"},{"excerpt":"HtmlTooltipOverlayYou can add this  under  to enable tooltips.Example","rawMarkdownBody":"# HtmlTooltipOverlay\n\nYou can add this `react component` under `Nebula` to enable tooltips.\n\n\n## Example\n\n```js\n<Nebula\n  ref={nebula => (this.nebula = nebula || this.nebula)}\n  {...{ layers, viewport }}\n>\n  <HtmlTooltipOverlay />\n</Nebula>\n```\n","slug":"docs/api-reference/overlays/html-tooltip-overlay","title":"HtmlTooltipOverlay"},{"excerpt":"NebulaOverlayUse HtmlOverlay","rawMarkdownBody":"# NebulaOverlay\n\nUse [HtmlOverlay](documentation/api-reference/htmloverlay)\n","slug":"docs/api-reference/overlays/nebula-overlay","title":"NebulaOverlay"}]}}