{"version":3,"sources":["webpack:///../modules/main/src/lib/style.js","webpack:///../modules/main/src/lib/deck-renderer/deck-drawer.js","webpack:///../modules/main/src/lib/nebula-layer.js","webpack:///../modules/edit-modes/src/lib/edit-mode.js","webpack:///../modules/edit-modes/src/lib/immutable-feature-collection.js","webpack:///../modules/edit-modes/src/lib/geojson-edit-mode.js","webpack:///../modules/edit-modes/src/lib/view-mode.js","webpack:///../modules/edit-modes/src/lib/draw-polygon-mode.js","webpack:///../modules/layers/src/mode-handlers/mode-handler.js","webpack:///../modules/layers/src/mode-handlers/view-handler.js","webpack:///../modules/layers/src/utils.js","webpack:///../modules/layers/src/mode-handlers/modify-handler.js","webpack:///../modules/layers/src/mode-handlers/elevation-handler.js","webpack:///../modules/layers/src/mode-handlers/snappable-handler.js","webpack:///../modules/layers/src/mode-handlers/translate-handler.js","webpack:///../modules/layers/src/mode-handlers/duplicate-handler.js","webpack:///../modules/layers/src/mode-handlers/rotate-handler.js","webpack:///../modules/layers/src/mode-handlers/scale-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-point-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-line-string-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-90degree-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/two-click-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-rectangle-handler.js","webpack:///../modules/layers/src/mode-handlers/split-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/three-click-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-rectangle-using-three-points-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-circle-from-center-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-circle-by-bounding-box-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-ellipse-by-bounding-box-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-ellipse-using-three-points-handler.js","webpack:///../modules/layers/src/mode-handlers/extrude-handler.js","webpack:///../modules/layers/src/layers/editable-layer.js","webpack:///../modules/layers/src/layers/editable-geojson-layer.js","webpack:///../modules/layers/src/layers/editable-layer-edit-mode-poc.js","webpack:///../modules/layers/src/layers/editable-geojson-layer-edit-mode-poc.js","webpack:///../modules/layers/src/layers/selection-layer.js","webpack:///../modules/layers/src/layers/elevated-edit-handle-layer.js","webpack:///../modules/layers/src/shaderlib/outline/outline.js","webpack:///../modules/layers/src/layers/path-outline-layer/path-outline-layer.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer-vertex.glsl.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer-fragment.glsl.js","webpack:///../modules/layers/src/layers/path-marker-layer/arrow-2d-geometry.js","webpack:///../modules/layers/src/layers/path-marker-layer/create-path-markers.js","webpack:///../modules/layers/src/layers/path-marker-layer/polyline.js","webpack:///../modules/layers/src/layers/path-marker-layer/path-marker-layer.js","webpack:///../modules/layers/src/layers/junction-scatterplot-layer.js","webpack:///../modules/layers/src/mode-handlers/composite-mode-handler.js","webpack:///../modules/main/src/lib/layers/segments-layer.js","webpack:///../examples/advanced/toolbox.js","webpack:///../examples/advanced/example.js","webpack:///./src/pages/geojson-editor.js","webpack:///../examples/data/edit-handles.png"],"names":["ArrowStyles","SELECTION_TYPE","EventEmitter","BaseEditMode","_proto","prototype","getState","this","state","updateState","_this","prevState","changedEvents","data","modeConfig","selectedIndexes","guides","fn","handleClick","handlePointerMove","handleStartDragging","handleStopDragging","onDataChanged","onModeConfigChanged","onSelectedIndexesChanged","onGuidesChanged","getData","getModeConfig","getSelectedIndexes","getGuides","getCursor","cursor","onEdit","editAction","onUpdateGuides","onUpdateCursor","ImmutableFeatureCollection","featureCollection","getObject","replacePosition","geometry","features","featureIndex","isPolygonal","updatedGeometry","Object","assign","coordinates","immutablyReplacePosition","positionIndexes","updatedPosition","replaceGeometry","removePosition","Error","immutablyRemovePosition","type","polygon","holeIndex","length","removeHoleIfNecessary","prunePolygonIfNecessary","lineStringIndex","lineString","pruneMultiLineStringIfNecessary","polygonIndex","outerRing","pruneMultiPolygonIfNecessary","pruneGeometryIfNecessary","addPosition","immutablyAddPosition","positionToAdd","updatedFeature","concat","slice","addFeature","feature","getUpdatedPosition","previousPosition","elevation","updated","hole","DEFAULT_EDIT_HANDLES","BaseGeoJsonEditMode","_BaseEditMode","call","_clickSequence","setFeatureCollection","inheritsLoose_default","getFeatureCollection","getImmutableFeatureCollection","getSelectedFeature","getSelectedGeometry","getSelectedFeaturesAsFeatureCollection","getSelectedFeatureIndexes","map","selectedIndex","_refreshEditHandles","setModeConfig","console","setSelectedFeatureIndexes","_setTentativeFeature","tentativeFeature","getClickSequence","resetClickSequence","getTentativeFeature","getEditHandles","editHandles","getEditHandlesAdapter","picks","mapCoords","_refreshCursor","currentCursor","updatedCursor","getCursorAdapter","isDragging","_ref3","isSelectionPicked","pickedIndexes","_ref4","index","some","getAddFeatureAction","geometryAsAny","updatedData","properties","editType","editContext","featureIndexes","getAddManyFeaturesAction","initialIndex","updatedIndexes","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref5","next","done","value","getAddFeatureOrBooleanPolygonAction","selectedFeature","booleanOperation","turfUnion","turfDifference","turfIntersect","handleClickAdapter","event","_this$handlePointerMo","handlePointerMoveAdapter","cancelMapPan","handleStartDraggingAdapter","handleStopDraggingAdapter","push","getEditHandlesForCoordinates","positionIndexPrefix","editHandleType","i","position","ViewMode","_BaseGeoJsonEditMode","apply","arguments","geojson_edit_mode_BaseGeoJsonEditMode","DrawPolygonMode","handles","a","b","_a","getEditHandlesForGeometry","clickedEditHandle","info","find","pick","isGuide","object","getPickedEditHandle","clickSequence","polygonToAdd","fakePointerMoveEvent","screenCoords","pointerDownPicks","pointerDownScreenCoords","pointerDownMapCoords","sourceEvent","_ref","result","ModeHandler","_modeConfig","_selectedFeatureIndexes","indexes","_tentativeFeature","_ref2","groundCoords","mode_handler_getPickedEditHandle","isEditingHandle","mode_handler_getIntermediatePosition","position1","position2","mode_handler_getEditHandlesForGeometry","mode_handler_getEditHandlesForCoordinates","ViewHandler","_ModeHandler","mode_handler_ModeHandler","generatePointsParallelToLinePoints","p1","p2","pt","point","ddistance","pointToLineDistance","lineBearing","bearing","orthogonalBearing","isPointToLeftOfLine","p3","destination","p4","distance2d","x1","y1","x2","y2","dx","dy","Math","ModifyHandler","_handles","_index","featureAsPick","includes","intermediatePoint","referencePoint","recursivelyTraverseNestedArrays","array","prefix","lineStringFeature","toLineString","candidateIntermediatePoint","nearestPointOnLine","dist","_intermediatePoint","line","coord","viewport","inPoint","projectedCoords","x","y","_ref$","z","_viewport$project","minDistance","Infinity","minPointInfo","_projectedCoords","A","B","C","div","distance","x0","y0","_minPointInfo","_projectedCoords2","_projectedCoords2$","z1","_projectedCoords$inde","_projectedCoords$inde2","z2","lineLength","z0","ratio","mix","nearestPointOnProjectedLine","ignored","_updatedData","_lastPointerMovePicks","editHandle","Boolean","selectedFeatureIndexes","defaultCalculateElevationChange","ElevationHandler","_ModifyHandler","makeElevatedEvent","_ref2$minElevation","minElevation","_ref2$maxElevation","maxElevation","_ref2$calculateElevat","calculateElevationChange","params","calculateElevationChangeWithViewport","PI","zoom","modify_handler_ModifyHandler","SnappableHandler","handler","_handler","_getSnappedMouseEvent","snapPoint","pointerDownGroundCoords","_startDragSnapHandlePosition","_getEditHandlePicks","potentialSnapHandle","pickedHandle","_updatePickedHandlePosition","_editHandlePicks","reduce","_getSnapTargets","additionalSnapTargets","_getNonPickedIntermediateHandles","enableSnapping","_performSnapIfRequired","_isSnapped","_ref6","_performUnsnapIfRequired","_getSnapAwareEvent","modeActionSummary","TranslateHandler","_isTranslatable","_geometryBeforeTranslate","getTranslateAction","startDragPoint","currentPoint","distanceMoved","turfDistance","direction","turfBearing","movedFeatures","turfTransformTranslate","movedFeature","DuplicateHandler","_TranslateHandler","translate_handler_TranslateHandler","RotateHandler","_isRotatable","_geometryBeingRotated","getRotateAction","startPosition","angle","centroid","bearing1","getRotationAngle","turfCentroid","rotatedFeatures","turfTransformRotate","ScaleHandler","_isScalable","_geometryBeingScaled","getScaleAction","factor","startDistance","getScaleFactor","scaledFeatures","turfTransformScale","origin","DrawPointHandler","DrawLineStringHandler","selectedGeometry","drawAtFront","DrawPolygonHandler","Draw90DegreePolygonHandler","finalizedCoordinates","coords","getIntermediatePoint","tc","angle1","angle2","angles","first","second","forEach","newAngle1","newAngle2","indexFirst","line1","indexSecond","line2","fc","lineIntersect","TwoClickPolygonHandler","DrawRectangleHandler","_TwoClickPolygonHandl","corner1","corner2","bboxPolygon","two_click_polygon_handler_TwoClickPolygonHandler","SplitPolygonHandler","calculateGroundCoords","lock90Degree","firstPoint","turfPolygonToLine","lines","Number","MAX_SAFE_INTEGER","closestPoint","distanceFromOrigin","lastBearing","currentDistance","units","destination_default","lastPoint","approximatePoint","isPointInPolygon","booleanPointInPolygon","isLineInterectingWithPolygon","splitPolygon","_modeConfig$gap","gap","_modeConfig$units","buffer","turfBuffer","_updatedGeometry$geom","updatedCoordinates","c","agg","prev","p","ThreeClickPolygonHandler","DrawRectangleUsingThreePointsHandler","_ThreeClickPolygonHan","_generatePointsParall","three_click_polygon_handler_ThreeClickPolygonHandler","DrawCircleFromCenterHandler","_modeConfig$steps","steps","options","centerCoordinates","radius","circle","DrawCircleByBoundingBoxHandler","firstClickedPoint","getIntermediatePosition","DrawEllipseByBoundingBoxHandler","minX","minY","maxX","maxY","polygonPoints","xSemiAxis","ySemiAxis","ellipse","DrawEllipseUsingThreePointsHandler","ExtrudeHandler","_len","args","_key","isPointAdded","size","coordinatesSize","nextPositionIndexes","getPointForPositionIndexes","prevPositionIndexes","isOrthogonal","_generatePointsParall2","getBearing","prevPoint","nextPoint","prevAngle","nextAngle","EditableLayer","onLayerClick","onDoubleClick","onStartDragging","onStopDragging","onPointerMove","initializeState","setState","_editableLayerState","pointerHandlers","finalizeState","_removePointerHandlers","props","changeFlags","_addPointerHandlers","context","gl","canvas","removeEventListener","onPointerDown","onPointerUp","_onPointerMove","bind","_onPointerDown","_onPointerUp","_onDoubleClick","addEventListener","getScreenCoords","getGroundCoords","deck","pickMultipleObjects","layerIds","id","pickingRadius","depth","pickingDepth","_this$state$_editable","movedEnoughForDrag","_this$state$_editable2","pointerEvent","getBoundingClientRect","unproject","screenCoords1","screenCoords2","CompositeLayer","DEFAULT_LINE_COLOR","DEFAULT_FILL_COLOR","DEFAULT_SELECTED_LINE_COLOR","DEFAULT_SELECTED_FILL_COLOR","DEFAULT_EDITING_EXISTING_POINT_COLOR","DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","DEFAULT_EDITING_SNAP_POINT_COLOR","DEFAULT_EDITING_EXISTING_POINT_RADIUS","DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","DEFAULT_EDITING_SNAP_POINT_RADIUS","getEditHandleColor","handle","defaultProps","mode","pickable","fp64","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","lineWidthUnits","lineJointRounded","lineMiterLimit","pointRadiusScale","pointRadiusMinPixels","pointRadiusMaxPixels","lineDashJustified","getLineColor","isSelected","getFillColor","getRadius","f","getLineWidth","lineWidth","getLineDashArray","getTentativeLineDashArray","getTentativeLineColor","getTentativeFillColor","getTentativeLineWidth","editHandleParameters","editHandleLayerProps","editHandlePointRadiusScale","editHandlePointOutline","editHandlePointStrokeWidth","editHandlePointRadiusMinPixels","editHandlePointRadiusMaxPixels","getEditHandlePointColor","getEditHandlePointRadius","editHandleIconAtlas","editHandleIconMapping","editHandleIconSizeScale","getEditHandleIcon","getEditHandleIconSize","getEditHandleIconColor","getEditHandleIconAngle","billboard","modeHandlers","view","view_handler_ViewHandler","modify","elevation_handler_ElevationHandler","extrude","extrude_handler_ExtrudeHandler","rotate","rotate_handler_RotateHandler","translate","snappable_handler_SnappableHandler","duplicate","duplicate_handler_DuplicateHandler","scale","scale_handler_ScaleHandler","drawPoint","draw_point_handler_DrawPointHandler","drawLineString","draw_line_string_handler_DrawLineStringHandler","drawPolygon","draw_polygon_handler_DrawPolygonHandler","draw90DegreePolygon","draw_90degree_polygon_handler_Draw90DegreePolygonHandler","split","split_polygon_handler_SplitPolygonHandler","drawRectangle","draw_rectangle_handler_DrawRectangleHandler","drawRectangleUsing3Points","draw_rectangle_using_three_points_handler_DrawRectangleUsingThreePointsHandler","drawCircleFromCenter","draw_circle_from_center_handler_DrawCircleFromCenterHandler","drawCircleByBoundingBox","draw_circle_by_bounding_box_handler_DrawCircleByBoundingBoxHandler","drawEllipseByBoundingBox","draw_ellipse_by_bounding_box_handler_DrawEllipseByBoundingBoxHandler","drawEllipseUsing3Points","draw_ellipse_using_three_points_handler_DrawEllipseUsingThreePointsHandler","EditableGeoJsonLayer","renderLayers","subLayerProps","getSubLayerProps","selectionAwareAccessor","_subLayerProps","line-strings","polygons-stroke","updateTriggers","layers","geojson_layer","_EditableLayer","selectedFeatures","shouldUpdateState","oldProps","oldContext","stateChanged","modeHandler","propsOrDataChanged","dataChanged","updateTentativeFeature","updateEditHandles","elem","accessor","isFeatureSelected","indexOf","getPickingInfo","sourceLayer","createEditHandleLayers","layer","sharedProps","layerName","parameters","icon_layer","iconAtlas","iconMapping","sizeScale","getIcon","getSize","getColor","getAngle","getPosition","d","scatterplot_layer","radiusScale","outline","strokeWidth","radiusMinPixels","radiusMaxPixels","EditHandleType","createTentativeLayers","_this2","autoHighlight","setLayerNeedsUpdate","_this$state$modeHandl","EditableLayer_EDIT_MODE_POC","getMapCoords","editable_geojson_layer_edit_mode_poc_getEditHandleColor","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_EXISTING_POINT_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_SNAP_POINT_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_SELECTED_LINE_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_LINE_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_SELECTED_FILL_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_FILL_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_EXISTING_POINT_RADIUS","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_SNAP_POINT_RADIUS","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","view_mode_ViewMode","draw_polygon_mode_DrawPolygonMode","EditableGeoJsonLayer_EDIT_MODE_POC","partialState","updateModeState","setNeedsRedraw","_this3","getActiveModeHandler","selectionType","onSelect","EMPTY_DATA","PASS_THROUGH_PROPS","SelectionLayer","_selectRectangleObjects","_this$props","_this$context$viewpor","project","_this$context$viewpor2","pickingInfos","pickObjects","width","height","_selectPolygonObjects","bigPolygon","_this$props2","mousePoints","allX","mousePoint","allY","landPointsPoly","bigBuffer","e","pendingPolygonSelection","blockerId","setTimeout","filter","item","_SELECTION_TYPE$RECTA","inheritedProps","undefined","editable_geojson_layer_EditableGeoJsonLayer","polygon_layer","opacity","obj","getPolygon","o","_ref2$changeFlags","ElevatedEditHandleLayer","line_layer","getSourcePosition","getTargetPosition","getStrokeWidth","INITIAL_STATE","outlineEnabled","outlineRenderShadowmap","outlineShadowmap","name","vs","fs","getUniforms","_temp","uniforms","injectShaderCode","source","_ref$code","code","PathOutlineLayer","getShaders","shaders","_PathLayer","modules","outlineFramebuffer","core_dist_esm","dummyTexture","attributeManager","addInstanced","instanceZLevel","GL","UNSIGNED_BYTE","update","calculateZLevels","draw","moduleParameters","rounded","miterLimit","widthScale","widthMinPixels","widthMaxPixels","dashJustified","jointType","alignMode","_this$state","color","model","updateModuleSettings","depthTest","blendEquation","MAX","framebuffer","getZLevel","pathTesselator","attribute","_updateAttribute","target","getValue","PathLayer","fp64LowPart","RADIAN_PER_DEGREE","getTexture","src","opts","urls","then","textures","catch","error","Promise","resolve","getTextureFromData","validateGeometryAttributes","attributes","condition","message","assert","getGeometry","positions","mesh","texture","min","depthFunc","LEQUAL","lightSettings","getYaw","getPitch","getRoll","MeshLayer","use64bitProjection","getAttributeManager","instancePositions","instancePositions64xy","calculateInstancePositions64xyLow","instanceRotations","calculateInstanceRotations","instanceColors","defaultValue","emptyTexture","Uint8Array","_updateFP64","setTexture","delete","getModel","render","isInstanced","shaderCache","sampler","hasTexture","setUniforms","isFP64","use64bitPositions","Float32Array","_iterator2","_isArray2","_i2","Layer","Arrow2DGeometry","_Geometry","getArrowAttributes","Geometry","_ref$length","_ref$headSize","headSize","_ref$tailWidth","tailWidth","_ref$tailStart","tailStart","texCoords","i3","normals","getLineLength","vPoints","DEFAULT_COLOR","DEFAULT_DIRECTION","forward","backward","createMarkerAlongPath","path","percentage","projectFlat","distanceAlong","previousDistance","along","vCenter","normalize","vDirection","vector2","subtract","verticalAngle","getClosestPointOnLine","_ref$clampToLine","clampToLine","lineVector","vector3","pointVector","dotProduct","clamp","DEFAULT_MARKER_LAYER","mesh_layer_MeshLayer","DEFAULT_MARKER_LAYER_PROPS","arrow_2d_geometry_Arrow2DGeometry","MarkerLayer","markerLayerProps","hightlightIndex","highlightPoint","getPath","getMarkerColor","getDirection","getMarkerPercentages","PathMarkerLayer","markers","coordinateSystem","COORDINATE_SYSTEM","METER_OFFSETS","_viewport$metersToLng","xyz","coordinateOrigin","LNGLAT_OFFSETS","_dx","_y","updateTriggersChanged","_ref$getPath","_ref$getDirection","_ref$getColor","create_path_markers_DEFAULT_COLOR","_ref$getMarkerPercent","vPointsReverse","reverse","marker","createPathMarkers","_recalculateClosestPoint","propsChanged","highlightIndex","points","pClosest","distanceSquared","pClosestOnLine","distanceToLineSquared","getClosestPointOnPolyline","closestPoints","path_outline_layer_PathOutlineLayer","blend","JunctionScatterplotLayer","getStrokeColor","getInnerRadius","ScatterplotLayer","CompositeModeHandler","handlers","_coalesce","resultEval","callback","_NEBULA_TO_DECK_DIREC","styles","toolboxItem","flexBasis","Toolbox","styled","withConfig","displayName","componentId","ToolboxRow","react_default","createElement","children","ToolboxControl","style","ToolboxTitle","buttonBackground","ToolboxButton","button","ToolboxCheckboxContainer","ToolboxCheckbox","EditableGeoJsonLayerImpl","window","mapContainer","alignItems","display","checkbox","margin","initialViewport","latitude","longitude","pitch","ALL_MODES","category","modes","POLYGON_DRAWING_MODES","drawLineString+modify","composite_mode_handler_CompositeModeHandler","FEATURE_COLORS","hex","parseInt","shift","example_getEditHandleColor","Example","_Component","_onChangeViewport","_onLayerClick","selectionTool","_resize","forceUpdate","_loadSample","testFeatures","sample_geojson","el","document","reader","FileReader","_parseStringJson","_copy","navigator","clipboard","JSON","_error","_paste","reason","_download","blob","Blob","URL","json","err","alert","pointsRemovable","showGeoJson","featureMenu","componentDidMount","componentWillUnmount","_getHtmlColorForFeature","join","selected","_getDeckColorForFeature","alpha","_renderSelectFeatureCheckbox","key","toolbox_ToolboxCheckbox","checked","onChange","featureType","right","onClick","clientX","clientY","_renderSelectFeatureCheckboxes","checkboxes","_renderBooleanOperationControls","toolbox_ToolboxRow","toolbox_ToolboxControl","operation","_renderDrawLineStringModeControls","_this4","_renderModifyModeControls","_this5","_renderSplitModeControls","_this6","_renderSnappingControls","_this7","_renderModeConfigControls","controls","_renderToolBox","_this8","Fragment","rows","renderStaticMap","dist_esm","mapStyle","_featureMenuClick","action","_renderFeatureMenu","_this9","top","left","customizeLayers","_this10","innerHeight","innerWidth","viewport_mercator_project_dist_esm","editableGeoJsonLayer","updatedSelectedFeatureIndexes","elevated_edit_handle_layer_ElevatedEditHandleLayer","edit_handles_default","intermediate","mask","existing","depthMask","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","selection_layer_SelectionLayer","pi","href","rel","esm_deckgl","viewState","views","esm","controller","doubleClickZoom","onViewStateChange","Component","Container","GeoJsonEditor","example_Example","module","exports"],"mappings":"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","file":"component---src-pages-geojson-editor-js-d24d5d66bb1cbb779818.js","sourcesContent":["// @flow\n// Describes the arrow style of polylines\nexport const ArrowStyles = {\n  NONE: 0,\n  FORWARD: 1,\n  BACKWARD: 2,\n  BOTH: 3\n};\n\nexport const DEFAULT_ARROWS = 1;\nexport const MAX_ARROWS = 3;\n\nexport const DEFAULT_STYLE = {\n  arrowColor: [0, 0, 0, 1],\n  arrowCount: DEFAULT_ARROWS,\n  arrowStyle: ArrowStyles.NONE,\n  fillColor: [0, 0, 0, 1],\n  lineColor: [0, 0, 0, 1],\n  lineWidthMeters: 5,\n  outlineRadiusMeters: 0,\n  opacity: 1,\n  zLevel: 0\n};\n","// @flow\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { point, polygon } from '@turf/helpers';\nimport turfBbox from '@turf/bbox';\nimport turfBboxPolygon from '@turf/bbox-polygon';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\nimport turfDistance from '@turf/distance';\n\nconst POLYGON_LINE_COLOR = [0, 255, 0, 255];\nconst POLYGON_FILL_COLOR = [255, 255, 255, 90];\nconst POLYGON_LINE_WIDTH = 2;\nconst POLYGON_DASHES = [20, 20];\nconst POLYGON_THRESHOLD = 0.01;\nconst EXPANSION_KM = 10;\nconst LAYER_ID_VIEW = 'DeckDrawerView';\nconst LAYER_ID_PICK = 'DeckDrawerPick';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nexport default class DeckDrawer {\n  nebula: Object;\n  usePolygon: boolean;\n  validPolygon: boolean;\n  landPoints: [number, number][];\n  mousePoints: [number, number][];\n\n  constructor(nebula: Object) {\n    this.nebula = nebula;\n    this.usePolygon = false;\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _getLayerIds() {\n    // TODO: sort by mouse priority\n    return this.nebula.deckgl.props.layers\n      .filter(l => l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enableSelection)\n      .map(l => l.id);\n  }\n\n  _selectFromPickingInfos(pickingInfos: Object[]) {\n    const objects = pickingInfos.map(\n      ({ layer, index, object }) =>\n        object.original || layer.props.nebulaLayer.deckCache.originals[index]\n    );\n    this.nebula.props.onSelection(objects);\n  }\n\n  _getBoundingBox(): Object {\n    const { mousePoints } = this;\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    return { x, y, width: maxX - x, height: maxY - y };\n  }\n\n  _selectRectangleObjects() {\n    if (this.landPoints.length !== 2) return;\n\n    const [x1, y1] = this.mousePoints[0];\n    const [x2, y2] = this.mousePoints[1];\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds: this._getLayerIds()\n    });\n\n    this._selectFromPickingInfos(pickingInfos);\n  }\n\n  _selectPolygonObjects() {\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      ...this._getBoundingBox(),\n      layerIds: [LAYER_ID_PICK, ...this._getLayerIds()]\n    });\n\n    this._selectFromPickingInfos(pickingInfos.filter(item => item.layer.id !== LAYER_ID_PICK));\n  }\n\n  _getMousePosFromEvent(event: Object): [number, number] {\n    const { offsetX, offsetY } = event;\n    return [offsetX, offsetY];\n  }\n\n  handleEvent(\n    event: Object,\n    lngLat: [number, number],\n    selectionType: number\n  ): { redraw: boolean, deactivate: boolean } {\n    // capture all events (mouse-up is needed to prevent us stuck in moving map)\n    if (event.type !== 'mouseup') event.stopPropagation();\n\n    this.usePolygon = selectionType === SELECTION_TYPE.POLYGON;\n\n    let redraw = false;\n    let deactivate = false;\n\n    const { usePolygon, landPoints, mousePoints } = this;\n\n    if (event.type === 'mousedown') {\n      if (usePolygon && landPoints.length) {\n        // if landPoints.length is zero we want to insert two points (so we let it run the else)\n        // also don't insert if polygon is invalid\n        if (this.landPoints.length < 3 || this.validPolygon) {\n          landPoints.push(lngLat);\n          mousePoints.push(this._getMousePosFromEvent(event));\n        }\n      } else {\n        this.landPoints = [lngLat, lngLat];\n        const m = this._getMousePosFromEvent(event);\n        this.mousePoints = [m, m];\n      }\n      redraw = true;\n    } else if (event.type === 'mousemove' && landPoints.length) {\n      // update last point\n      landPoints[landPoints.length - 1] = lngLat;\n      mousePoints[mousePoints.length - 1] = this._getMousePosFromEvent(event);\n      redraw = true;\n    } else if (event.type === 'mouseup') {\n      if (usePolygon) {\n        // check to see if completed\n        // TODO: Maybe double-click to finish?\n        if (\n          landPoints.length > 4 &&\n          turfDistance(landPoints[0], landPoints[landPoints.length - 1]) < POLYGON_THRESHOLD &&\n          this.validPolygon\n        ) {\n          this._selectPolygonObjects();\n          this.reset();\n          redraw = true;\n          deactivate = true;\n        }\n      } else {\n        this._selectRectangleObjects();\n        this.reset();\n        redraw = true;\n        deactivate = true;\n      }\n    }\n\n    return { redraw, deactivate };\n  }\n\n  reset() {\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _makeStartPointHighlight(center: [number, number]): number[] {\n    const buffer = turfBuffer(point(center), POLYGON_THRESHOLD / 4.0);\n    return turfBboxPolygon(turfBbox(buffer)).geometry.coordinates;\n  }\n\n  render() {\n    const data = [];\n    const dataPick = [];\n\n    if (!this.usePolygon && this.landPoints.length === 2) {\n      // Use mouse points instead of land points so we get the right shape\n      // no matter what bearing is.\n      const [[x1, y1], [x2, y2]] = this.mousePoints;\n      const selPolygon = [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]].map(mousePos =>\n        this.nebula.unprojectMousePosition(mousePos)\n      );\n      data.push({\n        polygon: selPolygon,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n    } else if (this.usePolygon && this.landPoints.length) {\n      data.push({\n        polygon: this.landPoints,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n\n      // Hack: use a polygon to hide the outside, because pickObjects()\n      // does not support polygons\n      if (this.landPoints.length >= 3) {\n        const landPointsPoly = polygon([[...this.landPoints, this.landPoints[0]]]);\n        const bigBuffer = turfBuffer(point(this.landPoints[0]), EXPANSION_KM);\n        let bigPolygon;\n        try {\n          // turfDifference throws an exception if the polygon\n          // intersects with itself\n          bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n          dataPick.push({\n            polygon: bigPolygon.geometry.coordinates,\n            fillColor: [0, 0, 0, 1]\n          });\n          this.validPolygon = true;\n        } catch (e) {\n          // invalid selection polygon\n          this.validPolygon = false;\n        }\n      }\n    }\n\n    if (this.landPoints.length) {\n      // highlight start point\n      data.push({\n        polygon: this._makeStartPointHighlight(this.landPoints[0]),\n        lineColor: [0, 0, 0, 0],\n        fillColor: POLYGON_LINE_COLOR\n      });\n    }\n\n    // Hack to make the PolygonLayer() stay active,\n    // otherwise it takes 3 seconds (!) to init!\n    // TODO: fix this\n    data.push({ polygon: [[0, 0]] });\n    dataPick.push({ polygon: [[0, 0]] });\n\n    return [\n      new PolygonLayer({\n        id: LAYER_ID_VIEW,\n        data,\n        fp64: false,\n        opacity: 1.0,\n        pickable: false,\n        lineWidthMinPixels: POLYGON_LINE_WIDTH,\n        lineWidthMaxPixels: POLYGON_LINE_WIDTH,\n        lineDashJustified: true,\n        getLineDashArray: x => POLYGON_DASHES,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        getPolygon: o => o.polygon\n      }),\n      new PolygonLayer({\n        id: LAYER_ID_PICK,\n        data: dataPick,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        fp64: false,\n        opacity: 1.0,\n        stroked: false,\n        pickable: true,\n        getPolygon: o => o.polygon\n      })\n    ];\n  }\n}\n","// @flow\nimport EventEmitter from 'events';\nimport uuid from 'uuid';\n\nimport Feature from './feature';\n\nexport default class NebulaLayer extends EventEmitter {\n  getData: () => Object[];\n  toNebulaFeature: (data: Object) => Feature;\n  id: string;\n  helperLayers: Object[];\n\n  // flags\n  usesMapEvents: boolean = false;\n  enablePicking: boolean = false;\n  enableSelection: boolean = false;\n  //\n\n  constructor({ getData, on, toNebulaFeature }: Object) {\n    super();\n    this.id = uuid.v4();\n    this.getData = getData;\n    this.toNebulaFeature = toNebulaFeature;\n    this.helperLayers = [];\n\n    if (on) {\n      Object.keys(on).forEach(key => this.on(key, on[key]));\n    }\n  }\n\n  render(config: Object): mixed {\n    return null;\n  }\n}\n","// @flow\n\nimport type {\n  EditAction,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../types.js';\n\nexport type ModeState<TData, TGuides> = {\n  // The data being edited, this can be an array or an object\n  data: TData,\n\n  // Additional configuration for this mode\n  modeConfig: any,\n\n  // The indexes of the selected features\n  selectedIndexes: number[],\n\n  // Features that can be used as a guide for editing the data\n  guides: ?TGuides,\n\n  // The cursor type, as a [CSS Cursor](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor)\n  cursor: string,\n\n  // Callback used to notify applications of an edit action\n  onEdit: (editAction: EditAction<TData>) => void,\n\n  // Callback used to update guides\n  onUpdateGuides: (guides: ?TGuides) => void,\n\n  // Callback used to update cursor\n  onUpdateCursor: (cursor: string) => void\n};\n\nexport interface EditMode<TData, TGuides> {\n  // Called every time something in `state` changes\n  updateState(state: ModeState<TData, TGuides>): void;\n\n  // Called when the pointer went down and up without dragging regardless of whether something was picked\n  handleClick(event: ClickEvent): void;\n\n  // Called when the pointer moved, regardless of whether the pointer is down, up, and whether something was picked\n  handlePointerMove(event: PointerMoveEvent): void;\n\n  // Called when the pointer went down on something rendered by this layer and the pointer started to move\n  handleStartDragging(event: StartDraggingEvent): void;\n\n  // Called when the pointer went down on something rendered by this layer, the pointer moved, and now the pointer is up\n  handleStopDragging(event: StopDraggingEvent): void;\n}\n\nexport class BaseEditMode<TData, TGuides> implements EditMode<TData, TGuides> {\n  state: ModeState<TData, TGuides>;\n\n  getState(): ModeState<TData, TGuides> {\n    return this.state;\n  }\n\n  updateState(state: ModeState<TData, TGuides>) {\n    const prevState = this.state;\n    const changedEvents: ((prevState: ModeState<TData, TGuides>) => void)[] = [];\n    if (!this.state || this.state.data !== state.data) {\n      changedEvents.push(this.onDataChanged);\n    }\n    if (!this.state || this.state.modeConfig !== state.modeConfig) {\n      changedEvents.push(this.onModeConfigChanged);\n    }\n    if (!this.state || this.state.selectedIndexes !== state.selectedIndexes) {\n      changedEvents.push(this.onSelectedIndexesChanged);\n    }\n    if (!this.state || this.state.guides !== state.guides) {\n      changedEvents.push(this.onGuidesChanged);\n    }\n    this.state = state;\n\n    changedEvents.forEach(fn => fn.bind(this)(prevState));\n  }\n\n  // Overridable user interaction handlers\n  handleClick(event: ClickEvent): void {}\n  handlePointerMove(event: PointerMoveEvent): void {}\n  handleStartDragging(event: StartDraggingEvent): void {}\n  handleStopDragging(event: StopDraggingEvent): void {}\n\n  // Convenience functions to handle state changes\n  onDataChanged(prevState: ModeState<TData, TGuides>): void {}\n  onModeConfigChanged(prevState: ModeState<TData, TGuides>): void {}\n  onSelectedIndexesChanged(prevState: ModeState<TData, TGuides>): void {}\n  onGuidesChanged(prevState: ModeState<TData, TGuides>): void {}\n\n  // Convenience functions to access state\n  getData(): TData {\n    return this.state.data;\n  }\n  getModeConfig(): any {\n    return this.state.modeConfig;\n  }\n  getSelectedIndexes(): number[] {\n    return this.state.selectedIndexes;\n  }\n  getGuides(): ?TGuides {\n    return this.state && this.state.guides;\n  }\n  getCursor(): string {\n    return this.state && this.state.cursor;\n  }\n  onEdit(editAction: EditAction<TData>): void {\n    this.state.onEdit(editAction);\n  }\n  onUpdateGuides(guides: ?TGuides): void {\n    this.state.onUpdateGuides(guides);\n  }\n  onUpdateCursor(cursor: string): void {\n    this.state.onUpdateCursor(cursor);\n  }\n}\n","// @flow\n\nimport type {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  Polygon,\n  MultiLineString,\n  MultiPolygon,\n  Position,\n  PolygonCoordinates\n} from '../geojson-types.js';\n\nexport class ImmutableFeatureCollection {\n  featureCollection: FeatureCollection;\n\n  constructor(featureCollection: FeatureCollection) {\n    this.featureCollection = featureCollection;\n  }\n\n  getObject() {\n    return this.featureCollection;\n  }\n\n  /**\n   * Replaces the position deeply nested withing the given feature's geometry.\n   * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position to replace\n   * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n   */\n  replacePosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    updatedPosition: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyReplacePosition(\n        geometry.coordinates,\n        positionIndexes,\n        updatedPosition,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion to remove\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  removePosition(featureIndex: number, positionIndexes: number[]): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw Error(`Can't remove a position from a Point or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'MultiPoint' &&\n      // only 1 point left\n      geometry.coordinates.length < 2\n    ) {\n      throw Error(`Can't remove the last point of a MultiPoint or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'LineString' &&\n      // only 2 positions\n      geometry.coordinates.length < 3\n    ) {\n      throw Error(`Can't remove position. LineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'Polygon' &&\n      // outer ring is a triangle\n      geometry.coordinates[0].length < 5 &&\n      // trying to remove from outer ring\n      positionIndexes[0] === 0\n    ) {\n      throw Error(`Can't remove position. Polygon's outer ring must have at least four positions`);\n    }\n    if (\n      geometry.type === 'MultiLineString' &&\n      // only 1 LineString left\n      geometry.coordinates.length === 1 &&\n      // only 2 positions\n      geometry.coordinates[0].length < 3\n    ) {\n      throw Error(`Can't remove position. MultiLineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'MultiPolygon' &&\n      // only 1 polygon left\n      geometry.coordinates.length === 1 &&\n      // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 &&\n      // trying to remove from first polygon\n      positionIndexes[0] === 0 &&\n      // trying to remove from outer ring\n      positionIndexes[1] === 0\n    ) {\n      throw Error(\n        `Can't remove position. MultiPolygon's outer ring must have at least four positions`\n      );\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)\n    };\n\n    // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n    pruneGeometryIfNecessary(updatedGeometry);\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion that will preceed the new position\n   * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  addPosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    positionToAdd: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw new Error('Unable to add a position to a Point feature');\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyAddPosition(\n        geometry.coordinates,\n        positionIndexes,\n        positionToAdd,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  replaceGeometry(featureIndex: number, geometry: Geometry): ImmutableFeatureCollection {\n    const updatedFeature: any = {\n      ...this.featureCollection.features[featureIndex],\n      geometry\n    };\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [\n        ...this.featureCollection.features.slice(0, featureIndex),\n        updatedFeature,\n        ...this.featureCollection.features.slice(featureIndex + 1)\n      ]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  addFeature(feature: Feature): ImmutableFeatureCollection {\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [...this.featureCollection.features, feature]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n}\n\nfunction getUpdatedPosition(updatedPosition: Position, previousPosition: Position): Position {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    const elevation = (previousPosition: any)[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  updatedPosition: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyReplacePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      updatedPosition,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyRemovePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyRemovePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyAddPosition(\n  coordinates: any,\n  positionIndexes: number[],\n  positionToAdd: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      positionToAdd,\n      ...coordinates.slice(positionIndexes[0])\n    ];\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyAddPosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      positionToAdd,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction pruneGeometryIfNecessary(geometry: Geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry: Polygon) {\n  const polygon = geometry.coordinates;\n\n  // If any hole is no longer a polygon, remove the hole entirely\n  for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry: MultiLineString) {\n  for (let lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    const lineString = geometry.coordinates[lineStringIndex];\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1);\n      // Keep the index the same\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry: MultiPolygon) {\n  for (let polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    const polygon = geometry.coordinates[polygonIndex];\n    const outerRing = polygon[0];\n\n    // If the outer ring is no longer a polygon, remove the whole polygon\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1);\n      // It was removed, so keep the index the same\n      polygonIndex--;\n    }\n\n    for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon: PolygonCoordinates, holeIndex: number) {\n  const hole = polygon[holeIndex];\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n  return false;\n}\n","// @flow\n\nimport turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\n\nimport type {\n  EditAction,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  Pick\n} from '../types.js';\nimport type { FeatureCollection, Feature, Polygon, Geometry, Position } from '../geojson-types.js';\nimport type { ModeState } from './edit-mode.js';\nimport { EditMode, BaseEditMode } from './edit-mode.js';\n\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport type EditHandleType = 'existing' | 'intermediate' | 'snap';\n\nexport type EditHandle = {\n  position: Position,\n  positionIndexes: number[],\n  featureIndex: number,\n  type: EditHandleType\n};\n\nexport type GeoJsonEditAction = EditAction<FeatureCollection>;\nexport type ModeHandlerGuides = { tentativeFeature: ?Feature, editHandles: EditHandle[] };\n\nconst DEFAULT_EDIT_HANDLES: EditHandle[] = [];\n\n// Main interface for `EditMode`s that edit GeoJSON\nexport type GeoJsonEditMode = EditMode<FeatureCollection, ModeHandlerGuides>;\n\nexport class BaseGeoJsonEditMode extends BaseEditMode<FeatureCollection, ModeHandlerGuides> {\n  // TODO: add underscore\n  featureCollection: ImmutableFeatureCollection;\n  _clickSequence: Position[] = [];\n\n  constructor(featureCollection?: FeatureCollection) {\n    super();\n    if (featureCollection) {\n      this.setFeatureCollection(featureCollection);\n    }\n  }\n\n  getFeatureCollection(): FeatureCollection {\n    return this.featureCollection.getObject();\n  }\n\n  getImmutableFeatureCollection(): ImmutableFeatureCollection {\n    return this.featureCollection;\n  }\n\n  getSelectedFeature(): ?Feature {\n    if (this.getSelectedIndexes().length === 1) {\n      return this.featureCollection.getObject().features[this.getSelectedIndexes()[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(): ?Geometry {\n    const feature = this.getSelectedFeature();\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(): FeatureCollection {\n    const { features } = this.featureCollection.getObject();\n    const selectedFeatures = this.getSelectedFeatureIndexes().map(\n      selectedIndex => features[selectedIndex]\n    );\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures\n    };\n  }\n\n  onDataChanged(): void {\n    this.setFeatureCollection(this.getData());\n    this._refreshEditHandles();\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.featureCollection = new ImmutableFeatureCollection(featureCollection);\n  }\n\n  // TODO: delete me\n  setModeConfig(modeConfig: any): void {\n    console.warn('TODO: call to obsolete setModeConfig'); // eslint-disable-line\n  }\n\n  // TODO: delete me\n  getSelectedFeatureIndexes(): number[] {\n    return this.getSelectedIndexes();\n  }\n\n  // TODO: delete me\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    console.warn('TODO: call to obsolete setSelectedFeatureIndexes'); // eslint-disable-line\n  }\n\n  onSelectedIndexesChanged(): void {\n    this._setTentativeFeature(null);\n  }\n\n  onGuidesChanged(prevState: ModeState<FeatureCollection, ModeHandlerGuides>): void {\n    const guides = this.getGuides();\n\n    if (!guides) {\n      // Reset the click sequence\n      this._clickSequence = [];\n    }\n\n    if (\n      prevState &&\n      prevState.guides &&\n      guides &&\n      prevState.guides.tentativeFeature !== guides.tentativeFeature\n    ) {\n      // re-calculate edit handles\n      this._refreshEditHandles();\n    }\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeFeature(): ?Feature {\n    const { tentativeFeature } = this.getGuides() || {};\n    return tentativeFeature;\n  }\n\n  getEditHandles(): EditHandle[] {\n    const { editHandles } = this.getGuides() || { editHandles: DEFAULT_EDIT_HANDLES };\n    return editHandles;\n  }\n\n  // TODO: delete me once mode handlers do getEditHandles lazily\n  _setTentativeFeature(tentativeFeature: ?Feature): void {\n    this.getState().onUpdateGuides({\n      tentativeFeature,\n      editHandles: this.getEditHandles()\n    });\n  }\n\n  // TODO: delete me once mode handlers do getEditHandles lazily\n  _refreshEditHandles(picks?: Array<Object>, mapCoords?: Position): void {\n    this.getState().onUpdateGuides({\n      tentativeFeature: this.getTentativeFeature(),\n      editHandles: this.getEditHandlesAdapter(picks, mapCoords)\n    });\n  }\n\n  _refreshCursor(): void {\n    const currentCursor = this.getCursor();\n    const updatedCursor = this.getCursorAdapter({ isDragging: false });\n\n    if (currentCursor !== updatedCursor) {\n      this.onUpdateCursor(updatedCursor);\n    }\n  }\n\n  /**\n   * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.\n   *\n   * @param featureIndex The index of the feature to get edit handles\n   */\n  getEditHandlesAdapter(\n    picks?: Array<Object>,\n    mapCoords?: Position,\n    tentativeFeature?: ?Feature\n  ): EditHandle[] {\n    return DEFAULT_EDIT_HANDLES;\n  }\n\n  getCursorAdapter({ isDragging }: { isDragging: boolean }): string {\n    return 'cell';\n  }\n\n  isSelectionPicked(picks: Pick[]): boolean {\n    if (!picks.length) return false;\n    const pickedIndexes = picks.map(({ index }) => index);\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    return selectedFeatureIndexes.some(index => pickedIndexes.includes(index));\n  }\n\n  getAddFeatureAction(geometry: Geometry): GeoJsonEditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const geometryAsAny: any = geometry;\n\n    const updatedData = this.getImmutableFeatureCollection()\n      .addFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: geometryAsAny\n      })\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: [updatedData.features.length - 1]\n      }\n    };\n  }\n\n  getAddManyFeaturesAction(featureCollection: FeatureCollection): GeoJsonEditAction {\n    const features = featureCollection.features;\n    let updatedData = this.getImmutableFeatureCollection();\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of features) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: updatedIndexes\n      }\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(geometry: Polygon): ?GeoJsonEditAction {\n    const selectedFeature = this.getSelectedFeature();\n    const modeConfig = this.getModeConfig();\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature = {\n        type: 'Feature',\n        geometry\n      };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = this.getSelectedFeatureIndexes()[0];\n\n      const updatedData = this.getImmutableFeatureCollection()\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: GeoJsonEditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        editContext: {\n          featureIndexes: [featureIndex]\n        }\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(geometry);\n  }\n\n  handleClick(event: ClickEvent): void {\n    const editAction = this.handleClickAdapter(event);\n\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  handlePointerMove(event: PointerMoveEvent): void {\n    const { editAction, cancelMapPan } = this.handlePointerMoveAdapter(event);\n\n    if (cancelMapPan) {\n      // TODO: is there a less hacky way to prevent map panning?\n      // Stop propagation to prevent map panning while dragging an edit handle\n      event.sourceEvent.stopPropagation();\n    }\n\n    this._refreshCursor();\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  handleStartDragging(event: StartDraggingEvent): void {\n    const editAction = this.handleStartDraggingAdapter(event);\n\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent): void {\n    const editAction = this.handleStopDraggingAdapter(event);\n\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  // TODO: delete these adapters once all ModeHandler implementations don't use them\n  handleClickAdapter(event: ClickEvent): ?GeoJsonEditAction {\n    this._clickSequence.push(event.mapCoords);\n\n    return null;\n  }\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    return { editAction: null, cancelMapPan: false };\n  }\n\n  handleStartDraggingAdapter(event: StartDraggingEvent): ?GeoJsonEditAction {\n    return null;\n  }\n\n  handleStopDraggingAdapter(event: StopDraggingEvent): ?GeoJsonEditAction {\n    return null;\n  }\n}\n\nexport function getPickedEditHandle(picks: ?(any[])): ?EditHandle {\n  const info = picks && picks.find(pick => pick.isGuide);\n  if (info) {\n    return info.object;\n  }\n  return null;\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0\n  ];\n  return intermediatePosition;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n) {\n  let handles: EditHandle[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          position: geometry.coordinates,\n          positionIndexes: [],\n          featureIndex,\n          type: editHandleType\n        }\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    default:\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandle[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      position,\n      positionIndexes: [...positionIndexPrefix, i],\n      featureIndex,\n      type: editHandleType\n    });\n  }\n  return editHandles;\n}\n","// @flow\n\nimport { BaseGeoJsonEditMode } from './geojson-edit-mode.js';\n\nexport class ViewMode extends BaseGeoJsonEditMode {}\n","// @flow\n\nimport type { ClickEvent, PointerMoveEvent } from '../types.js';\nimport type { Polygon, Position } from '../geojson-types.js';\nimport type { GeoJsonEditAction, EditHandle } from './geojson-edit-mode.js';\nimport {\n  BaseGeoJsonEditMode,\n  getPickedEditHandle,\n  getEditHandlesForGeometry\n} from './geojson-edit-mode.js';\n\nexport class DrawPolygonMode extends BaseGeoJsonEditMode {\n  getEditHandlesAdapter(picks?: Array<Object>, mapCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandlesAdapter(picks, mapCoords);\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handleClickAdapter(event: ClickEvent): ?GeoJsonEditAction {\n    super.handleClickAdapter(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?GeoJsonEditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (clickedEditHandle) {\n      // User clicked an edit handle.\n      // Remove it from the click sequence, so it isn't added as a new point.\n      const clickSequence = this.getClickSequence();\n      clickSequence.splice(clickSequence.length - 1, 1);\n    }\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n\n        // Remove the hovered position\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: [[...polygon.coordinates[0].slice(0, -2), polygon.coordinates[0][0]]]\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      mapCoords: event.mapCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownMapCoords: null,\n      sourceEvent: null\n    };\n\n    this.handlePointerMoveAdapter(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  handlePointerMoveAdapter({\n    mapCoords\n  }: PointerMoveEvent): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, mapCoords]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, mapCoords, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\n// TODO: delete this once all mode handlers derive from GeoJsonEditMode\n\nimport turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\n\nimport { ImmutableFeatureCollection } from '@nebula.gl/edit-modes';\nimport type {\n  FeatureCollection,\n  Feature,\n  Polygon,\n  Geometry,\n  Position\n} from '@nebula.gl/edit-modes';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DeckGLPick\n} from '../event-types.js';\n\nexport type EditHandleType = 'existing' | 'intermediate' | 'snap';\n\nexport type EditHandle = {\n  position: Position,\n  positionIndexes: number[],\n  featureIndex: number,\n  type: EditHandleType\n};\n\nexport type EditAction = {\n  updatedData: FeatureCollection,\n  editType: string,\n  featureIndexes: number[],\n  editContext: any\n};\n\nexport class ModeHandler {\n  // TODO: add underscore\n  featureCollection: ImmutableFeatureCollection;\n  _tentativeFeature: ?Feature;\n  _modeConfig: any = null;\n  _selectedFeatureIndexes: number[] = [];\n  _clickSequence: Position[] = [];\n\n  constructor(featureCollection?: FeatureCollection) {\n    if (featureCollection) {\n      this.setFeatureCollection(featureCollection);\n    }\n  }\n\n  getFeatureCollection(): FeatureCollection {\n    return this.featureCollection.getObject();\n  }\n\n  getImmutableFeatureCollection(): ImmutableFeatureCollection {\n    return this.featureCollection;\n  }\n\n  getSelectedFeature(): ?Feature {\n    if (this._selectedFeatureIndexes.length === 1) {\n      return this.featureCollection.getObject().features[this._selectedFeatureIndexes[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(): ?Geometry {\n    const feature = this.getSelectedFeature();\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(): FeatureCollection {\n    const { features } = this.featureCollection.getObject();\n    const selectedFeatures = this.getSelectedFeatureIndexes().map(\n      selectedIndex => features[selectedIndex]\n    );\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures\n    };\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.featureCollection = new ImmutableFeatureCollection(featureCollection);\n  }\n\n  getModeConfig(): any {\n    return this._modeConfig;\n  }\n\n  setModeConfig(modeConfig: any): void {\n    if (this._modeConfig === modeConfig) {\n      return;\n    }\n\n    this._modeConfig = modeConfig;\n    this._setTentativeFeature(null);\n  }\n\n  getSelectedFeatureIndexes(): number[] {\n    return this._selectedFeatureIndexes;\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    if (this._selectedFeatureIndexes === indexes) {\n      return;\n    }\n\n    this._selectedFeatureIndexes = indexes;\n    this._setTentativeFeature(null);\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._tentativeFeature;\n  }\n\n  // TODO: remove the underscore\n  _setTentativeFeature(tentativeFeature: ?Feature): void {\n    this._tentativeFeature = tentativeFeature;\n    if (!tentativeFeature) {\n      // Reset the click sequence\n      this._clickSequence = [];\n    }\n  }\n\n  /**\n   * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.\n   *\n   * @param featureIndex The index of the feature to get edit handles\n   */\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    return [];\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return 'cell';\n  }\n\n  isSelectionPicked(picks: DeckGLPick[]): boolean {\n    if (!picks.length) return false;\n    const pickedIndexes = picks.map(({ index }) => index);\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    return selectedFeatureIndexes.some(index => pickedIndexes.includes(index));\n  }\n\n  getAddFeatureAction(geometry: Geometry): EditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const geometryAsAny: any = geometry;\n\n    const updatedData = this.getImmutableFeatureCollection()\n      .addFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: geometryAsAny\n      })\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      featureIndexes: [updatedData.features.length - 1],\n      editContext: null\n    };\n  }\n\n  getAddManyFeaturesAction(featureCollection: FeatureCollection): EditAction {\n    const features = featureCollection.features;\n    let updatedData = this.getImmutableFeatureCollection();\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of features) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      featureIndexes: updatedIndexes,\n      editContext: null\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(geometry: Polygon): ?EditAction {\n    const selectedFeature = this.getSelectedFeature();\n    const modeConfig = this.getModeConfig();\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature = {\n        type: 'Feature',\n        geometry\n      };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = this.getSelectedFeatureIndexes()[0];\n\n      const updatedData = this.getImmutableFeatureCollection()\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: EditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        featureIndexes: [featureIndex],\n        editContext: null\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(geometry);\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    this._clickSequence.push(event.groundCoords);\n\n    return null;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    return { editAction: null, cancelMapPan: false };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    return null;\n  }\n}\n\nexport function getPickedEditHandle(picks: ?(any[])): ?EditHandle {\n  const info = picks && picks.find(pick => pick.isEditingHandle);\n  if (info) {\n    return info.object;\n  }\n  return null;\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0\n  ];\n  return intermediatePosition;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n) {\n  let handles: EditHandle[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          position: geometry.coordinates,\n          positionIndexes: [],\n          featureIndex,\n          type: editHandleType\n        }\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    default:\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandle[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      position,\n      positionIndexes: [...positionIndexPrefix, i],\n      featureIndex,\n      type: editHandleType\n    });\n  }\n  return editHandles;\n}\n","// @flow\n\nimport type { Position } from '@nebula.gl/edit-modes';\nimport type { EditHandle } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class ViewHandler extends ModeHandler {\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    return [];\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { point } from '@turf/helpers';\nimport type {\n  Position,\n  Point,\n  LineString,\n  FeatureOf,\n  FeatureWithProps\n} from '@nebula.gl/edit-modes';\nimport { WebMercatorViewport } from '@deck.gl/core';\n\nexport type NearestPointType = FeatureWithProps<Point, { dist: number, index: number }>;\n\nexport function toDeckColor(\n  color?: ?[number, number, number, number],\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  groundCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  const pt = point(groundCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nexport function distance2d(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function mix(a: number, b: number, ratio: number): number {\n  return b * ratio + a * (1 - ratio);\n}\n\nexport function nearestPointOnProjectedLine(\n  line: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport: WebMercatorViewport\n): NearestPointType {\n  // Project the line to viewport, then find the nearest point\n  const coordinates: Array<Array<number>> = (line.geometry.coordinates: any);\n  const projectedCoords = coordinates.map(([x, y, z = 0]) => viewport.project([x, y, z]));\n  const [x, y] = viewport.project(inPoint.geometry.coordinates);\n\n  let minDistance = Infinity;\n  let minPointInfo = {};\n\n  projectedCoords.forEach(([x2, y2], index) => {\n    if (index === 0) {\n      return;\n    }\n\n    const [x1, y1] = projectedCoords[index - 1];\n\n    // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n    const A = y1 - y2;\n    const B = x2 - x1;\n    const C = x1 * y2 - x2 * y1;\n\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    const div = A * A + B * B;\n    const distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);\n\n    // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div\n      };\n    }\n  });\n\n  const { index, x0, y0 } = minPointInfo;\n  const [x1, y1, z1 = 0] = projectedCoords[index - 1];\n  const [x2, y2, z2 = 0] = projectedCoords[index];\n\n  // calculate what ratio of the line we are on to find the proper z\n  const lineLength = distance2d(x1, y1, x2, y2);\n  const startToPointLength = distance2d(x1, y1, x0, y0);\n  const ratio = startToPointLength / lineLength;\n  const z0 = mix(z1, z2, ratio);\n\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: viewport.unproject([x0, y0, z0])\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1\n    }\n  };\n}\n","// @flow\n\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { point, lineString as toLineString } from '@turf/helpers';\nimport type { Position, FeatureOf, Point, LineString } from '@nebula.gl/edit-modes';\nimport {\n  recursivelyTraverseNestedArrays,\n  nearestPointOnProjectedLine,\n  type NearestPointType\n} from '../utils.js';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class ModifyHandler extends ModeHandler {\n  _lastPointerMovePicks: *;\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = [];\n    const { features } = this.featureCollection.getObject();\n\n    for (const index of this.getSelectedFeatureIndexes()) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index));\n      } else {\n        console.warn(`selectedFeatureIndexes out of range ${index}`); // eslint-disable-line no-console,no-undef\n      }\n    }\n\n    // intermediate edit handle\n    if (picks && picks.length && groundCoords) {\n      const existingEditHandle = picks.find(\n        pick => pick.isEditingHandle && pick.object && pick.object.type === 'existing'\n      );\n      // don't show intermediate point when too close to an existing edit handle\n      const featureAsPick = !existingEditHandle && picks.find(pick => !pick.isEditingHandle);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        !featureAsPick.object.geometry.type.includes('Point') &&\n        this.getSelectedFeatureIndexes().includes(featureAsPick.index)\n      ) {\n        let intermediatePoint: ?NearestPointType = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(groundCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.nearestPointOnLine(\n              lineStringFeature,\n              referencePoint\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index }\n          } = intermediatePoint;\n          handles = [\n            ...handles,\n            {\n              position,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n              featureIndex: featureAsPick.index,\n              type: 'intermediate'\n            }\n          ];\n        }\n      }\n    }\n\n    return handles;\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  nearestPointOnLine(line: FeatureOf<LineString>, inPoint: FeatureOf<Point>): NearestPointType {\n    const { coordinates } = line.geometry;\n    if (coordinates.some(coord => coord.length > 2)) {\n      const modeConfig = this.getModeConfig();\n      if (modeConfig && modeConfig.viewport) {\n        // This line has elevation, we need to use alternative algorithm\n        return nearestPointOnProjectedLine(line, inPoint, modeConfig.viewport);\n      }\n      // eslint-disable-next-line no-console,no-undef\n      console.log(\n        'Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.'\n      );\n    }\n\n    return nearestPointOnLine(line, inPoint);\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const clickedEditHandle = getPickedEditHandle(event.picks);\n\n    if (clickedEditHandle && clickedEditHandle.featureIndex >= 0) {\n      if (clickedEditHandle.type === 'existing') {\n        let updatedData;\n        try {\n          updatedData = this.getImmutableFeatureCollection()\n            .removePosition(clickedEditHandle.featureIndex, clickedEditHandle.positionIndexes)\n            .getObject();\n        } catch (ignored) {\n          // This happens if user attempts to remove the last point\n        }\n\n        if (updatedData) {\n          editAction = {\n            updatedData,\n            editType: 'removePosition',\n            featureIndexes: [clickedEditHandle.featureIndex],\n            editContext: {\n              positionIndexes: clickedEditHandle.positionIndexes,\n              position: clickedEditHandle.position\n            }\n          };\n        }\n      } else if (clickedEditHandle.type === 'intermediate') {\n        const updatedData = this.getImmutableFeatureCollection()\n          .addPosition(\n            clickedEditHandle.featureIndex,\n            clickedEditHandle.positionIndexes,\n            clickedEditHandle.position\n          )\n          .getObject();\n\n        if (updatedData) {\n          editAction = {\n            updatedData,\n            editType: 'addPosition',\n            featureIndexes: [clickedEditHandle.featureIndex],\n            editContext: {\n              positionIndexes: clickedEditHandle.positionIndexes,\n              position: clickedEditHandle.position\n            }\n          };\n        }\n      }\n    }\n    return editAction;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    this._lastPointerMovePicks = event.picks;\n\n    let editAction: ?EditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const updatedData = this.getImmutableFeatureCollection()\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'movePosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n\n    return { editAction, cancelMapPan };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle && editHandle.type === 'intermediate') {\n      const updatedData = this.getImmutableFeatureCollection()\n        .addPosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const updatedData = this.getImmutableFeatureCollection()\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'finishMovePosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    const picks = this._lastPointerMovePicks;\n\n    if (picks && picks.length > 0) {\n      const handlePicked = picks.some(pick => pick.isEditingHandle);\n      if (handlePicked) {\n        return 'cell';\n      }\n    }\n\n    return isDragging ? 'grabbing' : 'grab';\n  }\n}\n","// @flow\n\nimport type { Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { getPickedEditHandle } from './mode-handler.js';\nimport { ModifyHandler } from './modify-handler.js';\n\nfunction defaultCalculateElevationChange({\n  pointerDownScreenCoords,\n  screenCoords\n}: {\n  pointerDownScreenCoords: Position,\n  screenCoords: Position\n}) {\n  return 10 * (pointerDownScreenCoords[1] - screenCoords[1]);\n}\n\nexport class ElevationHandler extends ModifyHandler {\n  makeElevatedEvent(event: PointerMoveEvent | StopDraggingEvent, position: Position): Object {\n    if (!event.pointerDownScreenCoords) {\n      return event;\n    }\n\n    const {\n      minElevation = 0,\n      maxElevation = 20000,\n      calculateElevationChange = defaultCalculateElevationChange\n    } =\n      this._modeConfig || {};\n\n    // $FlowFixMe - really, I know it has something at index 2\n    let elevation = position.length === 3 ? position[2] : 0;\n\n    // calculateElevationChange is configurable becase (at this time) modes are not aware of the viewport\n    elevation += calculateElevationChange({\n      pointerDownScreenCoords: event.pointerDownScreenCoords,\n      screenCoords: event.screenCoords\n    });\n    elevation = Math.min(elevation, maxElevation);\n    elevation = Math.max(elevation, minElevation);\n\n    return Object.assign({}, event, {\n      groundCoords: [position[0], position[1], elevation]\n    });\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n    const position = editHandle ? editHandle.position : event.groundCoords;\n    return super.handlePointerMove(this.makeElevatedEvent(event, position));\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    const editHandle = getPickedEditHandle(event.picks);\n    const position = editHandle ? editHandle.position : event.groundCoords;\n    return super.handleStopDragging(this.makeElevatedEvent(event, position));\n  }\n\n  getCursor(params: { isDragging: boolean }): string {\n    let cursor = super.getCursor(params);\n    if (cursor === 'cell') {\n      cursor = 'ns-resize';\n    }\n    return cursor;\n  }\n\n  static calculateElevationChangeWithViewport(\n    viewport: any,\n    {\n      pointerDownScreenCoords,\n      screenCoords\n    }: {\n      pointerDownScreenCoords: Position,\n      screenCoords: Position\n    }\n  ): number {\n    // Source: https://gis.stackexchange.com/a/127949/111804\n    const metersPerPixel =\n      (156543.03392 * Math.cos((viewport.latitude * Math.PI) / 180)) / Math.pow(2, viewport.zoom);\n\n    return (metersPerPixel * (pointerDownScreenCoords[1] - screenCoords[1])) / 2;\n  }\n}\n","// @flow\n\nimport type { Feature, FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditHandle, EditAction } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\ntype HandlePicks = { pickedHandle?: EditHandle, potentialSnapHandle?: EditHandle };\n\nexport class SnappableHandler extends ModeHandler {\n  _handler: ModeHandler;\n  _editHandlePicks: ?HandlePicks;\n  _startDragSnapHandlePosition: Position;\n  _isSnapped: boolean;\n\n  constructor(handler: ModeHandler) {\n    super();\n    this._handler = handler;\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this._handler.setFeatureCollection(featureCollection);\n  }\n\n  setModeConfig(modeConfig: any): void {\n    this._modeConfig = modeConfig;\n    this._handler.setModeConfig(modeConfig);\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    this._handler.setSelectedFeatureIndexes(indexes);\n  }\n\n  _getSnappedMouseEvent(event: Object, snapPoint: Position): PointerMoveEvent {\n    return Object.assign({}, event, {\n      groundCoords: snapPoint,\n      pointerDownGroundCoords: this._startDragSnapHandlePosition\n    });\n  }\n\n  _getEditHandlePicks(event: PointerMoveEvent): HandlePicks {\n    const { picks } = event;\n\n    const potentialSnapHandle = picks.find(\n      pick => pick.object && pick.object.type === 'intermediate'\n    );\n    const handles = { potentialSnapHandle: potentialSnapHandle && potentialSnapHandle.object };\n\n    const pickedHandle = getPickedEditHandle(event.pointerDownPicks);\n    if (pickedHandle) {\n      return { ...handles, pickedHandle };\n    }\n\n    return handles;\n  }\n\n  _updatePickedHandlePosition(editAction: EditAction) {\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle && editAction) {\n      const { featureIndexes, updatedData } = editAction;\n\n      for (let i = 0; i < featureIndexes.length; i++) {\n        const selectedIndex = featureIndexes[i];\n        const updatedFeature = updatedData.features[selectedIndex];\n\n        const { positionIndexes, featureIndex } = pickedHandle;\n        if (selectedIndex >= 0 && featureIndex === selectedIndex) {\n          const { coordinates } = updatedFeature.geometry;\n          // $FlowFixMe\n          pickedHandle.position = positionIndexes.reduce(\n            (a: any[], b: number) => a[b],\n            coordinates\n          );\n        }\n      }\n    }\n  }\n\n  // If additionalSnapTargets is present in modeConfig and is populated, this\n  // method will return those features along with the features\n  // that live in the current layer. Otherwise, this method will simply return the\n  // features from the current layer\n  _getSnapTargets(): Feature[] {\n    let { additionalSnapTargets } = this.getModeConfig() || {};\n    additionalSnapTargets = additionalSnapTargets || [];\n\n    const features = [\n      ...this._handler.featureCollection.getObject().features,\n      ...additionalSnapTargets\n    ];\n    return features;\n  }\n\n  _getNonPickedIntermediateHandles(): EditHandle[] {\n    const handles = [];\n    const features = this._getSnapTargets();\n\n    for (let i = 0; i < features.length; i++) {\n      // Filter out the currently selected feature(s)\n      const isCurrentIndexFeatureNotSelected =\n        i < features.length && !this._handler.getSelectedFeatureIndexes().includes(i);\n\n      if (isCurrentIndexFeatureNotSelected) {\n        const { geometry } = features[i];\n        handles.push(...getEditHandlesForGeometry(geometry, i, 'intermediate'));\n      }\n    }\n    return handles;\n  }\n\n  // If no snap handle has been picked, only display the edit handles of the\n  // selected feature. If a snap handle has been picked, display said snap handle\n  // along with all snappable points on all non-selected features.\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): any[] {\n    const { enableSnapping } = this._modeConfig || {};\n    const handles = this._handler.getEditHandles(picks, groundCoords);\n\n    if (!enableSnapping) return handles;\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle) {\n      handles.push(...this._getNonPickedIntermediateHandles(), pickedHandle);\n      return handles;\n    }\n\n    const { features } = this._handler.featureCollection.getObject();\n    for (const index of this._handler.getSelectedFeatureIndexes()) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index, 'snap'));\n      }\n    }\n\n    return handles.filter(Boolean);\n  }\n\n  _performSnapIfRequired() {\n    if (this._isSnapped) return;\n    const { pickedHandle, potentialSnapHandle } = this._editHandlePicks || {};\n    if (pickedHandle && potentialSnapHandle) {\n      this._isSnapped = true;\n    }\n  }\n\n  // Unsnapping only occurs after the user snaps two polygons but continues to drag the\n  // cursor past the point of resistance.\n  _performUnsnapIfRequired() {\n    if (!this._isSnapped) return;\n\n    const { potentialSnapHandle } = this._editHandlePicks || {};\n    if (!potentialSnapHandle) {\n      this._isSnapped = false;\n    }\n  }\n\n  _getSnapAwareEvent(event: Object): Object {\n    const { potentialSnapHandle } = this._editHandlePicks || {};\n\n    return potentialSnapHandle && potentialSnapHandle.position\n      ? this._getSnappedMouseEvent(event, potentialSnapHandle.position)\n      : event;\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    this._startDragSnapHandlePosition = (getPickedEditHandle(event.picks) || {}).position;\n    return this._handler.handleStartDragging(event);\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    const modeActionSummary = this._handler.handleStopDragging(this._getSnapAwareEvent(event));\n\n    this._editHandlePicks = null;\n    this._isSnapped = false;\n    return modeActionSummary;\n  }\n\n  getCursor(event: { isDragging: boolean }): string {\n    return this._handler.getCursor(event);\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const { enableSnapping } = this._handler.getModeConfig() || {};\n\n    if (enableSnapping) {\n      this._editHandlePicks = this._getEditHandlePicks(event);\n      if (this._editHandlePicks) {\n        this._performSnapIfRequired();\n        this._performUnsnapIfRequired();\n      }\n    }\n\n    const modeActionSummary = this._handler.handlePointerMove(this._getSnapAwareEvent(event));\n    const { editAction } = modeActionSummary;\n    if (editAction) {\n      this._updatePickedHandlePosition(editAction);\n    }\n\n    return modeActionSummary;\n  }\n}\n","// @flow\n\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfTransformTranslate from '@turf/transform-translate';\nimport { point } from '@turf/helpers';\nimport type { FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class TranslateHandler extends ModeHandler {\n  _geometryBeforeTranslate: ?FeatureCollection;\n  _isTranslatable: boolean;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isTranslatable =\n      Boolean(this._geometryBeforeTranslate) || this.isSelectionPicked(event.picks);\n\n    if (!this._isTranslatable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'translating'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'translated'\n      );\n      this._geometryBeforeTranslate = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isTranslatable) {\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getTranslateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string\n  ): ?EditAction {\n    if (!this._geometryBeforeTranslate) {\n      return null;\n    }\n    const p1 = point(startDragPoint);\n    const p2 = point(currentPoint);\n\n    const distanceMoved = turfDistance(p1, p2);\n    const direction = turfBearing(p1, p2);\n\n    const movedFeatures = turfTransformTranslate(\n      this._geometryBeforeTranslate,\n      distanceMoved,\n      direction\n    );\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = movedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n","// @flow\n\nimport type { StartDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TranslateHandler } from './translate-handler';\n\nexport class DuplicateHandler extends TranslateHandler {\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection();\n\n    return this._geometryBeforeTranslate\n      ? this.getAddManyFeaturesAction(this._geometryBeforeTranslate)\n      : null;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isTranslatable) {\n      return 'copy';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport turfTransformRotate from '@turf/transform-rotate';\nimport type { FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class RotateHandler extends ModeHandler {\n  _isRotatable: boolean;\n  _geometryBeingRotated: ?FeatureCollection;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isRotatable = Boolean(this._geometryBeingRotated) || this.isSelectionPicked(event.picks);\n\n    if (!this._isRotatable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'rotating'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isRotatable) {\n      return null;\n    }\n\n    this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'rotated'\n      );\n      this._geometryBeingRotated = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isRotatable) {\n      // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getRotateAction(startDragPoint: Position, currentPoint: Position, editType: string): EditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingRotated);\n    const angle = getRotationAngle(centroid, startPosition, currentPoint);\n\n    const rotatedFeatures = turfTransformRotate(this._geometryBeingRotated, angle);\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = rotatedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n\nfunction getRotationAngle(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const bearing1 = turfBearing(centroid, startDragPoint);\n  const bearing2 = turfBearing(centroid, currentPoint);\n  return bearing2 - bearing1;\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfDistance from '@turf/distance';\nimport turfTransformScale from '@turf/transform-scale';\nimport type { FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class ScaleHandler extends ModeHandler {\n  _isScalable: boolean;\n  _geometryBeingScaled: ?FeatureCollection;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isScalable = Boolean(this._geometryBeingScaled) || this.isSelectionPicked(event.picks);\n\n    if (!this._isScalable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'scaling'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isScalable) {\n      return null;\n    }\n\n    this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(event.pointerDownGroundCoords, event.groundCoords, 'scaled');\n      this._geometryBeingScaled = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isScalable) {\n      // TODO: look at doing SVG cursors to get a better \"scale\" cursor\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getScaleAction(startDragPoint: Position, currentPoint: Position, editType: string): EditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingScaled);\n    const factor = getScaleFactor(centroid, startPosition, currentPoint);\n    const scaledFeatures = turfTransformScale(this._geometryBeingScaled, factor, {\n      origin: centroid\n    });\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = scaledFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n\nfunction getScaleFactor(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const startDistance = turfDistance(centroid, startDragPoint);\n  const endDistance = turfDistance(centroid, currentPoint);\n  return endDistance / startDistance;\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class DrawPointHandler extends ModeHandler {\n  handleClick({ groundCoords }: ClickEvent): ?EditAction {\n    const geometry = {\n      type: 'Point',\n      coordinates: groundCoords\n    };\n\n    return this.getAddFeatureAction(geometry);\n  }\n}\n","// @flow\n\nimport type { Position, LineString } from '@nebula.gl/edit-modes';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class DrawLineStringHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    let editAction: ?EditAction = null;\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const selectedGeometry = this.getSelectedGeometry();\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      console.warn(`drawLineString mode only supported for single LineString selection`); // eslint-disable-line\n      this.resetClickSequence();\n      return null;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Extend the LineString\n      const lineString: LineString = selectedGeometry;\n\n      let positionIndexes = [lineString.coordinates.length];\n\n      const modeConfig = this.getModeConfig();\n      if (modeConfig && modeConfig.drawAtFront) {\n        positionIndexes = [0];\n      }\n      const featureIndex = selectedFeatureIndexes[0];\n      const updatedData = this.getImmutableFeatureCollection()\n        .addPosition(featureIndex, positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        featureIndexes: [featureIndex],\n        editContext: {\n          positionIndexes,\n          position: event.groundCoords\n        }\n      };\n\n      this.resetClickSequence();\n    } else if (clickSequence.length === 2 && tentativeFeature) {\n      // Add a new LineString\n      const geometry: any = tentativeFeature.geometry;\n      editAction = this.getAddFeatureAction(geometry);\n\n      this.resetClickSequence();\n    }\n\n    return editAction;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n\n    const clickSequence = this.getClickSequence();\n    const groundCoords = event.groundCoords;\n\n    let startPosition: ?Position = null;\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const selectedGeometry = this.getSelectedGeometry();\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      // unsupported\n      return result;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Draw an extension line starting from one end of the selected LineString\n      startPosition = selectedGeometry.coordinates[selectedGeometry.coordinates.length - 1];\n\n      const modeConfig = this.getModeConfig();\n      if (modeConfig && modeConfig.drawAtFront) {\n        startPosition = selectedGeometry.coordinates[0];\n      }\n    } else if (clickSequence.length === 1) {\n      startPosition = clickSequence[0];\n    }\n\n    if (startPosition) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: {\n          type: 'LineString',\n          coordinates: [startPosition, groundCoords]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport type { Polygon, Position } from '@nebula.gl/edit-modes';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class DrawPolygonHandler extends ModeHandler {\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandles(picks, groundCoords);\n\n    if (this._tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(this._tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (this._tentativeFeature && this._tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (this._tentativeFeature && this._tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?EditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (clickedEditHandle) {\n      // User clicked an edit handle.\n      // Remove it from the click sequence, so it isn't added as a new point.\n      const clickSequence = this.getClickSequence();\n      clickSequence.splice(clickSequence.length - 1, 1);\n    }\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n\n        // Remove the hovered position\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: [[...polygon.coordinates[0].slice(0, -2), polygon.coordinates[0][0]]]\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      groundCoords: event.groundCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownGroundCoords: null,\n      sourceEvent: null\n    };\n    this.handlePointerMove(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, groundCoords]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, groundCoords, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport lineIntersect from '@turf/line-intersect';\nimport turfDistance from '@turf/distance';\nimport { point, lineString } from '@turf/helpers';\nimport type { Polygon, Position } from '@nebula.gl/edit-modes';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class Draw90DegreePolygonHandler extends ModeHandler {\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandles(picks, groundCoords);\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[0][clickSequence.length - 1];\n    } else if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[clickSequence.length - 1];\n    }\n\n    let p3;\n    if (clickSequence.length === 1) {\n      p3 = groundCoords;\n    } else {\n      const p1 = clickSequence[clickSequence.length - 2];\n      const p2 = clickSequence[clickSequence.length - 1];\n      [p3] = generatePointsParallelToLinePoints(p1, p2, groundCoords);\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, p3]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, p3, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?EditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: this.finalizedCoordinates([...polygon.coordinates[0]])\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      groundCoords: event.groundCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownGroundCoords: null,\n      sourceEvent: null\n    };\n    this.handlePointerMove(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  finalizedCoordinates(coords: Position[]) {\n    // Remove the hovered position\n    let coordinates = [[...coords.slice(0, -2), coords[0]]];\n    let pt = this.getIntermediatePoint([...coords]);\n    if (!pt) {\n      // if intermediate point with 90 degree not available\n      // try remove the last clicked point and get the intermediate point.\n      const tc = [...coords];\n      tc.splice(-3, 1);\n      pt = this.getIntermediatePoint([...tc]);\n      if (pt) {\n        coordinates = [[...coords.slice(0, -3), pt, coords[0]]];\n      }\n    } else {\n      coordinates = [[...coords.slice(0, -2), pt, coords[0]]];\n    }\n    return coordinates;\n  }\n\n  getIntermediatePoint(coordinates: Position[]) {\n    let pt;\n    if (coordinates.length > 4) {\n      const [p1, p2] = [...coordinates];\n      const angle1 = bearing(p1, p2);\n      const p3 = coordinates[coordinates.length - 3];\n      const p4 = coordinates[coordinates.length - 4];\n      const angle2 = bearing(p3, p4);\n\n      const angles = { first: [], second: [] };\n      // calculate 3 right angle points for first and last points in lineString\n      [1, 2, 3].forEach(factor => {\n        const newAngle1 = angle1 + factor * 90;\n        // convert angles to 0 to -180 for anti-clock and 0 to 180 for clock wise\n        angles.first.push(newAngle1 > 180 ? newAngle1 - 360 : newAngle1);\n        const newAngle2 = angle2 + factor * 90;\n        angles.second.push(newAngle2 > 180 ? newAngle2 - 360 : newAngle2);\n      });\n\n      const distance = turfDistance(point(p1), point(p3));\n      // Draw imaginary right angle lines for both first and last points in lineString\n      // If there is intersection point for any 2 lines, will be the 90 degree point.\n      [0, 1, 2].forEach(indexFirst => {\n        const line1 = lineString([\n          p1,\n          destination(p1, distance, angles.first[indexFirst]).geometry.coordinates\n        ]);\n        [0, 1, 2].forEach(indexSecond => {\n          const line2 = lineString([\n            p3,\n            destination(p3, distance, angles.second[indexSecond]).geometry.coordinates\n          ]);\n          const fc = lineIntersect(line1, line2);\n          if (fc && fc.features.length) {\n            // found the intersect point\n            pt = fc.features[0].geometry.coordinates;\n          }\n        });\n      });\n    }\n    return pt;\n  }\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport { ModeHandler } from './mode-handler.js';\nimport type { EditAction } from './mode-handler.js';\n\nexport class TwoClickPolygonHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 1 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\n\nexport class DrawRectangleHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.groundCoords;\n    this._setTentativeFeature(bboxPolygon([corner1[0], corner1[1], corner2[0], corner2[1]]));\n\n    return result;\n  }\n}\n","// @flow\n\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport turfDifference from '@turf/difference';\nimport turfBuffer from '@turf/buffer';\nimport lineIntersect from '@turf/line-intersect';\nimport { lineString } from '@turf/helpers';\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfDestination from '@turf/destination';\nimport turfPolygonToLine from '@turf/polygon-to-line';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class SplitPolygonHandler extends ModeHandler {\n  calculateGroundCoords(clickSequence: any, groundCoords: any) {\n    const modeConfig = this.getModeConfig();\n    if (!modeConfig || !modeConfig.lock90Degree || !clickSequence.length) {\n      return groundCoords;\n    }\n    if (clickSequence.length === 1) {\n      // if first point is clicked, then find closest polygon point and build ~90deg vector\n      const firstPoint = clickSequence[0];\n      const selectedGeometry = this.getSelectedGeometry();\n      const feature = turfPolygonToLine(selectedGeometry);\n\n      const lines = feature.type === 'FeatureCollection' ? feature.features : [feature];\n      let minDistance = Number.MAX_SAFE_INTEGER;\n      let closestPoint = null;\n      // If Multipolygon, then we should find nearest polygon line and stick split to it.\n      lines.forEach(line => {\n        const snapPoint = nearestPointOnLine(line, firstPoint);\n        const distanceFromOrigin = turfDistance(snapPoint, firstPoint);\n        if (minDistance > distanceFromOrigin) {\n          minDistance = distanceFromOrigin;\n          closestPoint = snapPoint;\n        }\n      });\n\n      if (closestPoint) {\n        // closest point is used as 90degree entry to the polygon\n        const lastBearing = turfBearing(firstPoint, closestPoint);\n        const currentDistance = turfDistance(firstPoint, groundCoords, { units: 'meters' });\n        return turfDestination(firstPoint, currentDistance, lastBearing, {\n          units: 'meters'\n        }).geometry.coordinates;\n      }\n      return groundCoords;\n    }\n    // Allow only 90 degree turns\n    const lastPoint = clickSequence[clickSequence.length - 1];\n    const [approximatePoint] = generatePointsParallelToLinePoints(\n      clickSequence[clickSequence.length - 2],\n      lastPoint,\n      groundCoords\n    );\n    // align point with current ground\n    const nearestPt = nearestPointOnLine(lineString([lastPoint, approximatePoint]), groundCoords)\n      .geometry.coordinates;\n    return nearestPt;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick({\n      ...event,\n      groundCoords: this.calculateGroundCoords(this.getClickSequence(), event.groundCoords)\n    });\n    const editAction: ?EditAction = null;\n    const tentativeFeature = this.getTentativeFeature();\n    const selectedGeometry = this.getSelectedGeometry();\n    const clickSequence = this.getClickSequence();\n\n    if (!selectedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('A polygon must be selected for splitting');\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n    const pt = {\n      type: 'Point',\n      coordinates: clickSequence[clickSequence.length - 1]\n    };\n    const isPointInPolygon = booleanPointInPolygon(pt, selectedGeometry);\n    if (clickSequence.length > 1 && tentativeFeature && !isPointInPolygon) {\n      this.resetClickSequence();\n      const isLineInterectingWithPolygon = lineIntersect(tentativeFeature, selectedGeometry);\n      if (isLineInterectingWithPolygon.features.length === 0) {\n        this._setTentativeFeature(null);\n        return editAction;\n      }\n      return this.splitPolygon();\n    }\n\n    return editAction;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    this._setTentativeFeature({\n      type: 'Feature',\n      geometry: {\n        type: 'LineString',\n        coordinates: [...clickSequence, this.calculateGroundCoords(clickSequence, groundCoords)]\n      }\n    });\n\n    return result;\n  }\n\n  splitPolygon() {\n    const selectedGeometry = this.getSelectedGeometry();\n    const tentativeFeature = this.getTentativeFeature();\n    const featureIndex = this.getSelectedFeatureIndexes()[0];\n    const modeConfig = this.getModeConfig() || {};\n\n    // Default gap in between the polygon\n    let { gap = 0.1, units = 'centimeters' } = modeConfig;\n    if (gap === 0) {\n      gap = 0.1;\n      units = 'centimeters';\n    }\n\n    const buffer = turfBuffer(tentativeFeature, gap, { units });\n    const updatedGeometry = turfDifference(selectedGeometry, buffer);\n    this._setTentativeFeature(null);\n    if (!updatedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('Canceling edit. Split Polygon erased');\n      return null;\n    }\n\n    const { type, coordinates } = updatedGeometry.geometry;\n    let updatedCoordinates = [];\n    if (type === 'Polygon') {\n      // Update the coordinates as per Multipolygon\n      updatedCoordinates = coordinates.map(c => [c]);\n    } else {\n      // Handle Case when Multipolygon has holes\n      updatedCoordinates = coordinates.reduce((agg, prev) => {\n        prev.forEach(p => {\n          agg.push([p]);\n        });\n        return agg;\n      }, []);\n    }\n\n    // Update the type to Mulitpolygon\n    const updatedData = this.getImmutableFeatureCollection().replaceGeometry(featureIndex, {\n      type: 'MultiPolygon',\n      coordinates: updatedCoordinates\n    });\n\n    const editAction: EditAction = {\n      updatedData: updatedData.getObject(),\n      editType: 'split',\n      featureIndexes: [featureIndex],\n      editContext: null\n    };\n\n    return editAction;\n  }\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport { ModeHandler } from './mode-handler.js';\nimport type { EditAction } from './mode-handler.js';\n\nexport class ThreeClickPolygonHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 2 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n}\n","// @flow\n\nimport type { LineString } from '@nebula.gl/edit-modes';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ThreeClickPolygonHandler } from './three-click-polygon-handler.js';\n\nexport class DrawRectangleUsingThreePointsHandler extends ThreeClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const groundCoords = event.groundCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], groundCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const lineString: LineString = {\n        type: 'LineString',\n        coordinates: clickSequence\n      };\n      const [p1, p2] = clickSequence;\n      const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, groundCoords);\n\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [\n            [\n              // Draw a polygon containing all the points of the LineString,\n              // then the points orthogonal to the lineString,\n              // then back to the starting position\n              ...lineString.coordinates,\n              p3,\n              p4,\n              p1\n            ]\n          ]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\n\nexport class DrawCircleFromCenterHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = this.getModeConfig() || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const centerCoordinates = clickSequence[0];\n    const radius = Math.max(distance(centerCoordinates, event.groundCoords), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawCircleByBoundingBoxHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = this.getModeConfig() || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const firstClickedPoint = clickSequence[0];\n    const centerCoordinates = getIntermediatePosition(firstClickedPoint, event.groundCoords);\n    const radius = Math.max(distance(firstClickedPoint, centerCoordinates), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawEllipseByBoundingBoxHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.groundCoords;\n\n    const minX = Math.min(corner1[0], corner2[0]);\n    const minY = Math.min(corner1[1], corner2[1]);\n    const maxX = Math.max(corner1[0], corner2[0]);\n    const maxY = Math.max(corner1[1], corner2[1]);\n\n    const polygonPoints = bboxPolygon([minX, minY, maxX, maxY]).geometry.coordinates[0];\n    const centerCoordinates = getIntermediatePosition(corner1, corner2);\n\n    const xSemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[1])), 0.001);\n    const ySemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[3])), 0.001);\n\n    this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis));\n\n    return result;\n  }\n}\n","// @flow\n\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport bearing from '@turf/bearing';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ThreeClickPolygonHandler } from './three-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawEllipseUsingThreePointsHandler extends ThreeClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const groundCoords = event.groundCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], groundCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const [p1, p2] = clickSequence;\n\n      const centerCoordinates = getIntermediatePosition(p1, p2);\n      const xSemiAxis = Math.max(distance(centerCoordinates, point(groundCoords)), 0.001);\n      const ySemiAxis = Math.max(distance(p1, p2), 0.001) / 2;\n      const options = { angle: bearing(p1, p2) };\n\n      this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis, options));\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport bearing from '@turf/bearing';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { getPickedEditHandle } from './mode-handler.js';\nimport { ModifyHandler } from './modify-handler';\n\nexport class ExtrudeHandler extends ModifyHandler {\n  isPointAdded: boolean = false;\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    this._lastPointerMovePicks = event.picks;\n\n    let editAction: ?EditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, editHandle.featureIndex);\n      if (p1 && p2) {\n        // p3 and p4 are end points for moving (extruding) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.groundCoords);\n\n        const updatedData = this.getImmutableFeatureCollection()\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruding',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: this.nextPositionIndexes(editHandle.positionIndexes, size),\n            position: p3\n          }\n        };\n      }\n    }\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n\n    return { editAction, cancelMapPan };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle && editHandle.type === 'intermediate') {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(editHandle.positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(\n        editHandle.positionIndexes,\n        editHandle.featureIndex\n      );\n\n      if (p1 && p2) {\n        let updatedData = this.getImmutableFeatureCollection();\n        if (!this.isOrthogonal(editHandle.positionIndexes, editHandle.featureIndex, size)) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p2\n          );\n        }\n        if (\n          !this.isOrthogonal(\n            this.prevPositionIndexes(editHandle.positionIndexes, size),\n            editHandle.featureIndex,\n            size\n          )\n        ) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p1\n          );\n          this.isPointAdded = true;\n        }\n\n        editAction = {\n          updatedData: updatedData.getObject(),\n          editType: 'startExtruding',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: editHandle.positionIndexes,\n            position: p1\n          }\n        };\n      }\n    }\n\n    return editAction;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, editHandle.featureIndex);\n\n      if (p1 && p2) {\n        // p3 and p4 are end points for new moved (extruded) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.groundCoords);\n\n        const updatedData = this.getImmutableFeatureCollection()\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruded',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: editHandle.positionIndexes,\n            position: p3\n          }\n        };\n      }\n    }\n    this.isPointAdded = false;\n\n    return editAction;\n  }\n\n  coordinatesSize(positionIndexes: number[], featureIndex: number) {\n    let size = 0;\n    const feature = this.getImmutableFeatureCollection().getObject().features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        size = coordinates[a][b].length;\n      }\n    } else {\n      const [b] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        size = coordinates[b].length;\n      }\n    }\n    return size;\n  }\n\n  getBearing(p1: any, p2: any) {\n    const angle = bearing(p1, p2);\n    if (angle < 0) {\n      return Math.floor(360 + angle);\n    }\n    return Math.floor(angle);\n  }\n\n  isOrthogonal(positionIndexes: number[], featureIndex: number, size: number) {\n    if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n      positionIndexes[positionIndexes.length - 1] = 0;\n    }\n    const prevPoint = this.getPointForPositionIndexes(\n      this.prevPositionIndexes(positionIndexes, size),\n      featureIndex\n    );\n    const nextPoint = this.getPointForPositionIndexes(\n      this.nextPositionIndexes(positionIndexes, size),\n      featureIndex\n    );\n    const currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex);\n    const prevAngle = this.getBearing(currentPoint, prevPoint);\n    const nextAngle = this.getBearing(currentPoint, nextPoint);\n    return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n  }\n\n  nextPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const next = [...positionIndexes];\n    if (next.length) {\n      next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n    }\n    return next;\n  }\n\n  prevPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const prev = [...positionIndexes];\n    if (prev.length) {\n      prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n    }\n    return prev;\n  }\n\n  getPointForPositionIndexes(positionIndexes: number[], featureIndex: number) {\n    let p1;\n    const feature = this.getImmutableFeatureCollection().getObject().features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b, c] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        p1 = coordinates[a][b][c];\n      }\n    } else {\n      const [b, c] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        p1 = coordinates[b][c];\n      }\n    }\n    return p1;\n  }\n}\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  DoubleClickEvent\n} from '../event-types.js';\n\n// Minimum number of pixels the pointer must move from the original pointer down to be considered dragging\nconst MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS = 7;\n\nexport default class EditableLayer extends CompositeLayer {\n  // Overridable interaction event handlers\n  onLayerClick(event: ClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onDoubleClick(event: DoubleClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    // default implementation - do nothing\n  }\n\n  // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  initializeState() {\n    this.setState({\n      _editableLayerState: {\n        // Pointer event handlers\n        pointerHandlers: null,\n        // Picked objects at the time the pointer went down\n        pointerDownPicks: null,\n        // Screen coordinates where the pointer went down\n        pointerDownScreenCoords: null,\n        // Ground coordinates where the pointer went down\n        pointerDownGroundCoords: null,\n        // Is the pointer dragging (pointer down + moved at least MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS)\n        isDragging: false\n      }\n    });\n  }\n\n  finalizeState() {\n    this._removePointerHandlers();\n  }\n\n  updateState({ props, changeFlags }: Object) {\n    // unsubscribe previous layer instance's handlers\n    this._removePointerHandlers();\n    this._addPointerHandlers();\n  }\n\n  _removePointerHandlers() {\n    if (this.state._editableLayerState.pointerHandlers) {\n      this.context.gl.canvas.removeEventListener(\n        'pointermove',\n        this.state._editableLayerState.pointerHandlers.onPointerMove\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerdown',\n        this.state._editableLayerState.pointerHandlers.onPointerDown\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerup',\n        this.state._editableLayerState.pointerHandlers.onPointerUp\n      );\n      this.context.gl.canvas.removeEventListener(\n        'dblclick',\n        this.state._editableLayerState.pointerHandlers.onDoubleClick\n      );\n    }\n    this.state._editableLayerState.pointerHandlers = null;\n  }\n\n  _addPointerHandlers() {\n    this.state._editableLayerState.pointerHandlers = {\n      onPointerMove: this._onPointerMove.bind(this),\n      onPointerDown: this._onPointerDown.bind(this),\n      onPointerUp: this._onPointerUp.bind(this),\n      onDoubleClick: this._onDoubleClick.bind(this)\n    };\n\n    this.context.gl.canvas.addEventListener(\n      'pointermove',\n      this.state._editableLayerState.pointerHandlers.onPointerMove\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerdown',\n      this.state._editableLayerState.pointerHandlers.onPointerDown\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerup',\n      this.state._editableLayerState.pointerHandlers.onPointerUp\n    );\n    this.context.gl.canvas.addEventListener(\n      'dblclick',\n      this.state._editableLayerState.pointerHandlers.onDoubleClick\n    );\n  }\n\n  _onDoubleClick(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n    this.onDoubleClick({\n      groundCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerDown(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius,\n      depth: this.props.pickingDepth\n    });\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: screenCoords,\n        pointerDownGroundCoords: groundCoords,\n        pointerDownPicks: picks,\n        isDragging: false\n      }\n    });\n  }\n\n  _onPointerMove(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords\n    } = this.state._editableLayerState;\n\n    let { isDragging } = this.state._editableLayerState;\n\n    if (pointerDownScreenCoords) {\n      // Pointer went down and is moving\n\n      // Did it move enough to consider it a drag\n      if (!isDragging && this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n        // OK, this is considered dragging\n\n        // Fire the start dragging event\n        this.onStartDragging({\n          picks: pointerDownPicks,\n          screenCoords,\n          groundCoords,\n          pointerDownScreenCoords,\n          pointerDownGroundCoords,\n          sourceEvent: event\n        });\n\n        isDragging = true;\n        this.setState({\n          _editableLayerState: {\n            ...this.state._editableLayerState,\n            isDragging\n          }\n        });\n      }\n    }\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius,\n      depth: this.props.pickingDepth\n    });\n\n    this.onPointerMove({\n      screenCoords,\n      groundCoords,\n      picks,\n      isDragging,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerUp(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords,\n      isDragging\n    } = this.state._editableLayerState;\n\n    if (!pointerDownScreenCoords) {\n      // This is a pointer up without a pointer down (e.g. user pointer downed elsewhere), so ignore\n      return;\n    }\n\n    if (isDragging) {\n      this.onStopDragging({\n        picks: pointerDownPicks,\n        screenCoords,\n        groundCoords,\n        pointerDownScreenCoords,\n        pointerDownGroundCoords,\n        sourceEvent: event\n      });\n    } else if (!this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n      this.onLayerClick({\n        picks: pointerDownPicks,\n        screenCoords,\n        groundCoords,\n        sourceEvent: event\n      });\n    }\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: null,\n        pointerDownGroundCoords: null,\n        pointerDownPicks: null,\n        isDragging: false\n      }\n    });\n  }\n\n  getScreenCoords(pointerEvent: Object) {\n    return [\n      pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().x,\n      pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().y\n    ];\n  }\n\n  getGroundCoords(screenCoords: number[]) {\n    return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n  }\n\n  movedEnoughForDrag(screenCoords1: number[], screenCoords2: number[]) {\n    return (\n      Math.abs(screenCoords1[0] - screenCoords2[0]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS ||\n      Math.abs(screenCoords1[1] - screenCoords2[1]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS\n    );\n  }\n}\n\nEditableLayer.layerName = 'EditableLayer';\n","// @flow\n/* eslint-env browser */\n\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer } from '@deck.gl/layers';\nimport { type Position } from '@nebula.gl/edit-modes';\nimport { ModeHandler } from '../mode-handlers/mode-handler.js';\nimport { ViewHandler } from '../mode-handlers/view-handler.js';\nimport { ModifyHandler } from '../mode-handlers/modify-handler.js';\nimport { ElevationHandler } from '../mode-handlers/elevation-handler.js';\nimport { SnappableHandler } from '../mode-handlers/snappable-handler.js';\nimport { TranslateHandler } from '../mode-handlers/translate-handler.js';\nimport { DuplicateHandler } from '../mode-handlers/duplicate-handler';\nimport { RotateHandler } from '../mode-handlers/rotate-handler.js';\nimport { ScaleHandler } from '../mode-handlers/scale-handler.js';\nimport { DrawPointHandler } from '../mode-handlers/draw-point-handler.js';\nimport { DrawLineStringHandler } from '../mode-handlers/draw-line-string-handler.js';\nimport { DrawPolygonHandler } from '../mode-handlers/draw-polygon-handler.js';\nimport { Draw90DegreePolygonHandler } from '../mode-handlers/draw-90degree-polygon-handler.js';\nimport { DrawRectangleHandler } from '../mode-handlers/draw-rectangle-handler.js';\nimport { SplitPolygonHandler } from '../mode-handlers/split-polygon-handler.js';\nimport { DrawRectangleUsingThreePointsHandler } from '../mode-handlers/draw-rectangle-using-three-points-handler.js';\nimport { DrawCircleFromCenterHandler } from '../mode-handlers/draw-circle-from-center-handler.js';\nimport { DrawCircleByBoundingBoxHandler } from '../mode-handlers/draw-circle-by-bounding-box-handler.js';\nimport { DrawEllipseByBoundingBoxHandler } from '../mode-handlers/draw-ellipse-by-bounding-box-handler.js';\nimport { DrawEllipseUsingThreePointsHandler } from '../mode-handlers/draw-ellipse-using-three-points-handler.js';\n\nimport type { EditAction } from '../mode-handlers/mode-handler.js';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent\n} from '../event-types.js';\nimport { ExtrudeHandler } from '../mode-handlers/extrude-handler.js';\nimport EditableLayer from './editable-layer.js';\n\nconst DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\n\nfunction getEditHandleColor(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nconst defaultProps = {\n  mode: 'modify',\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  pickingRadius: 10,\n  pickingDepth: 5,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'meters',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineDashJustified: false,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: f =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: f => (f && f.properties && f.properties.lineWidth) || 1,\n  getLineDashArray: (feature, isSelected, mode) =>\n    isSelected && mode !== 'view' ? [7, 4] : [0, 0],\n\n  // Tentative feature rendering\n  getTentativeLineDashArray: (f, mode) => [7, 4],\n  getTentativeLineColor: (f, mode) => DEFAULT_SELECTED_LINE_COLOR,\n  getTentativeFillColor: (f, mode) => DEFAULT_SELECTED_FILL_COLOR,\n  getTentativeLineWidth: (f, mode) => (f && f.properties && f.properties.lineWidth) || 1,\n\n  editHandleType: 'point',\n  editHandleParameters: {},\n  editHandleLayerProps: {},\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: false,\n  editHandlePointStrokeWidth: 1,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: handle => handle.type,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // misc\n  billboard: true,\n\n  // Mode handlers\n  modeHandlers: {\n    view: new ViewHandler(),\n    modify: new ModifyHandler(),\n    elevation: new ElevationHandler(),\n    extrude: new ExtrudeHandler(),\n    rotate: new RotateHandler(),\n    translate: new SnappableHandler(new TranslateHandler()),\n    duplicate: new DuplicateHandler(),\n    scale: new ScaleHandler(),\n    drawPoint: new DrawPointHandler(),\n    drawLineString: new DrawLineStringHandler(),\n    drawPolygon: new DrawPolygonHandler(),\n    draw90DegreePolygon: new Draw90DegreePolygonHandler(),\n    split: new SplitPolygonHandler(),\n    drawRectangle: new DrawRectangleHandler(),\n    drawRectangleUsing3Points: new DrawRectangleUsingThreePointsHandler(),\n    drawCircleFromCenter: new DrawCircleFromCenterHandler(),\n    drawCircleByBoundingBox: new DrawCircleByBoundingBoxHandler(),\n    drawEllipseByBoundingBox: new DrawEllipseByBoundingBoxHandler(),\n    drawEllipseUsing3Points: new DrawEllipseUsingThreePointsHandler()\n  }\n};\n\ntype Props = {\n  mode: string,\n  modeHandlers: { [mode: string]: ModeHandler },\n  onEdit: EditAction => void,\n  // TODO: type the rest\n  [string]: any\n};\n\n// type State = {\n//   modeHandler: EditableFeatureCollection,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nexport default class EditableGeoJsonLayer extends EditableLayer {\n  // state: State;\n  // props: Props;\n  // setState: ($Shape<State>) => void;\n\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      lineDashJustified: this.props.lineDashJustified,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n      getLineDashArray: this.selectionAwareAccessor(this.props.getLineDashArray),\n\n      _subLayerProps: {\n        'line-strings': {\n          billboard: this.props.billboard\n        },\n        'polygons-stroke': {\n          billboard: this.props.billboard\n        }\n      },\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineDashArray: [this.props.selectedFeatureIndexes, this.props.mode]\n      }\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createTentativeLayers());\n    layers = layers.concat(this.createEditHandleLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      selectedFeatures: [],\n      editHandles: []\n    });\n  }\n\n  // TODO: figure out how to properly update state from an outside event handler\n  shouldUpdateState({ props, oldProps, context, oldContext, changeFlags }: Object) {\n    if (changeFlags.stateChanged) {\n      return true;\n    }\n    return true;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }: {\n    props: Props,\n    oldProps: Props,\n    changeFlags: any\n  }) {\n    super.updateState({ props, changeFlags });\n\n    let modeHandler: ModeHandler = this.state.modeHandler;\n    if (changeFlags.propsOrDataChanged) {\n      if (props.modeHandlers !== oldProps.modeHandlers || props.mode !== oldProps.mode) {\n        modeHandler = props.modeHandlers[props.mode];\n\n        if (!modeHandler) {\n          console.warn(`No handler configured for mode ${props.mode}`); // eslint-disable-line no-console,no-undef\n          // Use default mode handler\n          modeHandler = new ModeHandler();\n        }\n\n        if (modeHandler !== this.state.modeHandler) {\n          this.setState({ modeHandler });\n        }\n\n        modeHandler.setFeatureCollection(props.data);\n      } else if (changeFlags.dataChanged) {\n        modeHandler.setFeatureCollection(props.data);\n      }\n\n      modeHandler.setModeConfig(props.modeConfig);\n      modeHandler.setSelectedFeatureIndexes(props.selectedFeatureIndexes);\n      this.updateTentativeFeature();\n      this.updateEditHandles();\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map(elem => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Object) => accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Object) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Object) {\n    if (sourceLayer.id.endsWith('-edit-handles')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isEditingHandle = true;\n    }\n\n    return info;\n  }\n\n  createEditHandleLayers() {\n    if (!this.state.editHandles.length) {\n      return [];\n    }\n\n    const sharedProps = {\n      id: `${this.props.editHandleType.layerName || this.props.editHandleType}-edit-handles`,\n      data: this.state.editHandles,\n      fp64: this.props.fp64,\n\n      parameters: this.props.editHandleParameters,\n      ...this.props.editHandleLayerProps\n    };\n\n    let layer;\n\n    switch (this.props.editHandleType) {\n      case 'icon':\n        layer = new IconLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n            iconAtlas: this.props.editHandleIconAtlas,\n            iconMapping: this.props.editHandleIconMapping,\n            sizeScale: this.props.editHandleIconSizeScale,\n            getIcon: this.props.getEditHandleIcon,\n            getSize: this.props.getEditHandleIconSize,\n            getColor: this.props.getEditHandleIconColor,\n            getAngle: this.props.getEditHandleIconAngle,\n\n            getPosition: d => d.position\n          })\n        );\n        break;\n\n      case 'point':\n        layer = new ScatterplotLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n\n            // Proxy editing point props\n            radiusScale: this.props.editHandlePointRadiusScale,\n            outline: this.props.editHandlePointOutline,\n            strokeWidth: this.props.editHandlePointStrokeWidth,\n            radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n            radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n            getRadius: this.props.getEditHandlePointRadius,\n            getColor: this.props.getEditHandlePointColor\n          })\n        );\n        break;\n\n      default:\n        if (typeof this.props.editHandleType === 'function') {\n          const EditHandleType = this.props.editHandleType;\n          layer = new EditHandleType(\n            this.getSubLayerProps({\n              ...sharedProps,\n\n              // Proxy editing point props\n              radiusScale: this.props.editHandlePointRadiusScale,\n              outline: this.props.editHandlePointOutline,\n              strokeWidth: this.props.editHandlePointStrokeWidth,\n              radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n              radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n              getRadius: this.props.getEditHandlePointRadius,\n              getColor: this.props.getEditHandlePointColor\n            })\n          );\n        }\n        break;\n    }\n\n    return [layer];\n  }\n\n  createTentativeLayers() {\n    if (!this.state.tentativeFeature) {\n      return [];\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: 'tentative',\n        data: this.state.tentativeFeature,\n        fp64: this.props.fp64,\n        pickable: false,\n        stroked: true,\n        autoHighlight: false,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        pointRadiusScale: this.props.editHandlePointRadiusScale,\n        outline: this.props.editHandlePointOutline,\n        strokeWidth: this.props.editHandlePointStrokeWidth,\n        pointRadiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        pointRadiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: this.props.getEditHandlePointRadius,\n        getLineColor: feature => this.props.getTentativeLineColor(feature, this.props.mode),\n        getLineWidth: feature => this.props.getTentativeLineWidth(feature, this.props.mode),\n        getFillColor: feature => this.props.getTentativeFillColor(feature, this.props.mode),\n        getLineDashArray: feature =>\n          this.props.getTentativeLineDashArray(\n            feature,\n            this.state.selectedFeatures[0],\n            this.props.mode\n          )\n      })\n    );\n\n    return [layer];\n  }\n\n  updateTentativeFeature() {\n    const tentativeFeature = this.state.modeHandler.getTentativeFeature();\n    if (tentativeFeature !== this.state.tentativeFeature) {\n      this.setState({ tentativeFeature });\n      this.setLayerNeedsUpdate();\n    }\n  }\n\n  updateEditHandles(picks?: Array<Object>, groundCoords?: Position) {\n    const editHandles = this.state.modeHandler.getEditHandles(picks, groundCoords);\n    if (editHandles !== this.state.editHandles) {\n      this.setState({ editHandles });\n      this.setLayerNeedsUpdate();\n    }\n  }\n\n  onLayerClick(event: ClickEvent) {\n    const editAction = this.state.modeHandler.handleClick(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    const editAction = this.state.modeHandler.handleStartDragging(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    const editAction = this.state.modeHandler.handleStopDragging(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    const { groundCoords, picks, sourceEvent } = event;\n\n    const { editAction, cancelMapPan } = this.state.modeHandler.handlePointerMove(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles(picks, groundCoords);\n\n    if (cancelMapPan) {\n      // TODO: find a less hacky way to prevent map panning\n      // Stop propagation to prevent map panning while dragging an edit handle\n      sourceEvent.stopPropagation();\n    }\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    return this.state.modeHandler.getCursor({ isDragging });\n  }\n}\n\nEditableGeoJsonLayer.layerName = 'EditableGeoJsonLayer';\nEditableGeoJsonLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  DoubleClickEvent\n} from '@nebula.gl/edit-modes';\n\n// Minimum number of pixels the pointer must move from the original pointer down to be considered dragging\nconst MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS = 7;\n\n// eslint-disable-next-line camelcase\nexport default class EditableLayer_EDIT_MODE_POC extends CompositeLayer {\n  // Overridable interaction event handlers\n  onLayerClick(event: ClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onDoubleClick(event: DoubleClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    // default implementation - do nothing\n  }\n\n  // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  initializeState() {\n    this.setState({\n      _editableLayerState: {\n        // Pointer event handlers\n        pointerHandlers: null,\n        // Picked objects at the time the pointer went down\n        pointerDownPicks: null,\n        // Screen coordinates where the pointer went down\n        pointerDownScreenCoords: null,\n        // Ground coordinates where the pointer went down\n        pointerDownMapCoords: null,\n        // Is the pointer dragging (pointer down + moved at least MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS)\n        isDragging: false\n      }\n    });\n  }\n\n  finalizeState() {\n    this._removePointerHandlers();\n  }\n\n  updateState({ props, changeFlags }: Object) {\n    // unsubscribe previous layer instance's handlers\n    this._removePointerHandlers();\n    this._addPointerHandlers();\n  }\n\n  _removePointerHandlers() {\n    if (this.state._editableLayerState.pointerHandlers) {\n      this.context.gl.canvas.removeEventListener(\n        'pointermove',\n        this.state._editableLayerState.pointerHandlers.onPointerMove\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerdown',\n        this.state._editableLayerState.pointerHandlers.onPointerDown\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerup',\n        this.state._editableLayerState.pointerHandlers.onPointerUp\n      );\n      this.context.gl.canvas.removeEventListener(\n        'dblclick',\n        this.state._editableLayerState.pointerHandlers.onDoubleClick\n      );\n    }\n    this.state._editableLayerState.pointerHandlers = null;\n  }\n\n  _addPointerHandlers() {\n    this.state._editableLayerState.pointerHandlers = {\n      onPointerMove: this._onPointerMove.bind(this),\n      onPointerDown: this._onPointerDown.bind(this),\n      onPointerUp: this._onPointerUp.bind(this),\n      onDoubleClick: this._onDoubleClick.bind(this)\n    };\n\n    this.context.gl.canvas.addEventListener(\n      'pointermove',\n      this.state._editableLayerState.pointerHandlers.onPointerMove\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerdown',\n      this.state._editableLayerState.pointerHandlers.onPointerDown\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerup',\n      this.state._editableLayerState.pointerHandlers.onPointerUp\n    );\n    this.context.gl.canvas.addEventListener(\n      'dblclick',\n      this.state._editableLayerState.pointerHandlers.onDoubleClick\n    );\n  }\n\n  _onDoubleClick(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n    this.onDoubleClick({\n      mapCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerDown(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius || 10,\n      depth: 2\n    });\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: screenCoords,\n        pointerDownMapCoords: mapCoords,\n        pointerDownPicks: picks,\n        isDragging: false\n      }\n    });\n  }\n\n  _onPointerMove(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords\n    } = this.state._editableLayerState;\n\n    let { isDragging } = this.state._editableLayerState;\n\n    if (pointerDownScreenCoords) {\n      // Pointer went down and is moving\n\n      // Did it move enough to consider it a drag\n      if (!isDragging && this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n        // OK, this is considered dragging\n\n        // Fire the start dragging event\n        this.onStartDragging({\n          picks: pointerDownPicks,\n          screenCoords,\n          mapCoords,\n          pointerDownScreenCoords,\n          pointerDownMapCoords,\n          sourceEvent: event\n        });\n\n        isDragging = true;\n        this.setState({\n          _editableLayerState: {\n            ...this.state._editableLayerState,\n            isDragging\n          }\n        });\n      }\n    }\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius || 10,\n      depth: 2\n    });\n\n    this.onPointerMove({\n      screenCoords,\n      mapCoords,\n      picks,\n      isDragging,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerUp(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      isDragging\n    } = this.state._editableLayerState;\n\n    if (!pointerDownScreenCoords) {\n      // This is a pointer up without a pointer down (e.g. user pointer downed elsewhere), so ignore\n      return;\n    }\n\n    if (isDragging) {\n      this.onStopDragging({\n        picks: pointerDownPicks,\n        screenCoords,\n        mapCoords,\n        pointerDownScreenCoords,\n        pointerDownMapCoords,\n        sourceEvent: event\n      });\n    } else if (!this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n      this.onLayerClick({\n        picks: pointerDownPicks,\n        screenCoords,\n        mapCoords,\n        sourceEvent: event\n      });\n    }\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: null,\n        pointerDownMapCoords: null,\n        pointerDownPicks: null,\n        isDragging: false\n      }\n    });\n  }\n\n  getScreenCoords(pointerEvent: Object) {\n    return [\n      pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().x,\n      pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().y\n    ];\n  }\n\n  getMapCoords(screenCoords: number[]) {\n    return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n  }\n\n  movedEnoughForDrag(screenCoords1: number[], screenCoords2: number[]) {\n    return (\n      Math.abs(screenCoords1[0] - screenCoords2[0]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS ||\n      Math.abs(screenCoords1[1] - screenCoords2[1]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS\n    );\n  }\n}\n\n// eslint-disable-next-line camelcase\nEditableLayer_EDIT_MODE_POC.layerName = 'EditableLayer_EDIT_MODE_POC';\n","// @flow\n/* eslint-env browser */\n\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer } from '@deck.gl/layers';\n\nimport { ViewMode, DrawPolygonMode } from '@nebula.gl/edit-modes';\nimport type {\n  EditAction,\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  GeoJsonEditMode,\n  FeatureCollection\n} from '@nebula.gl/edit-modes';\nimport EditableLayer from './editable-layer-edit-mode-poc.js';\n\nconst DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\n\nfunction getEditHandleColor(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nconst defaultProps = {\n  mode: 'modify',\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  pickingRadius: 10,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'meters',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineDashJustified: false,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: f =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: f => (f && f.properties && f.properties.lineWidth) || 1,\n  getLineDashArray: (feature, isSelected, mode) =>\n    isSelected && mode !== 'view' ? [7, 4] : [0, 0],\n\n  // Tentative feature rendering\n  getTentativeLineDashArray: (f, mode) => [7, 4],\n  getTentativeLineColor: (f, mode) => DEFAULT_SELECTED_LINE_COLOR,\n  getTentativeFillColor: (f, mode) => DEFAULT_SELECTED_FILL_COLOR,\n  getTentativeLineWidth: (f, mode) => (f && f.properties && f.properties.lineWidth) || 1,\n\n  editHandleType: 'point',\n  editHandleParameters: {},\n  editHandleLayerProps: {},\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: false,\n  editHandlePointStrokeWidth: 1,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: handle => handle.type,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // Mode handlers\n  modeHandlers: {\n    view: new ViewMode(),\n    drawPolygon: new DrawPolygonMode()\n  }\n};\n\ntype Props = {\n  mode: string,\n  modeHandlers: { [mode: string]: GeoJsonEditMode },\n  onEdit: (EditAction<FeatureCollection>) => void,\n  // TODO: type the rest\n  [string]: any\n};\n\n// type State = {\n//   modeHandler: EditableFeatureCollection,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\n// eslint-disable-next-line camelcase\nexport default class EditableGeoJsonLayer_EDIT_MODE_POC extends EditableLayer {\n  // state: State;\n  // props: Props;\n  // setState: ($Shape<State>) => void;\n\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      lineDashJustified: this.props.lineDashJustified,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n      getLineDashArray: this.selectionAwareAccessor(this.props.getLineDashArray),\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineDashArray: [this.props.selectedFeatureIndexes, this.props.mode]\n      }\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createTentativeLayers());\n    layers = layers.concat(this.createEditHandleLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      cursor: 'grab',\n      selectedFeatures: [],\n      editHandles: []\n    });\n  }\n\n  setState(partialState: any) {\n    super.setState(partialState);\n    this.updateModeState(this.props);\n  }\n\n  // TODO: figure out how to properly update state from an outside event handler\n  shouldUpdateState() {\n    return true;\n  }\n\n  // shouldUpdateState(opts: Object) {\n  //   let shouldUpdateState = super.shouldUpdateState(opts);\n\n  //   if (opts.changeFlags.stateChanged) {\n  //     shouldUpdateState = true;\n\n  //     // const needsRedraw = this.getNeedsRedraw && this.getNeedsRedraw()\n  //     // console.log(\n  //     //   'calling modeHandler.updateState',\n  //     //   this.getNeedsRedraw(),\n  //     //   this.internalState.needsRedraw,\n  //     //   JSON.stringify(changeFlags)\n  //     // );\n\n  //     this.updateModeState(this.props);\n  //   }\n  //   return shouldUpdateState;\n  // }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }: {\n    props: Props,\n    oldProps: Props,\n    changeFlags: any\n  }) {\n    super.updateState({ props, changeFlags });\n\n    let modeHandler: GeoJsonEditMode = this.state.modeHandler;\n    if (changeFlags.propsOrDataChanged) {\n      if (props.modeHandlers !== oldProps.modeHandlers || props.mode !== oldProps.mode) {\n        modeHandler = props.modeHandlers[props.mode];\n\n        if (!modeHandler) {\n          console.warn(`No handler configured for mode ${props.mode}`); // eslint-disable-line no-console,no-undef\n          // Use default mode handler\n          modeHandler = new ViewMode();\n        }\n\n        if (modeHandler !== this.state.modeHandler) {\n          this.setState({ modeHandler });\n        }\n      }\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map(elem => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  updateModeState(props: Props) {\n    const modeHandler = props.modeHandlers[props.mode];\n\n    modeHandler.updateState({\n      modeConfig: props.modeConfig,\n      data: props.data,\n      selectedIndexes: props.selectedFeatureIndexes,\n      guides: this.state && {\n        tentativeFeature: this.state.tentativeFeature,\n        editHandles: this.state.editHandles\n      },\n      cursor: this.state.cursor,\n      onEdit: (editAction: EditAction<FeatureCollection>) => {\n        props.onEdit(editAction);\n      },\n      onUpdateGuides: guides => {\n        if (guides) {\n          this.setState({\n            tentativeFeature: guides.tentativeFeature,\n            editHandles: guides.editHandles\n          });\n        } else {\n          this.setState({\n            tentativeFeature: null,\n            editHandles: null\n          });\n        }\n        this.setLayerNeedsUpdate();\n        this.setNeedsRedraw();\n      },\n      onUpdateCursor: cursor => {\n        this.setState({ cursor });\n      }\n    });\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Object) => accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Object) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Object) {\n    if (sourceLayer.id.endsWith('-edit-handles')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isGuide = true;\n    }\n\n    return info;\n  }\n\n  createEditHandleLayers() {\n    if (!this.state.editHandles.length) {\n      return [];\n    }\n\n    const sharedProps = {\n      id: `${this.props.editHandleType.layerName || this.props.editHandleType}-edit-handles`,\n      data: this.state.editHandles,\n      fp64: this.props.fp64,\n\n      parameters: this.props.editHandleParameters,\n      ...this.props.editHandleLayerProps\n    };\n\n    let layer;\n\n    switch (this.props.editHandleType) {\n      case 'icon':\n        layer = new IconLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n            iconAtlas: this.props.editHandleIconAtlas,\n            iconMapping: this.props.editHandleIconMapping,\n            sizeScale: this.props.editHandleIconSizeScale,\n            getIcon: this.props.getEditHandleIcon,\n            getSize: this.props.getEditHandleIconSize,\n            getColor: this.props.getEditHandleIconColor,\n            getAngle: this.props.getEditHandleIconAngle,\n\n            getPosition: d => d.position\n          })\n        );\n        break;\n\n      case 'point':\n        layer = new ScatterplotLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n\n            // Proxy editing point props\n            radiusScale: this.props.editHandlePointRadiusScale,\n            outline: this.props.editHandlePointOutline,\n            strokeWidth: this.props.editHandlePointStrokeWidth,\n            radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n            radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n            getRadius: this.props.getEditHandlePointRadius,\n            getColor: this.props.getEditHandlePointColor\n          })\n        );\n        break;\n\n      default:\n        if (typeof this.props.editHandleType === 'function') {\n          const EditHandleType = this.props.editHandleType;\n          layer = new EditHandleType(\n            this.getSubLayerProps({\n              ...sharedProps,\n\n              // Proxy editing point props\n              radiusScale: this.props.editHandlePointRadiusScale,\n              outline: this.props.editHandlePointOutline,\n              strokeWidth: this.props.editHandlePointStrokeWidth,\n              radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n              radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n              getRadius: this.props.getEditHandlePointRadius,\n              getColor: this.props.getEditHandlePointColor\n            })\n          );\n        }\n        break;\n    }\n\n    return [layer];\n  }\n\n  createTentativeLayers() {\n    if (!this.state.tentativeFeature) {\n      return [];\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: 'tentative',\n        data: this.state.tentativeFeature,\n        fp64: this.props.fp64,\n        pickable: false,\n        stroked: true,\n        autoHighlight: false,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        pointRadiusScale: this.props.editHandlePointRadiusScale,\n        outline: this.props.editHandlePointOutline,\n        strokeWidth: this.props.editHandlePointStrokeWidth,\n        pointRadiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        pointRadiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: this.props.getEditHandlePointRadius,\n        getLineColor: feature => this.props.getTentativeLineColor(feature, this.props.mode),\n        getLineWidth: feature => this.props.getTentativeLineWidth(feature, this.props.mode),\n        getFillColor: feature => this.props.getTentativeFillColor(feature, this.props.mode),\n        getLineDashArray: feature =>\n          this.props.getTentativeLineDashArray(\n            feature,\n            this.state.selectedFeatures[0],\n            this.props.mode\n          )\n      })\n    );\n\n    return [layer];\n  }\n\n  onLayerClick(event: ClickEvent) {\n    this.getActiveModeHandler().handleClick(event);\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    this.getActiveModeHandler().handleStartDragging(event);\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    this.getActiveModeHandler().handleStopDragging(event);\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    this.getActiveModeHandler().handlePointerMove(event);\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    return this.state.cursor;\n  }\n\n  getActiveModeHandler(): GeoJsonEditMode {\n    return this.state.modeHandler;\n  }\n}\n\n// eslint-disable-next-line camelcase\nEditableGeoJsonLayer_EDIT_MODE_POC.layerName = 'EditableGeoJsonLayer_EDIT_MODE_POC';\n// eslint-disable-next-line camelcase\nEditableGeoJsonLayer_EDIT_MODE_POC.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\nimport { CompositeLayer } from '@deck.gl/core';\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { polygon } from '@turf/helpers';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\n\nimport EditableGeoJsonLayer from './editable-geojson-layer';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nconst defaultProps = {\n  selectionType: SELECTION_TYPE.RECTANGLE,\n  layerIds: [],\n  onSelect: () => {}\n};\n\nconst EMPTY_DATA = {\n  type: 'FeatureCollection',\n  features: []\n};\n\nconst EXPANSION_KM = 50;\nconst LAYER_ID_GEOJSON = 'selection-geojson';\nconst LAYER_ID_BLOCKER = 'selection-blocker';\n\nconst PASS_THROUGH_PROPS = [\n  'lineWidthScale',\n  'lineWidthMinPixels',\n  'lineWidthMaxPixels',\n  'lineWidthUnits',\n  'lineJointRounded',\n  'lineMiterLimit',\n  'pointRadiusScale',\n  'pointRadiusMinPixels',\n  'pointRadiusMaxPixels',\n  'lineDashJustified',\n  'getLineColor',\n  'getFillColor',\n  'getRadius',\n  'getLineWidth',\n  'getLineDashArray',\n  'getTentativeLineDashArray',\n  'getTentativeLineColor',\n  'getTentativeFillColor',\n  'getTentativeLineWidth'\n];\n\nexport default class SelectionLayer extends CompositeLayer {\n  _selectRectangleObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n\n    const [x1, y1] = this.context.viewport.project(coordinates[0][0]);\n    const [x2, y2] = this.context.viewport.project(coordinates[0][2]);\n\n    const pickingInfos = this.context.deck.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds\n    });\n\n    onSelect({ pickingInfos });\n  }\n\n  _selectPolygonObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n    const mousePoints = coordinates[0].map(c => this.context.viewport.project(c));\n\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    // Use a polygon to hide the outside, because pickObjects()\n    // does not support polygons\n    const landPointsPoly = polygon(coordinates);\n    const bigBuffer = turfBuffer(landPointsPoly, EXPANSION_KM);\n    let bigPolygon;\n    try {\n      // turfDifference throws an exception if the polygon\n      // intersects with itself (TODO: check if true in all versions)\n      bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n    } catch (e) {\n      // invalid selection polygon\n      console.log('turfDifference() error', e); // eslint-disable-line\n      return;\n    }\n\n    this.setState({\n      pendingPolygonSelection: {\n        bigPolygon\n      }\n    });\n\n    const blockerId = `${this.props.id}-${LAYER_ID_BLOCKER}`;\n\n    // HACK, find a better way\n    setTimeout(() => {\n      const pickingInfos = this.context.deck.pickObjects({\n        x,\n        y,\n        width: maxX - x,\n        height: maxY - y,\n        layerIds: [blockerId, ...layerIds]\n      });\n\n      onSelect({\n        pickingInfos: pickingInfos.filter(item => item.layer.id !== this.props.id)\n      });\n    }, 250);\n  }\n\n  renderLayers() {\n    const { pendingPolygonSelection } = this.state;\n\n    const mode =\n      {\n        [SELECTION_TYPE.RECTANGLE]: 'drawRectangle',\n        [SELECTION_TYPE.POLYGON]: 'drawPolygon'\n      }[this.props.selectionType] || 'view';\n\n    const inheritedProps = {};\n    PASS_THROUGH_PROPS.forEach(p => {\n      if (this.props[p] !== undefined) inheritedProps[p] = this.props[p];\n    });\n\n    const layers = [\n      new EditableGeoJsonLayer(\n        this.getSubLayerProps({\n          id: LAYER_ID_GEOJSON,\n          pickable: true,\n          mode,\n          selectedFeatureIndexes: [],\n          data: EMPTY_DATA,\n          onEdit: ({ updatedData, editType }) => {\n            if (editType === 'addFeature') {\n              const { coordinates } = updatedData.features[0].geometry;\n\n              if (this.props.selectionType === SELECTION_TYPE.RECTANGLE) {\n                this._selectRectangleObjects(coordinates);\n              } else if (this.props.selectionType === SELECTION_TYPE.POLYGON) {\n                this._selectPolygonObjects(coordinates);\n              }\n            }\n          },\n          ...inheritedProps\n        })\n      )\n    ];\n\n    if (pendingPolygonSelection) {\n      const { bigPolygon } = pendingPolygonSelection;\n      layers.push(\n        new PolygonLayer(\n          this.getSubLayerProps({\n            id: LAYER_ID_BLOCKER,\n            pickable: true,\n            stroked: false,\n            opacity: 1.0,\n            data: [bigPolygon],\n            getLineColor: obj => [0, 0, 0, 1],\n            getFillColor: obj => [0, 0, 0, 1],\n            getPolygon: o => o.geometry.coordinates\n          })\n        )\n      );\n    }\n\n    return layers;\n  }\n\n  shouldUpdateState({ changeFlags: { stateChanged, propsOrDataChanged } }: Object) {\n    return stateChanged || propsOrDataChanged;\n  }\n}\n\nSelectionLayer.layerName = 'SelectionLayer';\nSelectionLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer, LineLayer } from '@deck.gl/layers';\n\nconst defaultProps = {};\n\nexport default class ElevatedEditHandleLayer extends CompositeLayer {\n  renderLayers() {\n    const handles = new ScatterplotLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-ScatterplotLayer`,\n        data: this.props.data\n      })\n    );\n\n    const lines = new LineLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-LineLayer`,\n        data: this.props.data,\n        pickable: false,\n        getSourcePosition: ({ position }) => [position[0], position[1], 0],\n        getTargetPosition: ({ position }) => [position[0], position[1], position[2] || 0],\n        getColor: [150, 150, 150, 200],\n        getStrokeWidth: 3\n      })\n    );\n\n    return [handles, lines];\n  }\n}\n\nElevatedEditHandleLayer.layerName = 'ElevatedEditHandleLayer';\nElevatedEditHandleLayer.defaultProps = defaultProps;\n","/* eslint-disable camelcase */\nconst INITIAL_STATE = {\n  outlineEnabled: false,\n  outlineRenderShadowmap: false,\n  outlineShadowmap: null\n};\n\nfunction getUniforms({ outlineEnabled, outlineRenderShadowmap, outlineShadowmap } = INITIAL_STATE) {\n  const uniforms = {};\n  if (outlineEnabled !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uEnabled = outlineEnabled;\n  }\n  if (outlineRenderShadowmap !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uRenderOutlines = outlineRenderShadowmap;\n  }\n  if (outlineShadowmap !== undefined) {\n    uniforms.outline_uShadowmap = outlineShadowmap;\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nattribute float instanceZLevel;\nvarying float outline_vzLevel;\nvarying vec4 outline_vPosition;\n\n// Set the z level for the outline shadowmap rendering\nvoid outline_setZLevel(float zLevel) {\n  outline_vzLevel = zLevel;\n}\n\n// Store an adjusted position for texture2DProj\nvoid outline_setUV(vec4 position) {\n  // mat4(\n  //   0.5, 0.0, 0.0, 0.0,\n  //   0.0, 0.5, 0.0, 0.0,\n  //   0.0, 0.0, 0.5, 0.0,\n  //   0.5, 0.5, 0.5, 1.0\n  // ) * position;\n  outline_vPosition = vec4(position.xyz * 0.5 + position.w * 0.5, position.w);\n}\n`;\n\nconst fs = `\\\nuniform bool outline_uEnabled;\nuniform bool outline_uRenderOutlines;\nuniform sampler2D outline_uShadowmap;\n\nvarying float outline_vzLevel;\n// varying vec2 outline_vUV;\nvarying vec4 outline_vPosition;\n\nconst float OUTLINE_Z_LEVEL_ERROR = 0.01;\n\n// Return a darker color in shadowmap\nvec4 outline_filterShadowColor(vec4 color) {\n  return vec4(outline_vzLevel / 255., outline_vzLevel / 255., outline_vzLevel / 255., 1.);\n}\n\n// Return a darker color if in shadowmap\nvec4 outline_filterDarkenColor(vec4 color) {\n  if (outline_uEnabled) {\n    float maxZLevel;\n    if (outline_vPosition.q > 0.0) {\n      maxZLevel = texture2DProj(outline_uShadowmap, outline_vPosition).r * 255.;\n    } else {\n      discard;\n    }\n    if (maxZLevel < outline_vzLevel + OUTLINE_Z_LEVEL_ERROR) {\n      vec4(color.rgb * 0.5, color.a);\n    } else {\n      discard;\n    }\n  }\n  return color;\n}\n\n// if enabled and rendering outlines - Render depth to shadowmap\n// if enabled and rendering colors - Return a darker color if in shadowmap\n// if disabled, just return color\nvec4 outline_filterColor(vec4 color) {\n  if (outline_uEnabled) {\n    return outline_uRenderOutlines ?\n      outline_filterShadowColor(color) :\n      outline_filterDarkenColor(color);\n  }\n  return color;\n}\n`;\n\nexport default {\n  name: 'outline',\n  vs,\n  fs,\n  getUniforms\n};\n","import { PathLayer } from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport { Framebuffer, Texture2D } from '@luma.gl/core';\nimport outline from '../../shaderlib/outline/outline';\n\n// TODO - this should be built into assembleShaders\nfunction injectShaderCode({ source, code = '' }) {\n  const INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nconst VS_CODE = `\\\n  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n`;\n\nconst FS_CODE = `\\\n  gl_FragColor = outline_filterColor(gl_FragColor);\n`;\n\nconst defaultProps = {\n  getZLevel: { type: 'accessor', value: 0 }\n};\n\nexport default class PathOutlineLayer extends PathLayer {\n  // Override getShaders to inject the outline module\n  getShaders() {\n    const shaders = super.getShaders();\n    return Object.assign({}, shaders, {\n      modules: shaders.modules.concat([outline]),\n      vs: injectShaderCode({ source: shaders.vs, code: VS_CODE }),\n      fs: injectShaderCode({ source: shaders.fs, code: FS_CODE })\n    });\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    // Create an outline \"shadow\" map\n    // TODO - we should create a single outlineMap for all layers\n    this.setState({\n      outlineFramebuffer: new Framebuffer(context.gl),\n      dummyTexture: new Texture2D(context.gl)\n    });\n\n    // Create an attribute manager\n    this.state.attributeManager.addInstanced({\n      instanceZLevel: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateZLevels,\n        accessor: 'getZLevel'\n      }\n    });\n  }\n\n  // Override draw to add render module\n  draw({ moduleParameters = {}, parameters, uniforms, context }) {\n    // Need to calculate same uniforms as base layer\n    const {\n      rounded,\n      miterLimit,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n      dashJustified\n    } = this.props;\n\n    uniforms = Object.assign({}, uniforms, {\n      jointType: Number(rounded),\n      alignMode: Number(dashJustified),\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    });\n\n    // Render the outline shadowmap (based on segment z orders)\n    const { outlineFramebuffer, dummyTexture } = this.state;\n    outlineFramebuffer.resize();\n    outlineFramebuffer.clear({ color: true, depth: true });\n\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: true,\n      outlineShadowmap: dummyTexture\n    });\n\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: 0,\n        widthScale: this.props.widthScale * 1.3\n      }),\n      parameters: {\n        depthTest: false,\n        // Biggest value needs to go into buffer\n        blendEquation: GL.MAX\n      },\n      framebuffer: outlineFramebuffer\n    });\n\n    // Now use the outline shadowmap to render the lines (with outlines)\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: false,\n      outlineShadowmap: outlineFramebuffer\n    });\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        widthScale: this.props.widthScale\n      }),\n      parameters: {\n        depthTest: false\n      }\n    });\n  }\n\n  calculateZLevels(attribute) {\n    const { getZLevel } = this.props;\n    const { pathTesselator } = this.state;\n\n    attribute.value = pathTesselator._updateAttribute({\n      target: attribute.value,\n      size: 1,\n      getValue: (object, index) => [getZLevel(object, index) || 0]\n    });\n  }\n}\n\nPathOutlineLayer.layerName = 'PathOutlineLayer';\nPathOutlineLayer.defaultProps = defaultProps;\n","// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { Layer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport { Model, Geometry, loadTextures, Texture2D, fp64 } from '@luma.gl/core';\nconst { fp64LowPart } = fp64;\n\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nconst RADIAN_PER_DEGREE = Math.PI / 180;\n\n// Replacement for the external assert method to reduce bundle size\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(`deck.gl: ${message}`);\n  }\n}\n\n/*\n * Load image data into luma.gl Texture2D objects\n * @param {WebGLContext} gl\n * @param {String|Texture2D|HTMLImageElement|Uint8ClampedArray} src - source of image data\n *   can be url string, Texture2D object, HTMLImageElement or pixel array\n * @returns {Promise} resolves to an object with name -> texture mapping\n */\nfunction getTexture(gl, src, opts) {\n  if (typeof src === 'string') {\n    // Url, load the image\n    return loadTextures(gl, Object.assign({ urls: [src] }, opts))\n      .then(textures => textures[0])\n      .catch(error => {\n        throw new Error(`Could not load texture from ${src}: ${error}`);\n      });\n  }\n  return new Promise(resolve => resolve(getTextureFromData(gl, src, opts)));\n}\n\n/*\n * Convert image data into texture\n * @returns {Texture2D} texture\n */\nfunction getTextureFromData(gl, data, opts) {\n  if (data instanceof Texture2D) {\n    return data;\n  }\n  return new Texture2D(gl, Object.assign({ data }, opts));\n}\n\nfunction validateGeometryAttributes(attributes) {\n  assert(attributes.positions && attributes.normals && attributes.texCoords);\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data) {\n  if (data instanceof Geometry) {\n    validateGeometryAttributes(data.attributes);\n    return data;\n  } else if (data.positions) {\n    validateGeometryAttributes(data);\n    return new Geometry({\n      attributes: data\n    });\n  }\n  throw Error('Invalid mesh');\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  mesh: null,\n  texture: null,\n  sizeScale: { type: 'number', value: 1, min: 0 },\n\n  // TODO - parameters should be merged, not completely overridden\n  parameters: {\n    depthTest: true,\n    depthFunc: GL.LEQUAL\n  },\n  fp64: false,\n  // Optional settings for 'lighting' shader module\n  lightSettings: {},\n\n  getPosition: { type: 'accessor', value: x => x.position },\n  getColor: { type: 'accessor', value: DEFAULT_COLOR },\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  getYaw: { type: 'accessor', value: x => x.yaw || x.angle || 0 },\n  getPitch: { type: 'accessor', value: x => x.pitch || 0 },\n  getRoll: { type: 'accessor', value: x => x.roll || 0 }\n};\n\nexport default class MeshLayer extends Layer {\n  getShaders() {\n    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n    return { vs, fs, modules: [projectModule, 'lighting', 'picking'] };\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instancePositions64xy: {\n        size: 2,\n        accessor: 'getPosition',\n        update: this.calculateInstancePositions64xyLow\n      },\n      instanceRotations: {\n        size: 3,\n        accessor: ['getYaw', 'getPitch', 'getRoll'],\n        update: this.calculateInstanceRotations\n      },\n      instanceColors: {\n        size: 4,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      }\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    const attributeManager = this.getAttributeManager();\n\n    // super.updateState({props, oldProps, changeFlags});\n    if (changeFlags.dataChanged) {\n      attributeManager.invalidateAll();\n    }\n\n    this._updateFP64(props, oldProps);\n\n    if (props.texture !== oldProps.texture) {\n      this.setTexture(props.texture);\n    }\n  }\n\n  _updateFP64(props, oldProps) {\n    if (props.fp64 !== oldProps.fp64) {\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n\n      this.setState({ model: this.getModel(this.context.gl) });\n\n      this.setTexture(this.state.texture);\n\n      const attributeManager = this.getAttributeManager();\n      attributeManager.invalidateAll();\n    }\n  }\n\n  draw({ uniforms }) {\n    const { sizeScale } = this.props;\n\n    this.state.model.render(\n      Object.assign({}, uniforms, {\n        sizeScale\n      })\n    );\n  }\n\n  getModel(gl) {\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: getGeometry(this.props.mesh),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      })\n    );\n  }\n\n  setTexture(src) {\n    const { gl } = this.context;\n    const { model, emptyTexture } = this.state;\n\n    if (src) {\n      getTexture(gl, src).then(texture => {\n        model.setUniforms({ sampler: texture, hasTexture: 1 });\n        this.setState({ texture });\n      });\n    } else {\n      // reset\n      this.state.model.setUniforms({ sampler: emptyTexture, hasTexture: 0 });\n      this.setState({ texture: null });\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const isFP64 = this.use64bitPositions();\n    attribute.constant = !isFP64;\n\n    if (!isFP64) {\n      attribute.value = new Float32Array(2);\n      return;\n    }\n\n    const { data, getPosition } = this.props;\n    const { value } = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = fp64LowPart(position[0]);\n      value[i++] = fp64LowPart(position[1]);\n    }\n  }\n\n  // yaw(z), pitch(y) and roll(x) in radians\n  calculateInstanceRotations(attribute) {\n    const { data, getYaw, getPitch, getRoll } = this.props;\n    const { value, size } = attribute;\n    let i = 0;\n    for (const point of data) {\n      value[i++] = getRoll(point) * RADIAN_PER_DEGREE;\n      value[i++] = getPitch(point) * RADIAN_PER_DEGREE;\n      value[i++] = getYaw(point) * RADIAN_PER_DEGREE;\n    }\n  }\n}\n\nMeshLayer.layerName = 'MeshLayer';\nMeshLayer.defaultProps = defaultProps;\n","export default `\n#define SHADER_NAME mesh-layer-vs\n\n// Scale the model\nuniform float sizeScale;\n\n// Primitive attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\n// Instance attributes\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xy;\nattribute vec3 instanceRotations;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Outputs to fragment shader\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\n\n// yaw(z) pitch(y) roll(x)\nmat3 getRotationMatrix(vec3 rotation) {\n  float sr = sin(rotation.x);\n  float sp = sin(rotation.y);\n  float sw = sin(rotation.z);\n\n  float cr = cos(rotation.x);\n  float cp = cos(rotation.y);\n  float cw = cos(rotation.z);\n\n  return mat3(\n    cw * cp,                  // 0,0\n    sw * cp,                  // 1,0\n    -sp,                      // 2,0\n    -sw * cr + cw * sp * sr,  // 0,1\n    cw * cr + sw * sp * sr,   // 1,1\n    cp * sr,                  // 2,1\n    sw * sr + cw * sp * cr,   // 0,2\n    -cw * sr + sw * sp * cr,  // 1,2\n    cp * cr                   // 2,2\n  );\n}\n\nvoid main(void) {\n  mat3 rotationMatrix = getRotationMatrix(instanceRotations);\n\n  vec3 pos = rotationMatrix * positions;\n  pos = project_scale(pos * sizeScale);\n  // TODO - backward compatibility, remove in next major release\n  if (project_uPixelsPerMeter.y < 0.0) {\n    pos.y = -pos.y;\n  }\n\n  vec4 worldPosition;\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xy, pos, worldPosition);\n\n  // TODO - transform normals\n\n  picking_setPickingColor(instancePickingColors);\n\n  vTexCoord = texCoords;\n  vColor = instanceColors;\n}\n`;\n","export default `\n#define SHADER_NAME mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform vec4 color;\n\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = hasTexture ? texture2D(sampler, vTexCoord) : vColor / 255.;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n`;\n","import { Geometry } from '@luma.gl/core';\n\nexport default class Arrow2DGeometry extends Geometry {\n  constructor(opts = {}) {\n    super(\n      Object.assign({}, opts, {\n        attributes: getArrowAttributes(opts)\n      })\n    );\n  }\n}\n\nfunction getArrowAttributes({ length = 1, headSize = 0.2, tailWidth = 0.05, tailStart = 0.05 }) {\n  const texCoords = [\n    // HEAD\n    0.5,\n    1.0,\n    0,\n    0.5 - headSize / 2,\n    1.0 - headSize,\n    0,\n    0.5 + headSize / 2,\n    1.0 - headSize,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    tailStart,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 - tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0\n  ];\n\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\n\n  // Center and scale\n  const positions = new Array(texCoords.length);\n  for (let i = 0; i < texCoords.length / 3; i++) {\n    const i3 = i * 3;\n    positions[i3 + 0] = (texCoords[i3 + 0] - 0.5) * length;\n    positions[i3 + 1] = (texCoords[i3 + 1] - 0.5) * length;\n    positions[i3 + 2] = 0;\n  }\n  return {\n    positions: new Float32Array(positions),\n    normals: new Float32Array(normals),\n    texCoords: new Float32Array(texCoords)\n  };\n}\n","import { Vector2 } from 'math.gl';\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  let lineLength = 0;\n  for (let i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n  return lineLength;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_DIRECTION = { forward: true, backward: false };\n\nexport default function createPathMarkers({\n  data,\n  getPath = x => x.path,\n  getDirection = x => x.direction,\n  getColor = x => DEFAULT_COLOR,\n  getMarkerPercentages = x => [0.5],\n  projectFlat\n}) {\n  const markers = [];\n\n  for (const object of data) {\n    const path = getPath(object);\n    const direction = getDirection(object) || DEFAULT_DIRECTION;\n    const color = getColor(object);\n\n    const vPoints = path.map(p => new Vector2(p));\n    const vPointsReverse = vPoints.slice(0).reverse();\n\n    // calculate total length\n    const lineLength = getLineLength(vPoints);\n\n    // Ask for where to put markers\n    const percentages = getMarkerPercentages(object, { lineLength });\n\n    // Create the markers\n    for (const percentage of percentages) {\n      if (direction.forward) {\n        const marker = createMarkerAlongPath({\n          path: vPoints,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n\n      if (direction.backward) {\n        const marker = createMarkerAlongPath({\n          path: vPointsReverse,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n    }\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath({ path, percentage, lineLength, color, object, projectFlat }) {\n  const distanceAlong = lineLength * percentage;\n  let currentDistance = 0;\n  let previousDistance = 0;\n  let i = 0;\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n    previousDistance = currentDistance;\n  }\n\n  const vDirection = path[i + 1]\n    .clone()\n    .subtract(path[i])\n    .normalize();\n  const along = distanceAlong - previousDistance;\n  const vCenter = vDirection\n    .clone()\n    .multiply(new Vector2(along, along))\n    .add(path[i]);\n\n  const vDirection2 = new Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n  const angle = (-vDirection2.verticalAngle() * 180) / Math.PI;\n\n  return { position: [vCenter.x, vCenter.y, 0], angle, color, object };\n}\n","import { Vector3, clamp } from 'math.gl';\n\n// Return the closest point on a line segment\nexport function getClosestPointOnLine({ p, p1, p2, clampToLine = true }) {\n  const lineVector = new Vector3(p2).subtract(p1);\n  const pointVector = new Vector3(p).subtract(p1);\n  let dotProduct = lineVector.dot(pointVector);\n  if (clampToLine) {\n    dotProduct = clamp(dotProduct, 0, 1);\n  }\n  return lineVector.lerp(dotProduct);\n}\n\n// Return the closest point on a line segment\nexport function getClosestPointOnPolyline({ p, points }) {\n  p = new Vector3(p);\n  let pClosest = null;\n  let distanceSquared = Infinity;\n  let index = -1;\n  for (let i = 0; i < points.length - 1; ++i) {\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const pClosestOnLine = getClosestPointOnLine({ p, p1, p2 });\n    const distanceToLineSquared = p.distanceSquared(pClosestOnLine);\n    if (distanceToLineSquared < distanceSquared) {\n      distanceSquared = distanceToLineSquared;\n      pClosest = pClosestOnLine;\n      index = i;\n    }\n  }\n  return {\n    point: pClosest,\n    index,\n    p1: points[index],\n    p2: points[index + 1],\n    distanceSquared,\n    distance: Math.sqrt(distanceSquared)\n  };\n}\n","import { CompositeLayer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\nimport PathOutlineLayer from '../path-outline-layer/path-outline-layer';\nimport MeshLayer from '../mesh-layer/mesh-layer';\nimport Arrow2DGeometry from './arrow-2d-geometry';\n\nimport createPathMarkers from './create-path-markers';\nimport { getClosestPointOnPolyline } from './polyline';\n\nconst DISTANCE_FOR_MULTI_ARROWS = 0.1;\nconst ARROW_HEAD_SIZE = 0.2;\nconst ARROW_TAIL_WIDTH = 0.05;\n// const ARROW_CENTER_ADJUST = -0.8;\n\nconst DEFAULT_MARKER_LAYER = MeshLayer;\n\nconst DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH })\n};\n\nconst defaultProps = Object.assign({}, PathOutlineLayer.defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n\n  sizeScale: 100,\n  fp64: false,\n\n  hightlightIndex: -1,\n  highlightPoint: null,\n\n  getPath: x => x.path,\n  getColor: x => x.color,\n  getMarkerColor: x => [0, 0, 0, 255],\n  getDirection: x => x.direction,\n  getMarkerPercentages: (object, { lineLength }) =>\n    lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5]\n});\n\nexport default class PathMarkerLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      markers: [],\n      mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n      closestPoint: null\n    };\n  }\n\n  projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n    if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n      const [dx, dy] = viewport.metersToLngLatDelta(xyz);\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    } else if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n      const [dx, dy] = xyz;\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    }\n\n    return viewport.projectFlat(xyz);\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n      const {\n        data,\n        getPath,\n        getDirection,\n        getMarkerColor,\n        getMarkerPercentages,\n        coordinateSystem,\n        coordinateOrigin\n      } = this.props;\n      const { viewport } = this.context;\n      const projectFlat = o => this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n      this.state.markers = createPathMarkers({\n        data,\n        getPath,\n        getDirection,\n        getColor: getMarkerColor,\n        getMarkerPercentages,\n        projectFlat\n      });\n      this._recalculateClosestPoint();\n    }\n    if (changeFlags.propsChanged) {\n      if (props.point !== oldProps.point) {\n        this._recalculateClosestPoint();\n      }\n    }\n  }\n\n  _recalculateClosestPoint() {\n    const { highlightPoint, highlightIndex } = this.props;\n    if (highlightPoint && highlightIndex >= 0) {\n      const object = this.props.data[highlightIndex];\n      const points = this.props.getPath(object);\n      const { point } = getClosestPointOnPolyline({ points, p: highlightPoint });\n      this.state.closestPoints = [\n        {\n          position: point\n        }\n      ];\n    } else {\n      this.state.closestPoints = [];\n    }\n  }\n\n  getPickingInfo({ info }) {\n    return Object.assign(info, {\n      // override object with picked feature\n      object: (info.object && info.object.path) || info.object\n    });\n  }\n\n  renderLayers() {\n    return [\n      new PathOutlineLayer(\n        this.props,\n        this.getSubLayerProps({\n          id: 'paths',\n          // Note: data has to be passed explicitly like this to avoid being empty\n          data: this.props.data\n        })\n      ),\n      new this.props.MarkerLayer(\n        this.getSubLayerProps(\n          Object.assign({}, this.props.markerLayerProps, {\n            id: 'markers',\n            data: this.state.markers,\n            sizeScale: this.props.sizeScale,\n            fp64: this.props.fp64,\n            pickable: false,\n            parameters: {\n              blend: false,\n              depthTest: false\n            }\n          })\n        )\n      ),\n      this.state.closestPoints &&\n        new ScatterplotLayer({\n          id: `${this.props.id}-highlight`,\n          data: this.state.closestPoints,\n          fp64: this.props.fp64\n        })\n    ];\n  }\n}\n\nPathMarkerLayer.layerName = 'PathMarkerLayer';\nPathMarkerLayer.defaultProps = defaultProps;\n","// @flow\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\n\nexport default class JunctionScatterplotLayer extends CompositeLayer {\n  static layerName = 'JunctionScatterplotLayer';\n  static defaultProps = {\n    ...ScatterplotLayer.defaultProps,\n    getFillColor: d => [0, 0, 0, 255],\n    getStrokeColor: d => [255, 255, 255, 255],\n    getInnerRadius: d => 1\n  };\n\n  renderLayers() {\n    const { id, getFillColor, getStrokeColor, getInnerRadius, updateTriggers } = this.props;\n\n    // data needs to be passed explicitly after deck.gl 5.3\n    return [\n      // the full circles\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-full`,\n        data: this.props.data,\n        getColor: getStrokeColor,\n        updateTriggers: {\n          ...updateTriggers,\n          getColor: updateTriggers.getStrokeColor\n        }\n      }),\n      // the inner part\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-inner`,\n        data: this.props.data,\n        getColor: getFillColor,\n        getRadius: getInnerRadius,\n        pickable: false,\n        updateTriggers: {\n          ...updateTriggers,\n          getColor: updateTriggers.getFillColor,\n          getRadius: updateTriggers.getInnerRadius\n        }\n      })\n    ];\n  }\n}\n","// @flow\n\nimport type { FeatureCollection, Feature, Position } from '@nebula.gl/edit-modes';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../event-types.js';\nimport { ModeHandler, type EditAction, type EditHandle } from './mode-handler.js';\n\nexport class CompositeModeHandler extends ModeHandler {\n  handlers: Array<ModeHandler>;\n  options: Object;\n\n  constructor(handlers: Array<ModeHandler>, options: Object = {}) {\n    super();\n    this.handlers = handlers;\n    this.options = options;\n  }\n\n  _coalesce<T>(callback: ModeHandler => T, resultEval: ?(T) => boolean = null): T {\n    let result: T;\n\n    for (let i = 0; i < this.handlers.length; i++) {\n      result = callback(this.handlers[i]);\n      if (resultEval ? resultEval(result) : result) {\n        break;\n      }\n    }\n\n    return (result: any);\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.handlers.forEach(handler => handler.setFeatureCollection(featureCollection));\n  }\n\n  setModeConfig(modeConfig: any): void {\n    this.handlers.forEach(handler => handler.setModeConfig(modeConfig));\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    this.handlers.forEach(handler => handler.setSelectedFeatureIndexes(indexes));\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleClick(event));\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    return this._coalesce(\n      handler => handler.handlePointerMove(event),\n      result => result && Boolean(result.editAction)\n    );\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleStartDragging(event));\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleStopDragging(event));\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._coalesce(handler => handler.getTentativeFeature());\n  }\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    // TODO: Combine the handles *BUT* make sure if none of the results have\n    // changed to return the same object so that \"editHandles !== this.state.editHandles\"\n    // in editable-geojson-layer works.\n    return this._coalesce(\n      handler => handler.getEditHandles(picks, groundCoords),\n      handles => Array.isArray(handles) && handles.length > 0\n    );\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return this._coalesce(handler => handler.getCursor({ isDragging }));\n  }\n}\n","// @flow\nimport { PathMarkerLayer } from '@nebula.gl/layers';\nimport { MAX } from '@luma.gl/constants';\n\nimport { ArrowStyles, DEFAULT_STYLE, MAX_ARROWS } from '../style';\nimport NebulaLayer from '../nebula-layer';\nimport { toDeckColor } from '../utils';\nimport DeckCache from '../deck-renderer/deck-cache';\n\nconst NEBULA_TO_DECK_DIRECTIONS = {\n  [ArrowStyles.NONE]: { forward: false, backward: false },\n  [ArrowStyles.FORWARD]: { forward: true, backward: false },\n  [ArrowStyles.BACKWARD]: { forward: false, backward: true },\n  [ArrowStyles.BOTH]: { forward: true, backward: true }\n};\n\nexport default class SegmentsLayer extends NebulaLayer {\n  deckCache: DeckCache<*, *>;\n  noBlend: boolean;\n  highlightColor: [number, number, number, number];\n  arrowSize: number;\n  rounded: boolean;\n  dashed: boolean;\n  markerLayerProps: ?Object;\n\n  constructor(config: Object) {\n    super(config);\n    this.deckCache = new DeckCache(config.getData, data => config.toNebulaFeature(data));\n    this.enableSelection = true;\n    const {\n      enablePicking = true,\n      noBlend = false,\n      rounded = true,\n      dashed = false,\n      markerLayerProps = null\n    } = config;\n    Object.assign(this, { enablePicking, noBlend, rounded, dashed, markerLayerProps });\n  }\n\n  getMouseOverSegment(): any {\n    // TODO: remove references\n    return null;\n  }\n\n  _calcMarkerPercentages(nf: Object): number[] {\n    const { arrowPercentages } = nf.style;\n    if (arrowPercentages) {\n      return arrowPercentages;\n    }\n\n    const arrowStyle = nf.style.arrowStyle || DEFAULT_STYLE.arrowStyle;\n    if (arrowStyle === ArrowStyles.NONE) return [];\n\n    const arrowCount = Math.min(nf.style.arrowCount || DEFAULT_STYLE.arrowCount, MAX_ARROWS);\n    return [[0.5], [0.33, 0.66], [0.25, 0.5, 0.75]][arrowCount - 1];\n  }\n\n  _getHighlightedObjectIndex({ nebula }: Object): number {\n    const { deckglMouseOverInfo } = nebula;\n    if (deckglMouseOverInfo) {\n      const { originalLayer, index } = deckglMouseOverInfo;\n      if (originalLayer === this) {\n        return index;\n      }\n    }\n\n    // no object\n    return -1;\n  }\n\n  render({ nebula }: Object) {\n    const defaultColor = [0x0, 0x0, 0x0, 0xff];\n    const { objects, updateTrigger } = this.deckCache;\n\n    return new PathMarkerLayer({\n      id: `segments-${this.id}`,\n      data: objects,\n      opacity: 1,\n      fp64: false,\n      rounded: this.rounded,\n      pickable: true,\n      sizeScale: this.arrowSize || 6,\n      parameters: {\n        depthTest: false,\n        blend: !this.noBlend,\n        blendEquation: MAX\n      },\n      getPath: nf => nf.geoJson.geometry.coordinates,\n      getColor: nf => toDeckColor(nf.style.lineColor, defaultColor),\n      getWidth: nf => nf.style.lineWidthMeters || 1,\n      getZLevel: nf => nf.style.zLevel * 255,\n      getDirection: nf => NEBULA_TO_DECK_DIRECTIONS[nf.style.arrowStyle],\n      getMarkerColor: nf => toDeckColor(nf.style.arrowColor, defaultColor),\n      getMarkerPercentages: this._calcMarkerPercentages,\n      updateTriggers: { all: updateTrigger },\n\n      highlightedObjectIndex: this._getHighlightedObjectIndex({ nebula }),\n      highlightColor: toDeckColor(this.highlightColor),\n\n      dashJustified: this.dashed,\n      getDashArray: this.dashed ? nf => nf.style.dashArray : null,\n      markerLayerProps:\n        this.markerLayerProps || (PathMarkerLayer: Object).defaultProps.markerLayerProps,\n\n      nebulaLayer: this\n    });\n  }\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst styles = {\n  toolboxItem: {\n    flexBasis: '50%'\n  }\n};\n\nexport const Toolbox = styled.div`\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  color: #f0f0f0;\n  padding: 0;\n  width: 230px;\n  height: 100%;\n  font-family: Arial, Helvetica, sans-serif;\n  font-size: 16px;\n  overflow: scroll;\n  z-index: 999;\n`;\n\nexport const ToolboxRow = props => <div>{props.children}</div>;\nexport const ToolboxControl = props => <div style={styles.toolboxItem}>{props.children}</div>;\n\nexport const ToolboxTitle = styled.div`\n  background: rgba(39, 45, 59, 0.8);\n  font-size: 16px;\n  height: 44px;\n  display: flex;\n  align-items: center;\n  padding: 0px 8px;\n`;\n\nconst buttonBackground = props =>\n  props.selected ? 'rgba(30, 84, 183, 0.8)' : 'rgba(23, 28, 41, 0.8)';\n\nexport const ToolboxButton = styled.button`\n  display: block;\n  width: 100%;\n  border: none;\n  color: #f0f0f0;\n  background: ${buttonBackground};\n  text-align: left;\n  text-transform: capitalize;\n  font-size: 16px;\n  outline: none;\n  height: 44px;\n  cursor: pointer;\n\n  &:hover {\n    background: #276ef1;\n  }\n`;\n\nconst ToolboxCheckboxContainer = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  border: none;\n  color: #f0f0f0;\n  background: ${buttonBackground};\n  text-align: left;\n  text-transform: capitalize;\n  font-size: 16px;\n  outline: none;\n  height: 44px;\n  cursor: pointer;\n\n  &:hover {\n    background: #276ef1;\n  }\n`;\n\nexport const ToolboxCheckbox = props => (\n  <label>\n    <ToolboxCheckboxContainer>\n      <input {...{ ...props, children: null }} />\n      {props.children}\n    </ToolboxCheckboxContainer>\n  </label>\n);\n","// @flow\n/* eslint-env browser */\n\nimport window from 'global/window';\nimport React, { Component } from 'react';\nimport DeckGL from '@deck.gl/react';\nimport { MapView, MapController } from '@deck.gl/core';\nimport { StaticMap } from 'react-map-gl';\nimport GL from '@luma.gl/constants';\nimport circle from '@turf/circle';\nimport WebMercatorViewport from 'viewport-mercator-project';\n\nimport {\n  EditableGeoJsonLayer,\n  EditableGeoJsonLayer_EDIT_MODE_POC as EditableGeoJsonLayerEditModePoc,\n  SelectionLayer,\n  CompositeModeHandler,\n  ModifyHandler,\n  ElevationHandler,\n  DrawLineStringHandler,\n  ElevatedEditHandleLayer,\n  SELECTION_TYPE\n} from 'nebula.gl';\n\nimport sampleGeoJson from '../data/sample-geojson.json';\n\nimport iconSheet from '../data/edit-handles.png';\n\nimport {\n  Toolbox,\n  ToolboxControl,\n  ToolboxTitle,\n  ToolboxRow,\n  ToolboxButton,\n  ToolboxCheckbox\n} from './toolbox';\n\n// TODO: once we refactor EditableGeoJsonLayer to use new EditMode interface, this can go away\nlet EditableGeoJsonLayerImpl = EditableGeoJsonLayer;\nif (\n  window.location &&\n  window.location.search &&\n  window.location.search.indexOf('useEditModePoc') !== -1\n) {\n  EditableGeoJsonLayerImpl = EditableGeoJsonLayerEditModePoc;\n}\n\nconst styles = {\n  mapContainer: {\n    alignItems: 'stretch',\n    display: 'flex',\n    height: '100vh'\n  },\n  checkbox: {\n    margin: 10\n  }\n};\n\nconst initialViewport = {\n  bearing: 0,\n  height: 0,\n  latitude: 37.76,\n  longitude: -122.44,\n  pitch: 0,\n  width: 0,\n  zoom: 11\n};\n\nconst ALL_MODES = [\n  { category: 'View', modes: ['view'] },\n  {\n    category: 'Alter',\n    modes: ['modify', 'elevation', 'translate', 'rotate', 'scale', 'duplicate', 'extrude', 'split']\n  },\n  {\n    category: 'Draw',\n    modes: [\n      'drawPoint',\n      'drawLineString',\n      'drawPolygon',\n      'draw90DegreePolygon',\n      'drawRectangle',\n      'drawRectangleUsing3Points',\n      'drawCircleFromCenter',\n      'drawCircleByBoundingBox',\n      'drawEllipseByBoundingBox',\n      'drawEllipseUsing3Points'\n    ]\n  },\n  {\n    category: 'Composite',\n    modes: ['drawLineString+modify']\n  }\n];\n\nconst POLYGON_DRAWING_MODES = [\n  'drawPolygon',\n  'draw90DegreePolygon',\n  'drawRectangle',\n  'drawRectangleUsing3Points',\n  'drawCircleFromCenter',\n  'drawCircleByBoundingBox',\n  'drawEllipseByBoundingBox',\n  'drawEllipseUsing3Points'\n];\n\nconst modeHandlers = Object.assign(\n  {\n    'drawLineString+modify': new CompositeModeHandler([\n      new DrawLineStringHandler(),\n      new ModifyHandler()\n    ])\n  },\n  EditableGeoJsonLayerImpl.defaultProps.modeHandlers\n);\n\nfunction hex2rgb(hex: string) {\n  const value = parseInt(hex, 16);\n  return [16, 8, 0].map(shift => ((value >> shift) & 0xff) / 255);\n}\n\nconst FEATURE_COLORS = [\n  '00AEE4',\n  'DAF0E3',\n  '9BCC32',\n  '07A35A',\n  'F7DF90',\n  'EA376C',\n  '6A126A',\n  'FCB09B',\n  'B0592D',\n  'C1B5E3',\n  '9C805B',\n  'CCDFE5'\n].map(hex2rgb);\n\nfunction getEditHandleColor(handle: Object) {\n  switch (handle.type) {\n    case 'existing':\n      return [0xff, 0x80, 0x00, 0xff];\n    case 'snap':\n      return [0x7c, 0x00, 0xc0, 0xff];\n    case 'intermediate':\n    default:\n      return [0x0, 0x0, 0x0, 0x80];\n  }\n}\n\nexport default class Example extends Component<\n  {},\n  {\n    viewport: Object,\n    testFeatures: any,\n    mode: string,\n    modeConfig: any,\n    pointsRemovable: boolean,\n    selectedFeatureIndexes: number[],\n    editHandleType: string,\n    selectionTool: ?string,\n    showGeoJson: boolean,\n    featureMenu: ?{\n      index: number,\n      x: number,\n      y: number\n    }\n  }\n> {\n  constructor() {\n    super();\n\n    this.state = {\n      viewport: initialViewport,\n      testFeatures: sampleGeoJson,\n      mode: 'drawPolygon',\n      modeConfig: null,\n      pointsRemovable: true,\n      selectedFeatureIndexes: [],\n      editHandleType: 'point',\n      selectionTool: null,\n      showGeoJson: false,\n      featureMenu: null\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this._resize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize);\n  }\n\n  _onChangeViewport = (viewport: Object) => {\n    this.setState({\n      viewport: { ...this.state.viewport, ...viewport }\n    });\n  };\n\n  _onLayerClick = (info: any) => {\n    console.log('onLayerClick', info); // eslint-disable-line\n\n    if (this.state.mode !== 'view' || this.state.selectionTool) {\n      // don't change selection while editing\n      return;\n    }\n\n    if (info) {\n      console.log(`select editing feature ${info.index}`); // eslint-disable-line\n      // a feature was clicked\n      // TODO: once https://github.com/uber/deck.gl/pull/1918 lands, this will work since it'll work with Multi* geometry types\n      this.setState({ selectedFeatureIndexes: [info.index] });\n    } else {\n      console.log('deselect editing feature'); // eslint-disable-line\n      // open space was clicked, so stop editing\n      this.setState({ selectedFeatureIndexes: [] });\n    }\n  };\n\n  _resize = () => {\n    this.forceUpdate();\n  };\n\n  _loadSample = (type: string) => {\n    if (type === 'mixed') {\n      this.setState({\n        testFeatures: sampleGeoJson,\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'complex') {\n      this.setState({\n        testFeatures: {\n          type: 'FeatureCollection',\n          features: [\n            circle([-122.45, 37.81], 4, { steps: 5000 }),\n            circle([-122.33, 37.81], 4, { steps: 5000 }),\n            circle([-122.45, 37.73], 4, { steps: 5000 }),\n            circle([-122.33, 37.73], 4, { steps: 5000 })\n          ]\n        },\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'blank') {\n      this.setState({\n        testFeatures: {\n          type: 'FeatureCollection',\n          features: []\n        }\n      });\n    } else if (type === 'file') {\n      const el = document.createElement('input');\n      el.type = 'file';\n      el.onchange = e => {\n        if (e.target.files && e.target.files[0]) {\n          const reader = new FileReader();\n          reader.onload = ({ target }) => {\n            this._parseStringJson(target.result);\n          };\n          reader.readAsText(e.target.files[0]);\n        }\n      };\n      el.click();\n    }\n  };\n\n  _copy = () => {\n    if (navigator && navigator.clipboard) {\n      navigator.clipboard.writeText(JSON.stringify(this.state.testFeatures));\n    } else {\n      this._error('No navigator.clipboard');\n    }\n  };\n\n  _paste = () => {\n    if (navigator && navigator.clipboard) {\n      navigator.clipboard.readText().then(\n        value => {\n          this._parseStringJson(value);\n        },\n        reason => {\n          this._error(reason);\n        }\n      );\n    } else {\n      this._error('No navigator.clipboard');\n    }\n  };\n\n  _download = () => {\n    const blob = new Blob([JSON.stringify(this.state.testFeatures)], { type: 'octet/stream' });\n    const a = document.createElement('a');\n    a.href = URL.createObjectURL(blob);\n    a.download = 'nebula.geojson';\n    a.click();\n  };\n\n  _parseStringJson = (json: string) => {\n    let testFeatures = null;\n    try {\n      testFeatures = JSON.parse(json);\n      if (Array.isArray(testFeatures)) {\n        testFeatures = {\n          type: 'FeatureCollection',\n          features: testFeatures\n        };\n      }\n      // eslint-disable-next-line\n      console.log('Loaded JSON:', testFeatures);\n      this.setState({ testFeatures });\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  _error = (err: any) => {\n    // eslint-disable-next-line\n    alert(err);\n  };\n\n  _getHtmlColorForFeature(index: number, selected: boolean) {\n    const length = FEATURE_COLORS.length;\n    const color = FEATURE_COLORS[index % length].map(c => c * 255).join(',');\n    const alpha = selected ? 1.0 : 0.7;\n\n    return `rgba(${color}, ${alpha})`;\n  }\n\n  _getDeckColorForFeature(index: number, bright: number, alpha: number) {\n    const length = FEATURE_COLORS.length;\n    const color = FEATURE_COLORS[index % length].map(c => c * bright * 255);\n\n    return [...color, alpha * 255];\n  }\n\n  _renderSelectFeatureCheckbox(index: number, featureType: string) {\n    const { selectedFeatureIndexes } = this.state;\n    return (\n      <div key={index}>\n        <ToolboxCheckbox\n          style={styles.checkbox}\n          type=\"checkbox\"\n          checked={selectedFeatureIndexes.includes(index)}\n          onChange={() => {\n            if (selectedFeatureIndexes.includes(index)) {\n              this.setState({\n                selectedFeatureIndexes: selectedFeatureIndexes.filter(e => e !== index)\n              });\n            } else {\n              this.setState({\n                selectedFeatureIndexes: [...selectedFeatureIndexes, index]\n              });\n            }\n          }}\n        >\n          <span\n            style={{\n              color: this._getHtmlColorForFeature(index, selectedFeatureIndexes.includes(index))\n            }}\n          >\n            {index}\n            {': '}\n            {featureType}\n          </span>\n          <a\n            style={{ position: 'absolute', right: 12 }}\n            onClick={e => {\n              e.preventDefault();\n              e.stopPropagation();\n              this.setState({\n                selectedFeatureIndexes: [index],\n                featureMenu: { index, x: e.clientX, y: e.clientY }\n              });\n            }}\n          >\n            &gt;&gt;\n          </a>\n        </ToolboxCheckbox>\n      </div>\n    );\n  }\n\n  _renderSelectFeatureCheckboxes() {\n    const {\n      testFeatures: { features }\n    } = this.state;\n    const checkboxes = [];\n    for (let i = 0; i < features.length; ++i) {\n      checkboxes.push(this._renderSelectFeatureCheckbox(i, features[i].geometry.type));\n    }\n    return checkboxes;\n  }\n\n  _renderBooleanOperationControls() {\n    const operations = ['union', 'difference', 'intersection'];\n    return (\n      <ToolboxRow key=\"booleanOperations\">\n        <ToolboxTitle>\n          Boolean operation<br />(requires single selection)\n        </ToolboxTitle>\n        <ToolboxControl>\n          {operations.map(operation => (\n            <ToolboxButton\n              key={operation}\n              selected={\n                this.state.modeConfig && this.state.modeConfig.booleanOperation === operation\n              }\n              onClick={() => {\n                if (this.state.modeConfig && this.state.modeConfig.booleanOperation === operation) {\n                  this.setState({ modeConfig: null });\n                } else {\n                  this.setState({ modeConfig: { booleanOperation: operation } });\n                }\n              }}\n            >\n              {operation}\n            </ToolboxButton>\n          ))}\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderDrawLineStringModeControls() {\n    return (\n      <ToolboxRow key=\"drawLineString\">\n        <ToolboxTitle>Draw LineString At Front</ToolboxTitle>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.drawAtFront)}\n            onChange={event =>\n              this.setState({\n                modeConfig: {\n                  drawAtFront: Boolean(event.target.checked)\n                }\n              })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderModifyModeControls() {\n    return (\n      <ToolboxRow key=\"modify\">\n        <ToolboxTitle>Allow removing points</ToolboxTitle>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={this.state.pointsRemovable}\n            onChange={() => this.setState({ pointsRemovable: !this.state.pointsRemovable })}\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSplitModeControls() {\n    return (\n      <ToolboxRow key=\"split\">\n        <ToolboxTitle>Constrain to 90&deg;</ToolboxTitle>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.lock90Degree)}\n            onChange={event =>\n              this.setState({ modeConfig: { lock90Degree: Boolean(event.target.checked) } })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSnappingControls() {\n    return (\n      <div key=\"snap\">\n        <ToolboxRow>\n          <ToolboxTitle>Enable snapping</ToolboxTitle>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={Boolean(this.state.modeConfig && this.state.modeConfig.enableSnapping)}\n              onChange={event => {\n                const modeConfig = {\n                  ...this.state.modeConfig,\n                  enableSnapping: Boolean(event.target.checked)\n                };\n                this.setState({ modeConfig });\n              }}\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n      </div>\n    );\n  }\n\n  _renderModeConfigControls() {\n    const controls = [];\n\n    if (POLYGON_DRAWING_MODES.indexOf(this.state.mode) > -1) {\n      controls.push(this._renderBooleanOperationControls());\n    }\n    if (this.state.mode === 'drawLineString') {\n      controls.push(this._renderDrawLineStringModeControls());\n    }\n    if (this.state.mode === 'modify') {\n      controls.push(this._renderModifyModeControls());\n    }\n    if (this.state.mode === 'split') {\n      controls.push(this._renderSplitModeControls());\n    }\n    if (this.state.mode === 'translate') {\n      controls.push(this._renderSnappingControls());\n    }\n\n    return controls;\n  }\n\n  _renderToolBox() {\n    return (\n      <Toolbox>\n        {ALL_MODES.map(category => (\n          <ToolboxRow key={category.category}>\n            <ToolboxTitle>{category.category} Modes</ToolboxTitle>\n            {category.modes.map(mode => (\n              <ToolboxButton\n                key={mode}\n                selected={this.state.mode === mode}\n                onClick={() => {\n                  this.setState({ mode, modeConfig: {}, selectionTool: null });\n                }}\n              >\n                {mode}\n              </ToolboxButton>\n            ))}\n          </ToolboxRow>\n        ))}\n        {this._renderModeConfigControls()}\n        {this.state.showGeoJson && (\n          <React.Fragment>\n            <ToolboxTitle>GeoJSON</ToolboxTitle>\n            <ToolboxButton onClick={() => this.setState({ showGeoJson: !this.state.showGeoJson })}>\n              hide &#9650;\n            </ToolboxButton>\n            <ToolboxControl>\n              <textarea\n                id=\"geo-json-text\"\n                rows={5}\n                style={{ width: '100%' }}\n                value={JSON.stringify(this.state.testFeatures)}\n                onChange={event => this.setState({ testFeatures: JSON.parse(event.target.value) })}\n              />\n            </ToolboxControl>\n          </React.Fragment>\n        )}\n        {!this.state.showGeoJson && (\n          <React.Fragment>\n            <ToolboxTitle>GeoJSON</ToolboxTitle>\n            <ToolboxButton onClick={() => this.setState({ showGeoJson: !this.state.showGeoJson })}>\n              show &#9660;\n            </ToolboxButton>\n          </React.Fragment>\n        )}\n        <ToolboxButton onClick={() => this._copy()}>Copy</ToolboxButton>\n        <ToolboxButton onClick={() => this._paste()}>Paste</ToolboxButton>\n        <ToolboxButton onClick={() => this._download()}>Download</ToolboxButton>\n        <ToolboxRow>\n          <ToolboxTitle>Load data</ToolboxTitle>\n          <ToolboxControl>\n            <ToolboxButton onClick={() => this._loadSample('mixed')}>Mixed Sample</ToolboxButton>\n            <ToolboxButton onClick={() => this._loadSample('complex')}>\n              Complex Sample\n            </ToolboxButton>\n            <ToolboxButton onClick={() => this._loadSample('blank')}>Blank</ToolboxButton>\n            <ToolboxButton onClick={() => this._loadSample('file')}>Open file...</ToolboxButton>\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxTitle>Options</ToolboxTitle>\n          <ToolboxControl>\n            <ToolboxCheckbox\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'icon'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'icon' ? 'point' : 'icon'\n                })\n              }\n            >\n              Use Icons\n            </ToolboxCheckbox>\n          </ToolboxControl>\n\n          <ToolboxControl>\n            <ToolboxCheckbox\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'elevated'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'elevated' ? 'point' : 'elevated'\n                })\n              }\n            >\n              Use ElevatedEditHandleLayer\n            </ToolboxCheckbox>\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxTitle>Select Features</ToolboxTitle>\n          <ToolboxControl>\n            <ToolboxButton\n              onClick={() =>\n                this.setState({ selectedFeatureIndexes: [], selectionTool: SELECTION_TYPE.NONE })\n              }\n            >\n              Clear Selection\n            </ToolboxButton>\n            <ToolboxButton\n              onClick={() =>\n                this.setState({ mode: 'view', selectionTool: SELECTION_TYPE.RECTANGLE })\n              }\n            >\n              Rect Select\n            </ToolboxButton>\n            <ToolboxButton\n              onClick={() => this.setState({ mode: 'view', selectionTool: SELECTION_TYPE.POLYGON })}\n            >\n              Lasso Select\n            </ToolboxButton>\n          </ToolboxControl>\n        </ToolboxRow>\n        <ToolboxTitle>Features</ToolboxTitle>\n        <ToolboxRow>{this._renderSelectFeatureCheckboxes()}</ToolboxRow>\n      </Toolbox>\n    );\n  }\n\n  renderStaticMap(viewport: Object) {\n    return <StaticMap {...viewport} mapStyle={'mapbox://styles/mapbox/dark-v10'} />;\n  }\n\n  _featureMenuClick(action: string) {\n    const { index } = this.state.featureMenu || {};\n    let testFeatures = this.state.testFeatures;\n\n    if (action === 'delete') {\n      const features = [...testFeatures.features];\n      features.splice(index, 1);\n      testFeatures = Object.assign({}, testFeatures, {\n        features\n      });\n    } else if (action === 'split') {\n      // TODO\n    } else if (action === 'info') {\n      // eslint-disable-next-line\n      console.log(testFeatures.features[index]);\n    }\n\n    this.setState({ featureMenu: null, testFeatures });\n  }\n\n  _renderFeatureMenu({ x, y, index }: Object) {\n    return (\n      <div style={{ position: 'fixed', top: y - 40, left: x + 20 }}>\n        <ToolboxButton onClick={() => this._featureMenuClick('delete')}>Delete</ToolboxButton>\n        <ToolboxButton onClick={() => this._featureMenuClick('split')}>Split</ToolboxButton>\n        <ToolboxButton onClick={() => this._featureMenuClick('info')}>Info</ToolboxButton>\n        <ToolboxButton onClick={() => this._featureMenuClick('')}>Close</ToolboxButton>\n      </div>\n    );\n  }\n\n  customizeLayers(layers: Object[]) {}\n\n  render() {\n    const { testFeatures, selectedFeatureIndexes, mode } = this.state;\n    let { modeConfig } = this.state;\n\n    const viewport = {\n      ...this.state.viewport,\n      height: window.innerHeight,\n      width: window.innerWidth\n    };\n\n    if (mode === 'elevation') {\n      modeConfig = {\n        ...modeConfig,\n        viewport: new WebMercatorViewport(viewport),\n        calculateElevationChange: opts =>\n          ElevationHandler.calculateElevationChangeWithViewport(viewport, opts)\n      };\n    } else if (mode === 'modify') {\n      modeConfig = { ...modeConfig, viewport: new WebMercatorViewport(viewport) };\n    } else if (mode === 'translate' && modeConfig && modeConfig.enableSnapping) {\n      // Snapping can be accomplished to features that aren't rendered in the same layer\n      modeConfig = {\n        ...modeConfig,\n        additionalSnapTargets: [\n          {\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'Polygon',\n              coordinates: [\n                [\n                  [-122.52235, 37.734008],\n                  [-122.52217, 37.712706],\n                  [-122.49436, 37.711979],\n                  [-122.49725, 37.734306],\n                  [-122.52235, 37.734008]\n                ]\n              ]\n            }\n          }\n        ]\n      };\n    }\n\n    const editableGeoJsonLayer = new EditableGeoJsonLayerImpl({\n      id: 'geojson',\n      data: testFeatures,\n      selectedFeatureIndexes,\n      modeHandlers,\n      mode,\n      modeConfig,\n      autoHighlight: false,\n\n      // Editing callbacks\n      onEdit: ({ updatedData, editType, featureIndexes, editContext }) => {\n        let updatedSelectedFeatureIndexes = this.state.selectedFeatureIndexes;\n        if (\n          !['movePosition', 'extruding', 'rotating', 'translating', 'scaling'].includes(editType)\n        ) {\n          // Don't log edits that happen as the pointer moves since they're really chatty\n          // eslint-disable-next-line\n          console.log('onEdit', editType, editContext);\n        }\n        if (editType === 'removePosition' && !this.state.pointsRemovable) {\n          // This is a simple example of custom handling of edits\n          // reject the edit\n          return;\n        }\n        if (editType === 'addFeature' && mode !== 'duplicate') {\n          // TODO: once we refactor EditableGeoJsonLayer to use new EditMode interface, this check can go away\n          featureIndexes = featureIndexes || editContext.featureIndexes;\n          // Add the new feature to the selection\n          updatedSelectedFeatureIndexes = [...this.state.selectedFeatureIndexes, ...featureIndexes];\n        }\n        this.setState({\n          testFeatures: updatedData,\n          selectedFeatureIndexes: updatedSelectedFeatureIndexes\n        });\n      },\n\n      // test using icons for edit handles\n      editHandleType:\n        this.state.editHandleType === 'elevated'\n          ? ElevatedEditHandleLayer\n          : this.state.editHandleType,\n      editHandleIconAtlas: iconSheet,\n      editHandleIconMapping: {\n        intermediate: {\n          x: 0,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        },\n        existing: {\n          x: 58,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        }\n      },\n      getEditHandleIcon: d => d.type,\n      getEditHandleIconSize: 40,\n      getEditHandleIconColor: getEditHandleColor,\n\n      // Specify the same GeoJsonLayer props\n      lineWidthMinPixels: 2,\n      pointRadiusMinPixels: 5,\n      getLineDashArray: () => [0, 0],\n\n      // Accessors receive an isSelected argument\n      getFillColor: (feature, isSelected) => {\n        const index = testFeatures.features.indexOf(feature);\n        return isSelected\n          ? this._getDeckColorForFeature(index, 1.0, 0.5)\n          : this._getDeckColorForFeature(index, 0.5, 0.5);\n      },\n      getLineColor: (feature, isSelected) => {\n        const index = testFeatures.features.indexOf(feature);\n        return isSelected\n          ? this._getDeckColorForFeature(index, 1.0, 1.0)\n          : this._getDeckColorForFeature(index, 0.5, 1.0);\n      },\n\n      // Can customize editing points props\n      getEditHandlePointColor: getEditHandleColor,\n      editHandlePointRadiusScale: 2,\n\n      // customize tentative feature style\n      getTentativeLineDashArray: () => [7, 4],\n      getTentativeLineColor: () => [0x8f, 0x8f, 0x8f, 0xff],\n\n      parameters: {\n        depthTest: true,\n        depthMask: false,\n\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA]\n      }\n    });\n\n    const layers = [editableGeoJsonLayer];\n\n    if (this.state.selectionTool) {\n      layers.push(\n        new SelectionLayer({\n          id: 'selection',\n          selectionType: this.state.selectionTool,\n          onSelect: ({ pickingInfos }) => {\n            this.setState({ selectedFeatureIndexes: pickingInfos.map(pi => pi.index) });\n          },\n          layerIds: ['geojson'],\n\n          getTentativeFillColor: () => [255, 0, 255, 100],\n          getTentativeLineColor: () => [0, 0, 255, 255],\n          getTentativeLineDashArray: () => [0, 0],\n          lineWidthMinPixels: 3\n        })\n      );\n    }\n\n    this.customizeLayers(layers);\n\n    return (\n      <div style={styles.mapContainer}>\n        <link href=\"https://api.mapbox.com/mapbox-gl-js/v0.44.0/mapbox-gl.css\" rel=\"stylesheet\" />\n        <DeckGL\n          viewState={viewport}\n          getCursor={editableGeoJsonLayer.getCursor.bind(editableGeoJsonLayer)}\n          layers={layers}\n          views={\n            new MapView({\n              id: 'basemap',\n              controller: {\n                type: MapController,\n                doubleClickZoom: this.state.mode === 'view' && !this.state.selectionTool\n              }\n            })\n          }\n          onClick={this._onLayerClick}\n          onViewStateChange={({ viewState }) => this.setState({ viewport: viewState })}\n        >\n          {this.renderStaticMap(viewport)}\n        </DeckGL>\n        {this._renderToolBox()}\n        {this.state.featureMenu && this._renderFeatureMenu(this.state.featureMenu)}\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport styled from 'styled-components';\n\nimport Example from '../../../examples/advanced/example';\n\nconst Container = styled.div`\n  width: 100%;\n  height: calc(100vh - 4rem);\n  margin-top: 4rem;\n`;\n\nexport default class GeoJsonEditor extends Component {\n  render() {\n    return (\n      <Container id=\"geoJsonEditorContainer\">\n        <Example />\n      </Container>\n    );\n  }\n}\n","module.exports = \"data:image/png;base64,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\""],"sourceRoot":""}