{"version":3,"sources":["webpack:///../modules/main/src/lib/style.js","webpack:///../modules/main/src/lib/deck-renderer/deck-drawer.js","webpack:///../modules/main/src/lib/nebula-layer.js","webpack:///../modules/edit-modes/src/utils.js","webpack:///../modules/edit-modes/src/lib/immutable-feature-collection.js","webpack:///../modules/edit-modes/src/lib/geojson-edit-mode.js","webpack:///../modules/edit-modes/src/lib/modify-mode.js","webpack:///../modules/edit-modes/src/lib/translate-mode.js","webpack:///../modules/edit-modes/src/lib/scale-mode.js","webpack:///../modules/edit-modes/src/lib/rotate-mode.js","webpack:///../modules/edit-modes/src/lib/duplicate-mode.js","webpack:///../modules/edit-modes/src/lib/split-polygon-mode.js","webpack:///../modules/edit-modes/src/lib/extrude-mode.js","webpack:///../modules/edit-modes/src/lib/elevation-mode.js","webpack:///../modules/edit-modes/src/lib/draw-point-mode.js","webpack:///../modules/edit-modes/src/lib/draw-line-string-mode.js","webpack:///../modules/edit-modes/src/lib/draw-polygon-mode.js","webpack:///../modules/edit-modes/src/lib/two-click-polygon-mode.js","webpack:///../modules/edit-modes/src/lib/draw-rectangle-mode.js","webpack:///../modules/edit-modes/src/lib/draw-circle-by-bounding-box-mode.js","webpack:///../modules/edit-modes/src/lib/draw-circle-from-center-mode.js","webpack:///../modules/edit-modes/src/lib/draw-ellipse-by-bounding-box-mode.js","webpack:///../modules/edit-modes/src/lib/three-click-polygon-mode.js","webpack:///../modules/edit-modes/src/lib/draw-ellipse-using-three-points-mode.js","webpack:///../modules/edit-modes/src/lib/draw-rectangle-using-three-points-mode.js","webpack:///../modules/edit-modes/src/lib/draw-90degree-polygon-mode.js","webpack:///../modules/edit-modes/src/lib/view-mode.js","webpack:///../modules/edit-modes/src/lib/composite-mode.js","webpack:///../modules/edit-modes/src/lib/snappable-mode.js","webpack:///../modules/layers/src/layers/editable-layer.js","webpack:///../modules/layers/src/layers/editable-geojson-layer.js","webpack:///../modules/layers/src/layers/selection-layer.js","webpack:///../modules/layers/src/layers/elevated-edit-handle-layer.js","webpack:///../modules/layers/src/shaderlib/outline/outline.js","webpack:///../modules/layers/src/layers/path-outline-layer/path-outline-layer.js","webpack:///../modules/layers/src/layers/path-marker-layer/arrow-2d-geometry.js","webpack:///../modules/layers/src/layers/path-marker-layer/create-path-markers.js","webpack:///../modules/layers/src/layers/path-marker-layer/polyline.js","webpack:///../modules/layers/src/layers/path-marker-layer/path-marker-layer.js","webpack:///../modules/layers/src/layers/junction-scatterplot-layer.js","webpack:///../modules/main/src/lib/layers/segments-layer.js","webpack:///../examples/advanced/toolbox.js","webpack:///../examples/advanced/example.js","webpack:///./src/pages/geojson-editor.js","webpack:///../examples/data/edit-handles.png"],"names":["ArrowStyles","SELECTION_TYPE","EventEmitter","generatePointsParallelToLinePoints","p1","p2","mapCoords","lineString","type","coordinates","pt","point","ddistance","pointToLineDistance","lineBearing","bearing","orthogonalBearing","isPointToLeftOfLine","p3","destination","p4","distance2d","x1","y1","x2","y2","dx","dy","Math","ImmutableFeatureCollection","featureCollection","this","_proto","prototype","getObject","replacePosition","geometry","features","featureIndex","isPolygonal","updatedGeometry","Object","assign","immutablyReplacePosition","positionIndexes","updatedPosition","replaceGeometry","removePosition","Error","immutablyRemovePosition","polygon","holeIndex","length","removeHoleIfNecessary","prunePolygonIfNecessary","lineStringIndex","pruneMultiLineStringIfNecessary","polygonIndex","outerRing","pruneMultiPolygonIfNecessary","pruneGeometryIfNecessary","addPosition","immutablyAddPosition","positionToAdd","updatedFeature","concat","slice","addFeature","addFeatures","feature","deleteFeature","deleteFeatures","featureIndexes","i","getUpdatedPosition","previousPosition","elevation","updated","hole","DEFAULT_EDIT_HANDLES","BaseGeoJsonEditMode","_clickSequence","getGuides","lastPointerMoveEvent","props","picks","editHandles","getEditHandlesAdapter","tentativeFeature","getTentativeFeature","tentativeFeatures","editHandleFeatures","map","handle","properties","guideType","editHandleType","position","getSelectedFeature","getSelectedGeometry","getSelectedFeaturesAsFeatureCollection","data","selectedIndexes","selectedIndex","getClickSequence","resetClickSequence","_tentativeFeature","_setTentativeFeature","_refreshCursor","currentCursor","cursor","updatedCursor","getCursorAdapter","isSelectionPicked","pickedFeatures","filter","pick","isGuide","getNonGuidePicks","_ref","index","pickedHandles","getPickedEditHandles","pickedIndexes","Set","some","getAddFeatureAction","geometryAsAny","updatedData","editType","editContext","getAddManyFeaturesAction","featuresToAdd","_ref2","initialIndex","updatedIndexes","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref3","next","done","value","getAddFeatureOrBooleanPolygonAction","selectedFeature","modeConfig","booleanOperation","console","turfUnion","turfDifference","turfIntersect","handleClick","editAction","handleClickAdapter","event","handlePointerMove","_this$handlePointerMo","handlePointerMoveAdapter","cancelMapPan","handleStartDragging","handleStartDraggingAdapter","handleStopDragging","handleStopDraggingAdapter","push","getPickedEditHandle","handles","object","getPickedExistingEditHandle","find","h","getPickedIntermediateEditHandle","getIntermediatePosition","position1","position2","getEditHandlesForGeometry","getEditHandlesForCoordinates","a","b","_a","positionIndexPrefix","ModifyMode","_BaseGeoJsonEditMode","apply","arguments","inheritsLoose_default","_this","_handles","_index","featureAsPick","intermediatePoint","referencePoint","recursivelyTraverseNestedArrays","array","prefix","fn","lineStringFeature","toLineString","candidateIntermediatePoint","nearestPointOnLine","viewport","dist","_intermediatePoint","line","coord","inPoint","wmViewport","web_mercator_viewport","projectedCoords","x","y","_ref$","z","_wmViewport$project","minDistance","Infinity","minPointInfo","_projectedCoords","A","B","C","div","distance","x0","y0","_minPointInfo","_projectedCoords2","_projectedCoords2$","z1","_projectedCoords$inde","_projectedCoords$inde2","z2","lineLength","z0","ratio","mix","nearestPointOnProjectedLine","pickedExistingHandle","pickedIntermediateHandle","ignored","_updatedData","editHandle","pointerDownPicks","getCursor","Boolean","selectedFeatureIndexes","geojson_edit_mode_BaseGeoJsonEditMode","TranslateMode","_isTranslatable","pointerDownMapCoords","_geometryBeforeTranslate","getTranslateAction","startDragPoint","currentPoint","distanceMoved","turfDistance","direction","turfBearing","movedFeatures","turfTransformTranslate","movedFeature","ScaleMode","_isScalable","_geometryBeingScaled","getScaleAction","startPosition","centroid","turfCentroid","factor","startDistance","getScaleFactor","scaledFeatures","turfTransformScale","origin","RotateMode","_isRotatable","_geometryBeingRotated","getRotateAction","angle","bearing1","getRotationAngle","rotatedFeatures","turfTransformRotate","DuplicateMode","_TranslateMode","translate_mode_TranslateMode","SplitPolygonMode","calculateMapCoords","lock90Degree","clickSequence","firstPoint","selectedGeometry","turfPolygonToLine","lines","Number","MAX_SAFE_INTEGER","closestPoint","snapPoint","distanceFromOrigin","lastBearing","currentDistance","units","destination_default","lastPoint","approximatePoint","call","isPointInPolygon","booleanPointInPolygon","lineIntersect","isLineInterectingWithPolygon","splitPolygon","result","_modeConfig$gap","gap","_modeConfig$units","buffer","turfBuffer","_updatedGeometry$geom","updatedCoordinates","c","reduce","agg","prev","p","ExtrudeMode","_ModifyMode","_len","args","_key","isPointAdded","size","coordinatesSize","nextPositionIndexes","getPointForPositionIndexes","prevPositionIndexes","_generatePointsParall","isOrthogonal","_generatePointsParall2","getBearing","prevPoint","nextPoint","prevAngle","nextAngle","includes","modify_mode_ModifyMode","defaultCalculateElevationChange","pointerDownScreenCoords","screenCoords","ElevationMode","makeElevatedEvent","_ref2$minElevation","minElevation","_ref2$maxElevation","maxElevation","_ref2$calculateElevat","calculateElevationChange","calculateElevationChangeWithViewport","PI","zoom","DrawPointMode","DrawLineStringMode","drawAtFront","DrawPolygonMode","clickedEditHandle","polygonToAdd","fakePointerMoveEvent","isDragging","sourceEvent","TwoClickPolygonMode","DrawRectangleMode","_TwoClickPolygonMode","corner1","corner2","bboxPolygon","two_click_polygon_mode_TwoClickPolygonMode","DrawCircleByBoundingBoxMode","_modeConfig$steps","steps","options","firstClickedPoint","centerCoordinates","radius","circle","DrawCircleFromCenterMode","DrawEllipseByBoundingBoxMode","minX","minY","maxX","maxY","polygonPoints","xSemiAxis","ySemiAxis","ellipse","ThreeClickPolygonMode","DrawEllipseUsingThreePointsMode","_ThreeClickPolygonMod","three_click_polygon_mode_ThreeClickPolygonMode","DrawRectangleUsingThreePointsMode","Draw90DegreePolygonMode","finalizedCoordinates","coords","getIntermediatePoint","tc","angle1","angle2","angles","first","second","forEach","newAngle1","newAngle2","indexFirst","line1","indexSecond","line2","fc","ViewMode","CompositeMode","handlers","_coalesce","resultEval","callback","handler","SnappableMode","_handler","_getSnappedMouseEvent","_startDragSnapHandlePosition","_getEditHandlePicks","potentialSnapHandle","pickedHandle","_updatePickedHandlePosition","_editHandlePicks","_getSnapTargets","additionalSnapTargets","_getNonPickedIntermediateHandles","enableSnapping","_ref5","_getSnapAwareEvent","modeActionSummary","EditableLayer","onLayerClick","onDoubleClick","onStartDragging","onStopDragging","onPointerMove","initializeState","setState","_editableLayerState","pointerHandlers","finalizeState","_removePointerHandlers","updateState","changeFlags","_addPointerHandlers","state","context","gl","canvas","removeEventListener","onPointerDown","onPointerUp","_onPointerMove","bind","_onPointerDown","_onPointerUp","_onDoubleClick","addEventListener","getScreenCoords","getMapCoords","deck","pickMultipleObjects","layerIds","id","pickingRadius","depth","pickingDepth","_this$state$_editable","startedDragging","movedEnoughForDrag","_this$state$_editable2","pointerEvent","getBoundingClientRect","unproject","screenCoords1","screenCoords2","CompositeLayer","DEFAULT_LINE_COLOR","DEFAULT_FILL_COLOR","DEFAULT_SELECTED_LINE_COLOR","DEFAULT_SELECTED_FILL_COLOR","DEFAULT_EDITING_EXISTING_POINT_COLOR","DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","DEFAULT_EDITING_SNAP_POINT_COLOR","DEFAULT_EDITING_POINT_OUTLINE_COLOR","DEFAULT_EDITING_EXISTING_POINT_RADIUS","DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","DEFAULT_EDITING_SNAP_POINT_RADIUS","DEFAULT_EDIT_MODE","draw_polygon_mode_DrawPolygonMode","guideAccessor","accessor","guideMaybeWrapped","__source","sourceFeature","unwrapGuide","getEditHandleColor","defaultProps","mode","onEdit","pickable","fp64","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","lineWidthUnits","lineJointRounded","lineMiterLimit","pointRadiusScale","pointRadiusMinPixels","pointRadiusMaxPixels","lineDashJustified","getLineColor","isSelected","getFillColor","getRadius","f","getLineWidth","lineWidth","getLineDashArray","getTentativeLineDashArray","getTentativeLineColor","getTentativeFillColor","getTentativeLineWidth","editHandlePointRadiusScale","editHandlePointOutline","editHandlePointStrokeWidth","editHandlePointRadiusMinPixels","editHandlePointRadiusMaxPixels","getEditHandlePointColor","getEditHandlePointOutlineColor","getEditHandlePointRadius","editHandleIconAtlas","editHandleIconMapping","editHandleIconSizeScale","getEditHandleIcon","getEditHandleIconSize","getEditHandleIconColor","getEditHandleIconAngle","billboard","modeNameMapping","view","view_mode_ViewMode","modify","translate","snappable_mode_SnappableMode","scale","scale_mode_ScaleMode","rotate","rotate_mode_RotateMode","duplicate","duplicate_mode_DuplicateMode","split","split_polygon_mode_SplitPolygonMode","extrude","extrude_mode_ExtrudeMode","elevation_mode_ElevationMode","drawPoint","draw_point_mode_DrawPointMode","drawLineString","draw_line_string_mode_DrawLineStringMode","drawPolygon","drawRectangle","draw_rectangle_mode_DrawRectangleMode","drawCircleFromCenter","draw_circle_from_center_mode_DrawCircleFromCenterMode","drawCircleByBoundingBox","draw_circle_by_bounding_box_mode_DrawCircleByBoundingBoxMode","drawEllipseByBoundingBox","draw_ellipse_by_bounding_box_mode_DrawEllipseByBoundingBoxMode","drawRectangleUsing3Points","draw_rectangle_using_three_points_mode_DrawRectangleUsingThreePointsMode","drawEllipseUsing3Points","draw_ellipse_using_three_points_mode_DrawEllipseUsingThreePointsMode","draw90DegreePolygon","EditableGeoJsonLayer","renderLayers","subLayerProps","getSubLayerProps","selectionAwareAccessor","_subLayerProps","line-strings","polygons-stroke","updateTriggers","layers","geojson_layer","_EditableLayer","selectedFeatures","shouldUpdateState","opts","stateChanged","oldProps","propsOrDataChanged","String","elem","getModeProps","onUpdateCursor","_this2","isFeatureSelected","indexOf","getPickingInfo","info","sourceLayer","createGuidesLayers","pointLayerProps","guides","getActiveMode","icon_layer","iconAtlas","iconMapping","sizeScale","getIcon","getSize","getColor","getAngle","scatterplot_layer","radiusScale","radiusMinPixels","radiusMaxPixels","points","selectionType","onSelect","EMPTY_DATA","PASS_THROUGH_PROPS","SelectionLayer","_selectRectangleObjects","_this$props","_this$context$viewpor","project","_this$context$viewpor2","pickingInfos","pickObjects","width","height","_selectPolygonObjects","bigPolygon","_this$props2","mousePoints","allX","mousePoint","allY","landPointsPoly","bigBuffer","e","pendingPolygonSelection","blockerId","setTimeout","item","_SELECTION_TYPE$RECTA","inheritedProps","undefined","editable_geojson_layer_EditableGeoJsonLayer","polygon_layer","opacity","obj","getPolygon","o","_ref2$changeFlags","ElevatedEditHandleLayer","line_layer","getSourcePosition","getTargetPosition","getStrokeWidth","INITIAL_STATE","outlineEnabled","outlineRenderShadowmap","outlineShadowmap","outline","name","vs","fs","getUniforms","_temp","uniforms","injectShaderCode","source","_ref$code","code","PathOutlineLayer","getShaders","shaders","_PathLayer","modules","outlineFramebuffer","core_dist_esm","dummyTexture","attributeManager","addInstanced","instanceZLevel","GL","UNSIGNED_BYTE","update","calculateZLevels","draw","moduleParameters","parameters","rounded","miterLimit","widthScale","widthMinPixels","widthMaxPixels","dashJustified","jointType","alignMode","_this$state","color","model","updateModuleSettings","depthTest","blendEquation","MAX","framebuffer","getZLevel","pathTesselator","attribute","_updateAttribute","target","getValue","PathLayer","Arrow2DGeometry","_Geometry","attributes","getArrowAttributes","Geometry","_ref$length","_ref$headSize","headSize","_ref$tailWidth","tailWidth","_ref$tailStart","tailStart","texCoords","positions","i3","Float32Array","normals","getLineLength","vPoints","DEFAULT_COLOR","DEFAULT_DIRECTION","forward","backward","createMarkerAlongPath","_ref4","path","percentage","projectFlat","distanceAlong","previousDistance","along","vCenter","normalize","vDirection","vector2","subtract","verticalAngle","getClosestPointOnLine","_ref$clampToLine","clampToLine","lineVector","vector3","pointVector","dotProduct","clamp","DEFAULT_MARKER_LAYER","simple_mesh_layer","DEFAULT_MARKER_LAYER_PROPS","mesh","arrow_2d_geometry_Arrow2DGeometry","MarkerLayer","markerLayerProps","hightlightIndex","highlightPoint","getPath","getMarkerColor","getDirection","getMarkerPercentages","PathMarkerLayer","markers","coordinateSystem","COORDINATE_SYSTEM","METER_OFFSETS","_viewport$metersToLng","xyz","coordinateOrigin","LNGLAT_OFFSETS","_dx","_y","updateTriggersChanged","_ref$getPath","_ref$getDirection","_ref$getColor","_ref$getMarkerPercent","vPointsReverse","reverse","_iterator2","_isArray2","_i2","marker","createPathMarkers","_recalculateClosestPoint","propsChanged","highlightIndex","pClosest","distanceSquared","pClosestOnLine","distanceToLineSquared","getClosestPointOnPolyline","closestPoints","path_outline_layer_PathOutlineLayer","getOrientation","blend","JunctionScatterplotLayer","getStrokeColor","getInnerRadius","layerName","ScatterplotLayer","d","_NEBULA_TO_DECK_DIREC","styles","toolboxItem","flexBasis","Toolbox","styled","withConfig","displayName","componentId","ToolboxRow","react_default","createElement","children","ToolboxControl","style","ToolboxTitle","buttonBackground","ToolboxButton","button","ToolboxCheckboxContainer","ToolboxCheckbox","COMPOSITE_MODE","composite_mode_CompositeMode","mapContainer","alignItems","display","checkbox","margin","initialViewport","latitude","longitude","pitch","ALL_MODES","category","modes","label","POLYGON_DRAWING_MODES","draw_90degree_polygon_mode_Draw90DegreePolygonMode","EMPTY_FEATURE_COLLECTION","FEATURE_COLORS","hex","parseInt","shift","getEditHandleTypeFromEitherLayer","handleOrFeature","example_getEditHandleColor","Example","_Component","_onChangeViewport","_onLayerClick","selectionTool","_resize","forceUpdate","_loadSample","testFeatures","sample_geojson","el","document","reader","FileReader","_parseStringJson","_copy","navigator","clipboard","JSON","_error","_paste","reason","_download","blob","Blob","URL","json","err","alert","updatedSelectedFeatureIndexes","updatedDataInfo","flatMap","arr","getPositionCount","pointsRemovable","_getDeckColorForFeature","showGeoJson","pathMarkerLayer","featureMenu","componentDidMount","window","componentWillUnmount","_getHtmlColorForFeature","join","selected","alpha","_renderSelectFeatureCheckbox","key","toolbox_ToolboxCheckbox","checked","onChange","featureType","right","onClick","clientX","clientY","_renderSelectFeatureCheckboxes","checkboxes","_renderBooleanOperationControls","_this3","toolbox_ToolboxRow","toolbox_ToolboxControl","operation","_renderDrawLineStringModeControls","_this4","_renderModifyModeControls","_this5","_renderSplitModeControls","_this6","_renderSnappingControls","_this7","_renderModeConfigControls","controls","_renderToolBox","_this8","Fragment","rows","renderStaticMap","dist_esm","mapStyle","_featureMenuClick","action","_renderFeatureMenu","_this9","top","left","customizeLayers","render","_this10","innerHeight","innerWidth","elevated_edit_handle_layer_ElevatedEditHandleLayer","geojson","path_marker_layer_PathMarkerLayer","editableGeoJsonLayer","autoHighlight","edit_handles_default","intermediate","mask","existing","depthMask","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","selection_layer_SelectionLayer","_ref6","pi","href","rel","esm_deckgl","viewState","views","esm","controller","doubleClickZoom","onViewStateChange","_ref7","Component","Container","GeoJsonEditor","example_Example","module","exports"],"mappings":"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","file":"component---src-pages-geojson-editor-js-9dc1b7608d355ee83ea0.js","sourcesContent":["// @flow\n// Describes the arrow style of polylines\nexport const ArrowStyles = {\n  NONE: 0,\n  FORWARD: 1,\n  BACKWARD: 2,\n  BOTH: 3\n};\n\nexport const DEFAULT_ARROWS = 1;\nexport const MAX_ARROWS = 3;\n\nexport const DEFAULT_STYLE = {\n  arrowColor: [0, 0, 0, 1],\n  arrowCount: DEFAULT_ARROWS,\n  arrowStyle: ArrowStyles.NONE,\n  fillColor: [0, 0, 0, 1],\n  lineColor: [0, 0, 0, 1],\n  lineWidthMeters: 5,\n  outlineRadiusMeters: 0,\n  opacity: 1,\n  zLevel: 0\n};\n","// @flow\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { point, polygon } from '@turf/helpers';\nimport turfBbox from '@turf/bbox';\nimport turfBboxPolygon from '@turf/bbox-polygon';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\nimport turfDistance from '@turf/distance';\n\nconst POLYGON_LINE_COLOR = [0, 255, 0, 255];\nconst POLYGON_FILL_COLOR = [255, 255, 255, 90];\nconst POLYGON_LINE_WIDTH = 2;\nconst POLYGON_DASHES = [20, 20];\nconst POLYGON_THRESHOLD = 0.01;\nconst EXPANSION_KM = 10;\nconst LAYER_ID_VIEW = 'DeckDrawerView';\nconst LAYER_ID_PICK = 'DeckDrawerPick';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nexport default class DeckDrawer {\n  nebula: Object;\n  usePolygon: boolean;\n  validPolygon: boolean;\n  landPoints: [number, number][];\n  mousePoints: [number, number][];\n\n  constructor(nebula: Object) {\n    this.nebula = nebula;\n    this.usePolygon = false;\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _getLayerIds() {\n    // TODO: sort by mouse priority\n    return this.nebula.deckgl.props.layers\n      .filter(l => l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enableSelection)\n      .map(l => l.id);\n  }\n\n  _selectFromPickingInfos(pickingInfos: Object[]) {\n    const objects = pickingInfos.map(\n      ({ layer, index, object }) =>\n        object.original || layer.props.nebulaLayer.deckCache.originals[index]\n    );\n    this.nebula.props.onSelection(objects);\n  }\n\n  _getBoundingBox(): Object {\n    const { mousePoints } = this;\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    return { x, y, width: maxX - x, height: maxY - y };\n  }\n\n  _selectRectangleObjects() {\n    if (this.landPoints.length !== 2) return;\n\n    const [x1, y1] = this.mousePoints[0];\n    const [x2, y2] = this.mousePoints[1];\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds: this._getLayerIds()\n    });\n\n    this._selectFromPickingInfos(pickingInfos);\n  }\n\n  _selectPolygonObjects() {\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      ...this._getBoundingBox(),\n      layerIds: [LAYER_ID_PICK, ...this._getLayerIds()]\n    });\n\n    this._selectFromPickingInfos(pickingInfos.filter(item => item.layer.id !== LAYER_ID_PICK));\n  }\n\n  _getMousePosFromEvent(event: Object): [number, number] {\n    const { offsetX, offsetY } = event;\n    return [offsetX, offsetY];\n  }\n\n  handleEvent(\n    event: Object,\n    lngLat: [number, number],\n    selectionType: number\n  ): { redraw: boolean, deactivate: boolean } {\n    // capture all events (mouse-up is needed to prevent us stuck in moving map)\n    if (event.type !== 'mouseup') event.stopPropagation();\n\n    this.usePolygon = selectionType === SELECTION_TYPE.POLYGON;\n\n    let redraw = false;\n    let deactivate = false;\n\n    const { usePolygon, landPoints, mousePoints } = this;\n\n    if (event.type === 'mousedown') {\n      if (usePolygon && landPoints.length) {\n        // if landPoints.length is zero we want to insert two points (so we let it run the else)\n        // also don't insert if polygon is invalid\n        if (this.landPoints.length < 3 || this.validPolygon) {\n          landPoints.push(lngLat);\n          mousePoints.push(this._getMousePosFromEvent(event));\n        }\n      } else {\n        this.landPoints = [lngLat, lngLat];\n        const m = this._getMousePosFromEvent(event);\n        this.mousePoints = [m, m];\n      }\n      redraw = true;\n    } else if (event.type === 'mousemove' && landPoints.length) {\n      // update last point\n      landPoints[landPoints.length - 1] = lngLat;\n      mousePoints[mousePoints.length - 1] = this._getMousePosFromEvent(event);\n      redraw = true;\n    } else if (event.type === 'mouseup') {\n      if (usePolygon) {\n        // check to see if completed\n        // TODO: Maybe double-click to finish?\n        if (\n          landPoints.length > 4 &&\n          turfDistance(landPoints[0], landPoints[landPoints.length - 1]) < POLYGON_THRESHOLD &&\n          this.validPolygon\n        ) {\n          this._selectPolygonObjects();\n          this.reset();\n          redraw = true;\n          deactivate = true;\n        }\n      } else {\n        this._selectRectangleObjects();\n        this.reset();\n        redraw = true;\n        deactivate = true;\n      }\n    }\n\n    return { redraw, deactivate };\n  }\n\n  reset() {\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _makeStartPointHighlight(center: [number, number]): number[] {\n    const buffer = turfBuffer(point(center), POLYGON_THRESHOLD / 4.0);\n    return turfBboxPolygon(turfBbox(buffer)).geometry.coordinates;\n  }\n\n  render() {\n    const data = [];\n    const dataPick = [];\n\n    if (!this.usePolygon && this.landPoints.length === 2) {\n      // Use mouse points instead of land points so we get the right shape\n      // no matter what bearing is.\n      const [[x1, y1], [x2, y2]] = this.mousePoints;\n      const selPolygon = [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]].map(mousePos =>\n        this.nebula.unprojectMousePosition(mousePos)\n      );\n      data.push({\n        polygon: selPolygon,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n    } else if (this.usePolygon && this.landPoints.length) {\n      data.push({\n        polygon: this.landPoints,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n\n      // Hack: use a polygon to hide the outside, because pickObjects()\n      // does not support polygons\n      if (this.landPoints.length >= 3) {\n        const landPointsPoly = polygon([[...this.landPoints, this.landPoints[0]]]);\n        const bigBuffer = turfBuffer(point(this.landPoints[0]), EXPANSION_KM);\n        let bigPolygon;\n        try {\n          // turfDifference throws an exception if the polygon\n          // intersects with itself\n          bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n          dataPick.push({\n            polygon: bigPolygon.geometry.coordinates,\n            fillColor: [0, 0, 0, 1]\n          });\n          this.validPolygon = true;\n        } catch (e) {\n          // invalid selection polygon\n          this.validPolygon = false;\n        }\n      }\n    }\n\n    if (this.landPoints.length) {\n      // highlight start point\n      data.push({\n        polygon: this._makeStartPointHighlight(this.landPoints[0]),\n        lineColor: [0, 0, 0, 0],\n        fillColor: POLYGON_LINE_COLOR\n      });\n    }\n\n    // Hack to make the PolygonLayer() stay active,\n    // otherwise it takes 3 seconds (!) to init!\n    // TODO: fix this\n    data.push({ polygon: [[0, 0]] });\n    dataPick.push({ polygon: [[0, 0]] });\n\n    return [\n      new PolygonLayer({\n        id: LAYER_ID_VIEW,\n        data,\n        fp64: false,\n        opacity: 1.0,\n        pickable: false,\n        lineWidthMinPixels: POLYGON_LINE_WIDTH,\n        lineWidthMaxPixels: POLYGON_LINE_WIDTH,\n        lineDashJustified: true,\n        getLineDashArray: x => POLYGON_DASHES,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        getPolygon: o => o.polygon\n      }),\n      new PolygonLayer({\n        id: LAYER_ID_PICK,\n        data: dataPick,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        fp64: false,\n        opacity: 1.0,\n        stroked: false,\n        pickable: true,\n        getPolygon: o => o.polygon\n      })\n    ];\n  }\n}\n","// @flow\nimport EventEmitter from 'events';\nimport uuid from 'uuid';\n\nimport Feature from './feature';\n\nexport default class NebulaLayer extends EventEmitter {\n  getData: () => Object[];\n  toNebulaFeature: (data: Object) => Feature;\n  id: string;\n  helperLayers: Object[];\n\n  // flags\n  usesMapEvents: boolean = false;\n  enablePicking: boolean = false;\n  enableSelection: boolean = false;\n  //\n\n  constructor({ getData, on, toNebulaFeature }: Object) {\n    super();\n    this.id = uuid.v4();\n    this.getData = getData;\n    this.toNebulaFeature = toNebulaFeature;\n    this.helperLayers = [];\n\n    if (on) {\n      Object.keys(on).forEach(key => this.on(key, on[key]));\n    }\n  }\n\n  render(config: Object): mixed {\n    return null;\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { point } from '@turf/helpers';\nimport WebMercatorViewport from 'viewport-mercator-project';\nimport type { Viewport } from './types.js';\nimport type { Position, Point, LineString, FeatureOf, FeatureWithProps } from './geojson-types.js';\n\nexport type NearestPointType = FeatureWithProps<Point, { dist: number, index: number }>;\n\nexport function toDeckColor(\n  color?: ?[number, number, number, number],\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  mapCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  const pt = point(mapCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nexport function distance2d(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function mix(a: number, b: number, ratio: number): number {\n  return b * ratio + a * (1 - ratio);\n}\n\nexport function nearestPointOnProjectedLine(\n  line: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport: Viewport\n): NearestPointType {\n  const wmViewport = new WebMercatorViewport(viewport);\n  // Project the line to viewport, then find the nearest point\n  const coordinates: Array<Array<number>> = (line.geometry.coordinates: any);\n  const projectedCoords = coordinates.map(([x, y, z = 0]) => wmViewport.project([x, y, z]));\n  const [x, y] = wmViewport.project(inPoint.geometry.coordinates);\n  // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n  let minDistance = Infinity;\n  let minPointInfo = {};\n\n  projectedCoords.forEach(([x2, y2], index) => {\n    if (index === 0) {\n      return;\n    }\n\n    const [x1, y1] = projectedCoords[index - 1];\n\n    // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n    const A = y1 - y2;\n    const B = x2 - x1;\n    const C = x1 * y2 - x2 * y1;\n\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    const div = A * A + B * B;\n    const distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);\n\n    // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div\n      };\n    }\n  });\n\n  const { index, x0, y0 } = minPointInfo;\n  const [x1, y1, z1 = 0] = projectedCoords[index - 1];\n  const [x2, y2, z2 = 0] = projectedCoords[index];\n\n  // calculate what ratio of the line we are on to find the proper z\n  const lineLength = distance2d(x1, y1, x2, y2);\n  const startToPointLength = distance2d(x1, y1, x0, y0);\n  const ratio = startToPointLength / lineLength;\n  const z0 = mix(z1, z2, ratio);\n\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0])\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1\n    }\n  };\n}\n","// @flow\n\nimport type {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  Polygon,\n  MultiLineString,\n  MultiPolygon,\n  Position,\n  PolygonCoordinates\n} from '../geojson-types.js';\n\nexport class ImmutableFeatureCollection {\n  featureCollection: FeatureCollection;\n\n  constructor(featureCollection: FeatureCollection) {\n    this.featureCollection = featureCollection;\n  }\n\n  getObject() {\n    return this.featureCollection;\n  }\n\n  /**\n   * Replaces the position deeply nested withing the given feature's geometry.\n   * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position to replace\n   * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n   */\n  replacePosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    updatedPosition: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyReplacePosition(\n        geometry.coordinates,\n        positionIndexes,\n        updatedPosition,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion to remove\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  removePosition(featureIndex: number, positionIndexes: number[]): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw Error(`Can't remove a position from a Point or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'MultiPoint' &&\n      // only 1 point left\n      geometry.coordinates.length < 2\n    ) {\n      throw Error(`Can't remove the last point of a MultiPoint or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'LineString' &&\n      // only 2 positions\n      geometry.coordinates.length < 3\n    ) {\n      throw Error(`Can't remove position. LineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'Polygon' &&\n      // outer ring is a triangle\n      geometry.coordinates[0].length < 5 &&\n      // trying to remove from outer ring\n      positionIndexes[0] === 0\n    ) {\n      throw Error(`Can't remove position. Polygon's outer ring must have at least four positions`);\n    }\n    if (\n      geometry.type === 'MultiLineString' &&\n      // only 1 LineString left\n      geometry.coordinates.length === 1 &&\n      // only 2 positions\n      geometry.coordinates[0].length < 3\n    ) {\n      throw Error(`Can't remove position. MultiLineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'MultiPolygon' &&\n      // only 1 polygon left\n      geometry.coordinates.length === 1 &&\n      // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 &&\n      // trying to remove from first polygon\n      positionIndexes[0] === 0 &&\n      // trying to remove from outer ring\n      positionIndexes[1] === 0\n    ) {\n      throw Error(\n        `Can't remove position. MultiPolygon's outer ring must have at least four positions`\n      );\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)\n    };\n\n    // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n    pruneGeometryIfNecessary(updatedGeometry);\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position that will proceed the new position\n   * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  addPosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    positionToAdd: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw new Error('Unable to add a position to a Point feature');\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyAddPosition(\n        geometry.coordinates,\n        positionIndexes,\n        positionToAdd,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  replaceGeometry(featureIndex: number, geometry: Geometry): ImmutableFeatureCollection {\n    const updatedFeature: any = {\n      ...this.featureCollection.features[featureIndex],\n      geometry\n    };\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [\n        ...this.featureCollection.features.slice(0, featureIndex),\n        updatedFeature,\n        ...this.featureCollection.features.slice(featureIndex + 1)\n      ]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  addFeature(feature: Feature): ImmutableFeatureCollection {\n    return this.addFeatures([feature]);\n  }\n\n  addFeatures(features: Feature[]): ImmutableFeatureCollection {\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [...this.featureCollection.features, ...features]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  deleteFeature(featureIndex: number) {\n    return this.deleteFeatures([featureIndex]);\n  }\n\n  deleteFeatures(featureIndexes: number[]) {\n    const features = [...this.featureCollection.features];\n    featureIndexes.sort();\n    for (let i = featureIndexes.length - 1; i >= 0; i--) {\n      const featureIndex = featureIndexes[i];\n      if (featureIndex >= 0 && featureIndex < features.length) {\n        features.splice(featureIndex, 1);\n      }\n    }\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n}\n\nfunction getUpdatedPosition(updatedPosition: Position, previousPosition: Position): Position {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    const elevation = (previousPosition: any)[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  updatedPosition: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyReplacePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      updatedPosition,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyRemovePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyRemovePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyAddPosition(\n  coordinates: any,\n  positionIndexes: number[],\n  positionToAdd: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      positionToAdd,\n      ...coordinates.slice(positionIndexes[0])\n    ];\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyAddPosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      positionToAdd,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction pruneGeometryIfNecessary(geometry: Geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry: Polygon) {\n  const polygon = geometry.coordinates;\n\n  // If any hole is no longer a polygon, remove the hole entirely\n  for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry: MultiLineString) {\n  for (let lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    const lineString = geometry.coordinates[lineStringIndex];\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1);\n      // Keep the index the same\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry: MultiPolygon) {\n  for (let polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    const polygon = geometry.coordinates[polygonIndex];\n    const outerRing = polygon[0];\n\n    // If the outer ring is no longer a polygon, remove the whole polygon\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1);\n      // It was removed, so keep the index the same\n      polygonIndex--;\n    }\n\n    for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon: PolygonCoordinates, holeIndex: number) {\n  const hole = polygon[holeIndex];\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n  return false;\n}\n","// @flow\n\nimport turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\n\nimport type {\n  EditAction,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  Pick,\n  ModeProps\n} from '../types.js';\nimport type {\n  FeatureCollection,\n  Feature,\n  FeatureOf,\n  Point,\n  Polygon,\n  Geometry,\n  Position\n} from '../geojson-types.js';\nimport { EditMode } from './edit-mode.js';\n\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport type EditHandleType = 'existing' | 'intermediate' | 'snap';\n\n// TODO edit-modes: - Change this to just be a GoeJSON instead\nexport type EditHandle = {\n  position: Position,\n  positionIndexes: number[],\n  featureIndex: number,\n  type: EditHandleType\n};\n\nexport type GeoJsonEditAction = EditAction<FeatureCollection>;\n\nconst DEFAULT_EDIT_HANDLES: EditHandle[] = [];\n\n// Main interface for `EditMode`s that edit GeoJSON\nexport type GeoJsonEditMode = EditMode<FeatureCollection, FeatureCollection>;\n\nexport class BaseGeoJsonEditMode implements EditMode<FeatureCollection, FeatureCollection> {\n  _clickSequence: Position[] = [];\n  _tentativeFeature: ?Feature;\n\n  getGuides(props: ModeProps<FeatureCollection>): FeatureCollection {\n    const { lastPointerMoveEvent } = props;\n    const picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n    const mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;\n    const editHandles = this.getEditHandlesAdapter(picks, mapCoords, props);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const tentativeFeatures: Feature[] = tentativeFeature ? [tentativeFeature] : [];\n    const editHandleFeatures: FeatureOf<Point>[] = editHandles.map(handle => ({\n      type: 'Feature',\n      properties: {\n        guideType: 'editHandle',\n        editHandleType: handle.type,\n        featureIndex: handle.featureIndex,\n        positionIndexes: handle.positionIndexes\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: handle.position\n      }\n    }));\n\n    return {\n      type: 'FeatureCollection',\n      features: [...tentativeFeatures, ...editHandleFeatures]\n    };\n  }\n\n  getSelectedFeature(props: ModeProps<FeatureCollection>): ?Feature {\n    if (props.selectedIndexes.length === 1) {\n      return props.data.features[props.selectedIndexes[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(props: ModeProps<FeatureCollection>): ?Geometry {\n    const feature = this.getSelectedFeature(props);\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(props: ModeProps<FeatureCollection>): FeatureCollection {\n    const { features } = props.data;\n    const selectedFeatures = props.selectedIndexes.map(selectedIndex => features[selectedIndex]);\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures\n    };\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._tentativeFeature;\n  }\n\n  // TODO edit-modes: delete me once mode handlers do getEditHandles lazily\n  _setTentativeFeature(tentativeFeature: ?Feature): void {\n    if (tentativeFeature) {\n      tentativeFeature.properties = {\n        ...(tentativeFeature.properties || {}),\n        guideType: 'tentative'\n      };\n    }\n    this._tentativeFeature = tentativeFeature;\n  }\n\n  _refreshCursor(props: ModeProps<FeatureCollection>): void {\n    const currentCursor = props.cursor;\n    const updatedCursor = this.getCursorAdapter(props);\n\n    if (currentCursor !== updatedCursor) {\n      props.onUpdateCursor(updatedCursor);\n    }\n  }\n\n  /**\n   * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.\n   *\n   * @param featureIndex The index of the feature to get edit handles\n   */\n  getEditHandlesAdapter(\n    picks: ?Array<Object>,\n    mapCoords: ?Position,\n    props: ModeProps<FeatureCollection>\n  ): EditHandle[] {\n    return DEFAULT_EDIT_HANDLES;\n  }\n\n  getCursorAdapter(props: ModeProps<FeatureCollection>): ?string {\n    return null;\n  }\n\n  isSelectionPicked(picks: Pick[], props: ModeProps<FeatureCollection>): boolean {\n    if (!picks.length) return false;\n    const pickedFeatures = getNonGuidePicks(picks).map(({ index }) => index);\n    const pickedHandles = getPickedEditHandles(picks).map(handle => handle.featureIndex);\n    const pickedIndexes = new Set([...pickedFeatures, ...pickedHandles]);\n    return props.selectedIndexes.some(index => pickedIndexes.has(index));\n  }\n\n  getAddFeatureAction(geometry: Geometry, features: FeatureCollection): GeoJsonEditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const geometryAsAny: any = geometry;\n\n    const updatedData = new ImmutableFeatureCollection(features)\n      .addFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: geometryAsAny\n      })\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: [updatedData.features.length - 1]\n      }\n    };\n  }\n\n  getAddManyFeaturesAction(\n    { features: featuresToAdd }: FeatureCollection,\n    features: FeatureCollection\n  ): GeoJsonEditAction {\n    let updatedData = new ImmutableFeatureCollection(features);\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of featuresToAdd) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: updatedIndexes\n      }\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(\n    geometry: Polygon,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    const selectedFeature = this.getSelectedFeature(props);\n    const { modeConfig } = props;\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature = {\n        type: 'Feature',\n        geometry\n      };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = props.selectedIndexes[0];\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: GeoJsonEditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        editContext: {\n          featureIndexes: [featureIndex]\n        }\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(geometry, props.data);\n  }\n\n  handleClick(event: ClickEvent, props: ModeProps<FeatureCollection>): void {\n    const editAction = this.handleClickAdapter(event, props);\n\n    if (editAction) {\n      props.onEdit(editAction);\n    }\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    const { editAction, cancelMapPan } = this.handlePointerMoveAdapter(event, props);\n\n    if (cancelMapPan) {\n      // TODO: is there a less hacky way to prevent map panning?\n      // Stop propagation to prevent map panning while dragging an edit handle\n      event.sourceEvent.stopPropagation();\n    }\n\n    this._refreshCursor(props);\n    if (editAction) {\n      props.onEdit(editAction);\n    }\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editAction = this.handleStartDraggingAdapter(event, props);\n\n    if (editAction) {\n      props.onEdit(editAction);\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editAction = this.handleStopDraggingAdapter(event, props);\n\n    if (editAction) {\n      props.onEdit(editAction);\n    }\n  }\n\n  // TODO edit-modes: delete these adapters once all ModeHandler implementations don't use them\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    this._clickSequence.push(event.mapCoords);\n\n    return null;\n  }\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    return { editAction: null, cancelMapPan: false };\n  }\n\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    return null;\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    return null;\n  }\n}\n\nexport function getPickedEditHandle(picks: ?(any[])): ?EditHandle {\n  const handles = getPickedEditHandles(picks);\n  return handles.length ? handles[0] : null;\n}\n\nexport function getNonGuidePicks(picks: any[]): any[] {\n  return picks && picks.filter(pick => !pick.isGuide);\n}\n\n// TODO edit-modes: refactor to just return `info.object`\nexport function getPickedEditHandles(picks: ?(any[])): EditHandle[] {\n  const handles =\n    (picks &&\n      picks\n        .filter(pick => pick.isGuide && pick.object.properties.guideType === 'editHandle')\n        .map(pick => pick.object)) ||\n    [];\n\n  return handles.map(handle => {\n    const feature: FeatureOf<Point> = handle;\n    const { geometry } = feature;\n\n    // $FlowFixMe\n    const properties: { [string]: any } = feature.properties;\n    return {\n      type: properties.editHandleType,\n      position: geometry.coordinates,\n      positionIndexes: properties.positionIndexes,\n      featureIndex: properties.featureIndex\n    };\n  });\n}\n\nexport function getPickedExistingEditHandle(picks: ?(any[])): ?EditHandle {\n  const handles = getPickedEditHandles(picks);\n  return handles.find(h => h.featureIndex >= 0 && h.type === 'existing');\n}\n\nexport function getPickedIntermediateEditHandle(picks: ?(any[])): ?EditHandle {\n  const handles = getPickedEditHandles(picks);\n  return handles.find(h => h.featureIndex >= 0 && h.type === 'intermediate');\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0\n  ];\n  return intermediatePosition;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n) {\n  let handles: EditHandle[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          position: geometry.coordinates,\n          positionIndexes: [],\n          featureIndex,\n          type: editHandleType\n        }\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    default:\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandle[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      position,\n      positionIndexes: [...positionIndexPrefix, i],\n      featureIndex,\n      type: editHandleType\n    });\n  }\n  return editHandles;\n}\n","// @flow\n\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { point, lineString as toLineString } from '@turf/helpers';\nimport {\n  recursivelyTraverseNestedArrays,\n  nearestPointOnProjectedLine,\n  type NearestPointType\n} from '../utils.js';\nimport type {\n  Position,\n  LineString,\n  Point,\n  FeatureCollection,\n  FeatureOf\n} from '../geojson-types.js';\nimport type {\n  ModeProps,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  Viewport\n} from '../types.js';\nimport {\n  BaseGeoJsonEditMode,\n  getPickedEditHandle,\n  getPickedEditHandles,\n  getPickedExistingEditHandle,\n  getPickedIntermediateEditHandle,\n  getEditHandlesForGeometry,\n  type GeoJsonEditAction,\n  type EditHandle\n} from './geojson-edit-mode.js';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport class ModifyMode extends BaseGeoJsonEditMode {\n  getEditHandlesAdapter(\n    picks: ?Array<Object>,\n    mapCoords: ?Position,\n    props: ModeProps<FeatureCollection>\n  ): EditHandle[] {\n    let handles = [];\n    const { features } = props.data;\n\n    for (const index of props.selectedIndexes) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index));\n      } else {\n        console.warn(`selectedFeatureIndexes out of range ${index}`); // eslint-disable-line no-console,no-undef\n      }\n    }\n\n    // intermediate edit handle\n    if (picks && picks.length && mapCoords) {\n      const existingEditHandle = getPickedExistingEditHandle(picks);\n      // don't show intermediate point when too close to an existing edit handle\n      const featureAsPick = !existingEditHandle && picks.find(pick => !pick.isGuide);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        !featureAsPick.object.geometry.type.includes('Point') &&\n        props.selectedIndexes.includes(featureAsPick.index)\n      ) {\n        let intermediatePoint: ?NearestPointType = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(mapCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.nearestPointOnLine(\n              lineStringFeature,\n              referencePoint,\n              props.modeConfig && props.modeConfig.viewport\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index }\n          } = intermediatePoint;\n          handles = [\n            ...handles,\n            {\n              position,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n              featureIndex: featureAsPick.index,\n              type: 'intermediate'\n            }\n          ];\n        }\n      }\n    }\n\n    return handles;\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  nearestPointOnLine(\n    line: FeatureOf<LineString>,\n    inPoint: FeatureOf<Point>,\n    viewport: ?Viewport\n  ): NearestPointType {\n    const { coordinates } = line.geometry;\n    if (coordinates.some(coord => coord.length > 2)) {\n      if (viewport) {\n        // This line has elevation, we need to use alternative algorithm\n        return nearestPointOnProjectedLine(line, inPoint, viewport);\n      }\n      // eslint-disable-next-line no-console,no-undef\n      console.log(\n        'Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.'\n      );\n    }\n\n    return nearestPointOnLine(line, inPoint);\n  }\n\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    const pickedExistingHandle = getPickedExistingEditHandle(event.picks);\n    const pickedIntermediateHandle = getPickedIntermediateEditHandle(event.picks);\n\n    if (pickedExistingHandle) {\n      let updatedData;\n      try {\n        updatedData = new ImmutableFeatureCollection(props.data)\n          .removePosition(pickedExistingHandle.featureIndex, pickedExistingHandle.positionIndexes)\n          .getObject();\n      } catch (ignored) {\n        // This happens if user attempts to remove the last point\n      }\n\n      if (updatedData) {\n        editAction = {\n          updatedData,\n          editType: 'removePosition',\n          editContext: {\n            featureIndexes: [pickedExistingHandle.featureIndex],\n            positionIndexes: pickedExistingHandle.positionIndexes,\n            position: pickedExistingHandle.position\n          }\n        };\n      }\n    } else if (pickedIntermediateHandle) {\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .addPosition(\n          pickedIntermediateHandle.featureIndex,\n          pickedIntermediateHandle.positionIndexes,\n          pickedIntermediateHandle.position\n        )\n        .getObject();\n\n      if (updatedData) {\n        editAction = {\n          updatedData,\n          editType: 'addPosition',\n          editContext: {\n            featureIndexes: [pickedIntermediateHandle.featureIndex],\n            positionIndexes: pickedIntermediateHandle.positionIndexes,\n            position: pickedIntermediateHandle.position\n          }\n        };\n      }\n    }\n    return editAction;\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    let editAction: ?GeoJsonEditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.mapCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'movePosition',\n        editContext: {\n          featureIndexes: [editHandle.featureIndex],\n          positionIndexes: editHandle.positionIndexes,\n          position: event.mapCoords\n        }\n      };\n\n      props.onEdit(editAction);\n    }\n\n    const cursor = this.getCursor(event);\n    props.onUpdateCursor(cursor);\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n    if (cancelMapPan) {\n      event.sourceEvent.stopPropagation();\n    }\n  }\n\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const editHandle = getPickedIntermediateEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .addPosition(editHandle.featureIndex, editHandle.positionIndexes, event.mapCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        editContext: {\n          featureIndexes: [editHandle.featureIndex],\n          positionIndexes: editHandle.positionIndexes,\n          position: event.mapCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.mapCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'finishMovePosition',\n        editContext: {\n          featureIndexes: [editHandle.featureIndex],\n          positionIndexes: editHandle.positionIndexes,\n          position: event.mapCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  getCursor(event: PointerMoveEvent): ?string {\n    const picks = (event && event.picks) || [];\n\n    const handlesPicked = getPickedEditHandles(picks);\n    if (handlesPicked.length) {\n      return 'cell';\n    }\n    return null;\n  }\n}\n","// @flow\n\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfTransformTranslate from '@turf/transform-translate';\nimport { point } from '@turf/helpers';\nimport type { FeatureCollection, Position } from '../geojson-types.js';\nimport type {\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  ModeProps\n} from '../types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport class TranslateMode extends BaseGeoJsonEditMode {\n  _geometryBeforeTranslate: ?FeatureCollection;\n  _isTranslatable: boolean;\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    let editAction: ?GeoJsonEditAction = null;\n\n    this._isTranslatable =\n      Boolean(this._geometryBeforeTranslate) || this.isSelectionPicked(event.picks, props);\n\n    if (!this._isTranslatable || !event.pointerDownMapCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'translating',\n        props\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection(props);\n    return null;\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    if (this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'translated',\n        props\n      );\n      this._geometryBeforeTranslate = null;\n    }\n\n    return editAction;\n  }\n\n  getCursorAdapter(): ?string {\n    if (this._isTranslatable) {\n      return 'move';\n    }\n    return null;\n  }\n\n  getTranslateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    if (!this._geometryBeforeTranslate) {\n      return null;\n    }\n    const p1 = point(startDragPoint);\n    const p2 = point(currentPoint);\n\n    const distanceMoved = turfDistance(p1, p2);\n    const direction = turfBearing(p1, p2);\n\n    const movedFeatures = turfTransformTranslate(\n      this._geometryBeforeTranslate,\n      distanceMoved,\n      direction\n    );\n\n    let updatedData = new ImmutableFeatureCollection(props.data);\n\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = movedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      editContext: {\n        featureIndexes: selectedIndexes\n      }\n    };\n  }\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfDistance from '@turf/distance';\nimport turfTransformScale from '@turf/transform-scale';\nimport type { FeatureCollection, Position } from '../geojson-types.js';\nimport type {\n  ModeProps,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport class ScaleMode extends BaseGeoJsonEditMode {\n  _isScalable: boolean;\n  _geometryBeingScaled: ?FeatureCollection;\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    let editAction: ?GeoJsonEditAction = null;\n\n    this._isScalable =\n      Boolean(this._geometryBeingScaled) || this.isSelectionPicked(event.picks, props);\n\n    if (!this._isScalable || !event.pointerDownMapCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'scaling',\n        props\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    if (!this._isScalable) {\n      return null;\n    }\n\n    this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection(props);\n    return null;\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    if (this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'scaled',\n        props\n      );\n      this._geometryBeingScaled = null;\n    }\n\n    return editAction;\n  }\n\n  getCursorAdapter(): ?string {\n    if (this._isScalable) {\n      // TODO: look at doing SVG cursors to get a better \"scale\" cursor\n      return 'move';\n    }\n    return null;\n  }\n\n  getScaleAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ): GeoJsonEditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingScaled);\n    const factor = getScaleFactor(centroid, startPosition, currentPoint);\n    const scaledFeatures = turfTransformScale(this._geometryBeingScaled, factor, {\n      origin: centroid\n    });\n\n    let updatedData = new ImmutableFeatureCollection(props.data);\n\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = scaledFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      editContext: {\n        featureIndexes: selectedIndexes\n      }\n    };\n  }\n}\n\nfunction getScaleFactor(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const startDistance = turfDistance(centroid, startDragPoint);\n  const endDistance = turfDistance(centroid, currentPoint);\n  return endDistance / startDistance;\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport turfTransformRotate from '@turf/transform-rotate';\nimport type {\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  ModeProps\n} from '../types.js';\nimport type { FeatureCollection, Position } from '../geojson-types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport class RotateMode extends BaseGeoJsonEditMode {\n  _isRotatable: boolean;\n  _geometryBeingRotated: ?FeatureCollection;\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    let editAction: ?GeoJsonEditAction = null;\n\n    this._isRotatable =\n      Boolean(this._geometryBeingRotated) || this.isSelectionPicked(event.picks, props);\n\n    if (!this._isRotatable || !event.pointerDownMapCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'rotating',\n        props\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    if (!this._isRotatable) {\n      return null;\n    }\n\n    this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection(props);\n    return null;\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    if (this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'rotated',\n        props\n      );\n      this._geometryBeingRotated = null;\n    }\n\n    return editAction;\n  }\n\n  getCursorAdapter(): ?string {\n    if (this._isRotatable) {\n      // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n      return 'move';\n    }\n    return null;\n  }\n\n  getRotateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ): GeoJsonEditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingRotated);\n    const angle = getRotationAngle(centroid, startPosition, currentPoint);\n\n    const rotatedFeatures = turfTransformRotate(this._geometryBeingRotated, angle);\n\n    let updatedData = new ImmutableFeatureCollection(props.data);\n\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = rotatedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      editContext: {\n        featureIndexes: selectedIndexes\n      }\n    };\n  }\n}\n\nfunction getRotationAngle(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const bearing1 = turfBearing(centroid, startDragPoint);\n  const bearing2 = turfBearing(centroid, currentPoint);\n  return bearing2 - bearing1;\n}\n","// @flow\n\nimport type { StartDraggingEvent, ModeProps } from '../types.js';\nimport type { FeatureCollection } from '../geojson-types.js';\nimport type { GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { TranslateMode } from './translate-mode.js';\n\nexport class DuplicateMode extends TranslateMode {\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection(props);\n\n    return this._geometryBeforeTranslate\n      ? this.getAddManyFeaturesAction(this._geometryBeforeTranslate, props.data)\n      : null;\n  }\n\n  getCursorAdapter(): ?string {\n    if (this._isTranslatable) {\n      return 'copy';\n    }\n    return null;\n  }\n}\n","// @flow\n\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport turfDifference from '@turf/difference';\nimport turfBuffer from '@turf/buffer';\nimport lineIntersect from '@turf/line-intersect';\nimport { lineString } from '@turf/helpers';\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfDestination from '@turf/destination';\nimport turfPolygonToLine from '@turf/polygon-to-line';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { generatePointsParallelToLinePoints } from '../utils.js';\nimport type { FeatureCollection } from '../geojson-types.js';\nimport type { ClickEvent, PointerMoveEvent, ModeProps } from '../types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport class SplitPolygonMode extends BaseGeoJsonEditMode {\n  calculateMapCoords(clickSequence: any, mapCoords: any, props: ModeProps<FeatureCollection>) {\n    const modeConfig = props.modeConfig;\n    if (!modeConfig || !modeConfig.lock90Degree || !clickSequence.length) {\n      return mapCoords;\n    }\n    if (clickSequence.length === 1) {\n      // if first point is clicked, then find closest polygon point and build ~90deg vector\n      const firstPoint = clickSequence[0];\n      const selectedGeometry = this.getSelectedGeometry(props);\n      const feature = turfPolygonToLine(selectedGeometry);\n\n      const lines = feature.type === 'FeatureCollection' ? feature.features : [feature];\n      let minDistance = Number.MAX_SAFE_INTEGER;\n      let closestPoint = null;\n      // If Multipolygon, then we should find nearest polygon line and stick split to it.\n      lines.forEach(line => {\n        const snapPoint = nearestPointOnLine(line, firstPoint);\n        const distanceFromOrigin = turfDistance(snapPoint, firstPoint);\n        if (minDistance > distanceFromOrigin) {\n          minDistance = distanceFromOrigin;\n          closestPoint = snapPoint;\n        }\n      });\n\n      if (closestPoint) {\n        // closest point is used as 90degree entry to the polygon\n        const lastBearing = turfBearing(firstPoint, closestPoint);\n        const currentDistance = turfDistance(firstPoint, mapCoords, { units: 'meters' });\n        return turfDestination(firstPoint, currentDistance, lastBearing, {\n          units: 'meters'\n        }).geometry.coordinates;\n      }\n      return mapCoords;\n    }\n    // Allow only 90 degree turns\n    const lastPoint = clickSequence[clickSequence.length - 1];\n    const [approximatePoint] = generatePointsParallelToLinePoints(\n      clickSequence[clickSequence.length - 2],\n      lastPoint,\n      mapCoords\n    );\n    // align point with current ground\n    const nearestPt = nearestPointOnLine(lineString([lastPoint, approximatePoint]), mapCoords)\n      .geometry.coordinates;\n    return nearestPt;\n  }\n\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    super.handleClickAdapter(\n      {\n        ...event,\n        mapCoords: this.calculateMapCoords(this.getClickSequence(), event.mapCoords, props)\n      },\n      props\n    );\n    const editAction: ?GeoJsonEditAction = null;\n    const tentativeFeature = this.getTentativeFeature();\n    const selectedGeometry = this.getSelectedGeometry(props);\n    const clickSequence = this.getClickSequence();\n\n    if (!selectedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('A polygon must be selected for splitting');\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n    const pt = {\n      type: 'Point',\n      coordinates: clickSequence[clickSequence.length - 1]\n    };\n    const isPointInPolygon = booleanPointInPolygon(pt, selectedGeometry);\n    if (clickSequence.length > 1 && tentativeFeature && !isPointInPolygon) {\n      this.resetClickSequence();\n      const isLineInterectingWithPolygon = lineIntersect(tentativeFeature, selectedGeometry);\n      if (isLineInterectingWithPolygon.features.length === 0) {\n        this._setTentativeFeature(null);\n        return editAction;\n      }\n      return this.splitPolygon(props);\n    }\n\n    return editAction;\n  }\n\n  handlePointerMoveAdapter(\n    { mapCoords }: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    this._setTentativeFeature({\n      type: 'Feature',\n      geometry: {\n        type: 'LineString',\n        coordinates: [...clickSequence, this.calculateMapCoords(clickSequence, mapCoords, props)]\n      }\n    });\n\n    return result;\n  }\n\n  splitPolygon(props: ModeProps<FeatureCollection>) {\n    const selectedGeometry = this.getSelectedGeometry(props);\n    const tentativeFeature = this.getTentativeFeature();\n    const featureIndex = props.selectedIndexes[0];\n    const modeConfig = props.modeConfig || {};\n\n    // Default gap in between the polygon\n    let { gap = 0.1, units = 'centimeters' } = modeConfig;\n    if (gap === 0) {\n      gap = 0.1;\n      units = 'centimeters';\n    }\n\n    const buffer = turfBuffer(tentativeFeature, gap, { units });\n    const updatedGeometry = turfDifference(selectedGeometry, buffer);\n    this._setTentativeFeature(null);\n    if (!updatedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('Canceling edit. Split Polygon erased');\n      return null;\n    }\n\n    const { type, coordinates } = updatedGeometry.geometry;\n    let updatedCoordinates = [];\n    if (type === 'Polygon') {\n      // Update the coordinates as per Multipolygon\n      updatedCoordinates = coordinates.map(c => [c]);\n    } else {\n      // Handle Case when Multipolygon has holes\n      updatedCoordinates = coordinates.reduce((agg, prev) => {\n        prev.forEach(p => {\n          agg.push([p]);\n        });\n        return agg;\n      }, []);\n    }\n\n    // Update the type to Mulitpolygon\n    const updatedData = new ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, {\n      type: 'MultiPolygon',\n      coordinates: updatedCoordinates\n    });\n\n    const editAction: GeoJsonEditAction = {\n      updatedData: updatedData.getObject(),\n      editType: 'split',\n      editContext: {\n        featureIndexes: [featureIndex]\n      }\n    };\n\n    return editAction;\n  }\n}\n","// @flow\n\nimport bearing from '@turf/bearing';\nimport { generatePointsParallelToLinePoints } from '../utils.js';\nimport type { FeatureCollection } from '../geojson-types.js';\nimport type {\n  ModeProps,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../types.js';\nimport { getPickedEditHandle, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ModifyMode } from './modify-mode.js';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport class ExtrudeMode extends ModifyMode {\n  isPointAdded: boolean = false;\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    let editAction: ?GeoJsonEditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const size = this.coordinatesSize(\n        editHandle.positionIndexes,\n        editHandle.featureIndex,\n        props.data\n      );\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(\n        positionIndexes,\n        editHandle.featureIndex,\n        props.data\n      );\n      if (p1 && p2) {\n        // p3 and p4 are end points for moving (extruding) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.mapCoords);\n\n        const updatedData = new ImmutableFeatureCollection(props.data)\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruding',\n          editContext: {\n            featureIndexes: [editHandle.featureIndex],\n            positionIndexes: this.nextPositionIndexes(editHandle.positionIndexes, size),\n            position: p3\n          }\n        };\n\n        props.onEdit(editAction);\n      }\n    }\n\n    const cursor = this.getCursor(event);\n    props.onUpdateCursor(cursor);\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n    if (cancelMapPan) {\n      event.sourceEvent.stopPropagation();\n    }\n  }\n\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle && editHandle.type === 'intermediate') {\n      const size = this.coordinatesSize(\n        editHandle.positionIndexes,\n        editHandle.featureIndex,\n        props.data\n      );\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(editHandle.positionIndexes, size),\n        editHandle.featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(\n        editHandle.positionIndexes,\n        editHandle.featureIndex,\n        props.data\n      );\n\n      if (p1 && p2) {\n        let updatedData = new ImmutableFeatureCollection(props.data);\n        if (\n          !this.isOrthogonal(editHandle.positionIndexes, editHandle.featureIndex, size, props.data)\n        ) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p2\n          );\n        }\n        if (\n          !this.isOrthogonal(\n            this.prevPositionIndexes(editHandle.positionIndexes, size),\n            editHandle.featureIndex,\n            size,\n            props.data\n          )\n        ) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p1\n          );\n          this.isPointAdded = true;\n        }\n\n        editAction = {\n          updatedData: updatedData.getObject(),\n          editType: 'startExtruding',\n          editContext: {\n            featureIndexes: [editHandle.featureIndex],\n            positionIndexes: editHandle.positionIndexes,\n            position: p1\n          }\n        };\n      }\n    }\n\n    return editAction;\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    let editAction: ?GeoJsonEditAction = null;\n\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const size = this.coordinatesSize(\n        editHandle.positionIndexes,\n        editHandle.featureIndex,\n        props.data\n      );\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(\n        positionIndexes,\n        editHandle.featureIndex,\n        props.data\n      );\n\n      if (p1 && p2) {\n        // p3 and p4 are end points for new moved (extruded) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.mapCoords);\n\n        const updatedData = new ImmutableFeatureCollection(props.data)\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruded',\n          editContext: {\n            featureIndexes: [editHandle.featureIndex],\n            positionIndexes: editHandle.positionIndexes,\n            position: p3\n          }\n        };\n      }\n    }\n    this.isPointAdded = false;\n\n    return editAction;\n  }\n\n  coordinatesSize(\n    positionIndexes: number[],\n    featureIndex: number,\n    { features }: FeatureCollection\n  ) {\n    let size = 0;\n    const feature = features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        size = coordinates[a][b].length;\n      }\n    } else {\n      const [b] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        size = coordinates[b].length;\n      }\n    }\n    return size;\n  }\n\n  getBearing(p1: any, p2: any) {\n    const angle = bearing(p1, p2);\n    if (angle < 0) {\n      return Math.floor(360 + angle);\n    }\n    return Math.floor(angle);\n  }\n\n  isOrthogonal(\n    positionIndexes: number[],\n    featureIndex: number,\n    size: number,\n    features: FeatureCollection\n  ) {\n    if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n      positionIndexes[positionIndexes.length - 1] = 0;\n    }\n    const prevPoint = this.getPointForPositionIndexes(\n      this.prevPositionIndexes(positionIndexes, size),\n      featureIndex,\n      features\n    );\n    const nextPoint = this.getPointForPositionIndexes(\n      this.nextPositionIndexes(positionIndexes, size),\n      featureIndex,\n      features\n    );\n    const currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex, features);\n    const prevAngle = this.getBearing(currentPoint, prevPoint);\n    const nextAngle = this.getBearing(currentPoint, nextPoint);\n    return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n  }\n\n  nextPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const next = [...positionIndexes];\n    if (next.length) {\n      next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n    }\n    return next;\n  }\n\n  prevPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const prev = [...positionIndexes];\n    if (prev.length) {\n      prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n    }\n    return prev;\n  }\n\n  getPointForPositionIndexes(\n    positionIndexes: number[],\n    featureIndex: number,\n    { features }: FeatureCollection\n  ) {\n    let p1;\n    const feature = features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b, c] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        p1 = coordinates[a][b][c];\n      }\n    } else {\n      const [b, c] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        p1 = coordinates[b][c];\n      }\n    }\n    return p1;\n  }\n}\n","// @flow\nimport type { ModeProps, PointerMoveEvent, StopDraggingEvent } from '../types.js';\nimport type { Position, FeatureCollection } from '../geojson-types.js';\nimport { getPickedEditHandle, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ModifyMode } from './modify-mode.js';\n\nfunction defaultCalculateElevationChange({\n  pointerDownScreenCoords,\n  screenCoords\n}: {\n  pointerDownScreenCoords: Position,\n  screenCoords: Position\n}) {\n  return 10 * (pointerDownScreenCoords[1] - screenCoords[1]);\n}\n\nexport class ElevationMode extends ModifyMode {\n  makeElevatedEvent(\n    event: PointerMoveEvent | StopDraggingEvent,\n    position: Position,\n    props: ModeProps<FeatureCollection>\n  ): Object {\n    const {\n      minElevation = 0,\n      maxElevation = 20000,\n      calculateElevationChange = defaultCalculateElevationChange\n    } =\n      props.modeConfig || {};\n\n    if (!event.pointerDownScreenCoords) {\n      return event;\n    }\n\n    // $FlowFixMe - really, I know it has something at index 2\n    let elevation = position.length === 3 ? position[2] : 0;\n\n    // calculateElevationChange is configurable because (at this time) modes are not aware of the viewport\n    elevation += calculateElevationChange({\n      pointerDownScreenCoords: event.pointerDownScreenCoords,\n      screenCoords: event.screenCoords\n    });\n    elevation = Math.min(elevation, maxElevation);\n    elevation = Math.max(elevation, minElevation);\n\n    return Object.assign({}, event, {\n      mapCoords: [position[0], position[1], elevation]\n    });\n  }\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n    const position = editHandle ? editHandle.position : event.mapCoords;\n    return super.handlePointerMoveAdapter(this.makeElevatedEvent(event, position, props), props);\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    const editHandle = getPickedEditHandle(event.picks);\n    const position = editHandle ? editHandle.position : event.mapCoords;\n    return super.handleStopDraggingAdapter(this.makeElevatedEvent(event, position, props), props);\n  }\n\n  getCursor(event: PointerMoveEvent): ?string {\n    let cursor = super.getCursor(event);\n    if (cursor === 'cell') {\n      cursor = 'ns-resize';\n    }\n    return cursor;\n  }\n\n  static calculateElevationChangeWithViewport(\n    viewport: any,\n    {\n      pointerDownScreenCoords,\n      screenCoords\n    }: {\n      pointerDownScreenCoords: Position,\n      screenCoords: Position\n    }\n  ): number {\n    // Source: https://gis.stackexchange.com/a/127949/111804\n    const metersPerPixel =\n      (156543.03392 * Math.cos((viewport.latitude * Math.PI) / 180)) / Math.pow(2, viewport.zoom);\n\n    return (metersPerPixel * (pointerDownScreenCoords[1] - screenCoords[1])) / 2;\n  }\n}\n","// @flow\n\nimport type { ClickEvent, ModeProps } from '../types.js';\nimport type { FeatureCollection } from '../geojson-types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\n\nexport class DrawPointMode extends BaseGeoJsonEditMode {\n  handleClickAdapter(\n    { mapCoords }: ClickEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    const geometry = {\n      type: 'Point',\n      coordinates: mapCoords\n    };\n\n    return this.getAddFeatureAction(geometry, props.data);\n  }\n\n  getCursorAdapter() {\n    return 'cell';\n  }\n}\n","// @flow\n\nimport type { Position, LineString, FeatureCollection } from '../geojson-types.js';\nimport type { ClickEvent, PointerMoveEvent, ModeProps } from '../types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport class DrawLineStringMode extends BaseGeoJsonEditMode {\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    super.handleClickAdapter(event, props);\n\n    let editAction: ?GeoJsonEditAction = null;\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const selectedGeometry = this.getSelectedGeometry(props);\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      console.warn(`drawLineString mode only supported for single LineString selection`); // eslint-disable-line\n      this.resetClickSequence();\n      return null;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Extend the LineString\n      const lineString: LineString = selectedGeometry;\n\n      let positionIndexes = [lineString.coordinates.length];\n\n      const modeConfig = props.modeConfig;\n      if (modeConfig && modeConfig.drawAtFront) {\n        positionIndexes = [0];\n      }\n      const featureIndex = selectedFeatureIndexes[0];\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .addPosition(featureIndex, positionIndexes, event.mapCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        editContext: {\n          featureIndexes: [featureIndex],\n          positionIndexes,\n          position: event.mapCoords\n        }\n      };\n\n      this.resetClickSequence();\n    } else if (clickSequence.length === 2 && tentativeFeature) {\n      // Add a new LineString\n      const geometry: any = tentativeFeature.geometry;\n      editAction = this.getAddFeatureAction(geometry, props.data);\n\n      this.resetClickSequence();\n    }\n\n    return editAction;\n  }\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n\n    const clickSequence = this.getClickSequence();\n    const mapCoords = event.mapCoords;\n\n    let startPosition: ?Position = null;\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const selectedGeometry = this.getSelectedGeometry(props);\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      // unsupported\n      return result;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Draw an extension line starting from one end of the selected LineString\n      startPosition = selectedGeometry.coordinates[selectedGeometry.coordinates.length - 1];\n\n      const modeConfig = props.modeConfig;\n      if (modeConfig && modeConfig.drawAtFront) {\n        startPosition = selectedGeometry.coordinates[0];\n      }\n    } else if (clickSequence.length === 1) {\n      startPosition = clickSequence[0];\n    }\n\n    if (startPosition) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: {\n          type: 'LineString',\n          coordinates: [startPosition, mapCoords]\n        }\n      });\n    }\n\n    return result;\n  }\n\n  getCursorAdapter() {\n    return 'cell';\n  }\n}\n","// @flow\n\nimport type { ClickEvent, PointerMoveEvent, ModeProps } from '../types.js';\nimport type { Polygon, Position, FeatureCollection } from '../geojson-types.js';\nimport type { GeoJsonEditAction, EditHandle } from './geojson-edit-mode.js';\nimport {\n  BaseGeoJsonEditMode,\n  getPickedEditHandle,\n  getEditHandlesForGeometry\n} from './geojson-edit-mode.js';\n\nexport class DrawPolygonMode extends BaseGeoJsonEditMode {\n  getEditHandlesAdapter(\n    picks: ?Array<Object>,\n    mapCoords: ?Position,\n    props: ModeProps<FeatureCollection>\n  ): EditHandle[] {\n    let handles = super.getEditHandlesAdapter(picks, mapCoords, props);\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    super.handleClickAdapter(event, props);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?GeoJsonEditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (clickedEditHandle) {\n      // User clicked an edit handle.\n      // Remove it from the click sequence, so it isn't added as a new point.\n      const clickSequence = this.getClickSequence();\n      clickSequence.splice(clickSequence.length - 1, 1);\n    }\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n\n        // Remove the hovered position\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: [[...polygon.coordinates[0].slice(0, -2), polygon.coordinates[0][0]]]\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      mapCoords: event.mapCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownMapCoords: null,\n      sourceEvent: null\n    };\n\n    this.handlePointerMoveAdapter(fakePointerMoveEvent, props);\n\n    return editAction;\n  }\n\n  handlePointerMoveAdapter(\n    { mapCoords }: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, mapCoords]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, mapCoords, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n\n  getCursorAdapter() {\n    return 'cell';\n  }\n}\n","// @flow\n\nimport type { ClickEvent, ModeProps } from '../types.js';\nimport type { FeatureCollection } from '../geojson-types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\n\nexport class TwoClickPolygonMode extends BaseGeoJsonEditMode {\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    super.handleClickAdapter(event, props);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 1 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry, props);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n\n  getCursorAdapter() {\n    return 'cell';\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport type { PointerMoveEvent } from '../types.js';\nimport { type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { TwoClickPolygonMode } from './two-click-polygon-mode.js';\n\nexport class DrawRectangleMode extends TwoClickPolygonMode {\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.mapCoords;\n    this._setTentativeFeature(bboxPolygon([corner1[0], corner1[1], corner2[0], corner2[1]]));\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent, ModeProps } from '../types.js';\nimport type { FeatureCollection } from '../geojson-types.js';\nimport { getIntermediatePosition, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { TwoClickPolygonMode } from './two-click-polygon-mode.js';\n\nexport class DrawCircleByBoundingBoxMode extends TwoClickPolygonMode {\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = props.modeConfig || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const firstClickedPoint = clickSequence[0];\n    const centerCoordinates = getIntermediatePosition(firstClickedPoint, event.mapCoords);\n    const radius = Math.max(distance(firstClickedPoint, centerCoordinates), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent, ModeProps } from '../types.js';\nimport { type FeatureCollection } from '../geojson-types.js';\nimport { type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { TwoClickPolygonMode } from './two-click-polygon-mode.js';\n\nexport class DrawCircleFromCenterMode extends TwoClickPolygonMode {\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = props.modeConfig || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const centerCoordinates = clickSequence[0];\n    const radius = Math.max(distance(centerCoordinates, event.mapCoords), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../types.js';\nimport { getIntermediatePosition, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { TwoClickPolygonMode } from './two-click-polygon-mode.js';\n\nexport class DrawEllipseByBoundingBoxMode extends TwoClickPolygonMode {\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.mapCoords;\n\n    const minX = Math.min(corner1[0], corner2[0]);\n    const minY = Math.min(corner1[1], corner2[1]);\n    const maxX = Math.max(corner1[0], corner2[0]);\n    const maxY = Math.max(corner1[1], corner2[1]);\n\n    const polygonPoints = bboxPolygon([minX, minY, maxX, maxY]).geometry.coordinates[0];\n    const centerCoordinates = getIntermediatePosition(corner1, corner2);\n\n    const xSemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[1])), 0.001);\n    const ySemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[3])), 0.001);\n\n    this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis));\n\n    return result;\n  }\n}\n","// @flow\n\nimport type { ClickEvent, ModeProps } from '../types.js';\nimport type { FeatureCollection } from '../geojson-types.js';\nimport { BaseGeoJsonEditMode, type GeoJsonEditAction } from './geojson-edit-mode.js';\n\nexport class ThreeClickPolygonMode extends BaseGeoJsonEditMode {\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    super.handleClickAdapter(event, props);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 2 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry, props);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n\n  getCursorAdapter() {\n    return 'cell';\n  }\n}\n","// @flow\n\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport bearing from '@turf/bearing';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../types.js';\nimport { getIntermediatePosition, type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ThreeClickPolygonMode } from './three-click-polygon-mode.js';\n\nexport class DrawEllipseUsingThreePointsMode extends ThreeClickPolygonMode {\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const mapCoords = event.mapCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], mapCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const [p1, p2] = clickSequence;\n\n      const centerCoordinates = getIntermediatePosition(p1, p2);\n      const xSemiAxis = Math.max(distance(centerCoordinates, point(mapCoords)), 0.001);\n      const ySemiAxis = Math.max(distance(p1, p2), 0.001) / 2;\n      const options = { angle: bearing(p1, p2) };\n\n      this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis, options));\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { LineString } from '../geojson-types.js';\nimport type { PointerMoveEvent } from '../types.js';\nimport { type GeoJsonEditAction } from './geojson-edit-mode.js';\nimport { ThreeClickPolygonMode } from './three-click-polygon-mode.js';\n\nexport class DrawRectangleUsingThreePointsMode extends ThreeClickPolygonMode {\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const mapCoords = event.mapCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], mapCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const lineString: LineString = {\n        type: 'LineString',\n        coordinates: clickSequence\n      };\n      const [p1, p2] = clickSequence;\n      const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, mapCoords);\n\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [\n            [\n              // Draw a polygon containing all the points of the LineString,\n              // then the points orthogonal to the lineString,\n              // then back to the starting position\n              ...lineString.coordinates,\n              p3,\n              p4,\n              p1\n            ]\n          ]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport lineIntersect from '@turf/line-intersect';\nimport turfDistance from '@turf/distance';\nimport { point, lineString } from '@turf/helpers';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { ClickEvent, PointerMoveEvent, ModeProps } from '../types.js';\nimport type { Polygon, Position, FeatureCollection } from '../geojson-types.js';\nimport {\n  BaseGeoJsonEditMode,\n  getPickedEditHandle,\n  getEditHandlesForGeometry,\n  type GeoJsonEditAction,\n  type EditHandle\n} from './geojson-edit-mode.js';\n\nexport class Draw90DegreePolygonMode extends BaseGeoJsonEditMode {\n  getEditHandlesAdapter(\n    picks: ?Array<Object>,\n    mapCoords: ?Position,\n    props: ModeProps<FeatureCollection>\n  ): EditHandle[] {\n    let handles = super.getEditHandlesAdapter(picks, mapCoords, props);\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handlePointerMoveAdapter({\n    mapCoords\n  }: PointerMoveEvent): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[0][clickSequence.length - 1];\n    } else if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[clickSequence.length - 1];\n    }\n\n    let p3;\n    if (clickSequence.length === 1) {\n      p3 = mapCoords;\n    } else {\n      const p1 = clickSequence[clickSequence.length - 2];\n      const p2 = clickSequence[clickSequence.length - 1];\n      [p3] = generatePointsParallelToLinePoints(p1, p2, mapCoords);\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, p3]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, p3, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n\n  handleClickAdapter(event: ClickEvent, props: ModeProps<FeatureCollection>): ?GeoJsonEditAction {\n    super.handleClickAdapter(event, props);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?GeoJsonEditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: this.finalizedCoordinates([...polygon.coordinates[0]])\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd, props);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      mapCoords: event.mapCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownMapCoords: null,\n      sourceEvent: null\n    };\n    this.handlePointerMoveAdapter(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  finalizedCoordinates(coords: Position[]) {\n    // Remove the hovered position\n    let coordinates = [[...coords.slice(0, -2), coords[0]]];\n    let pt = this.getIntermediatePoint([...coords]);\n    if (!pt) {\n      // if intermediate point with 90 degree not available\n      // try remove the last clicked point and get the intermediate point.\n      const tc = [...coords];\n      tc.splice(-3, 1);\n      pt = this.getIntermediatePoint([...tc]);\n      if (pt) {\n        coordinates = [[...coords.slice(0, -3), pt, coords[0]]];\n      }\n    } else {\n      coordinates = [[...coords.slice(0, -2), pt, coords[0]]];\n    }\n    return coordinates;\n  }\n\n  getIntermediatePoint(coordinates: Position[]) {\n    let pt;\n    if (coordinates.length > 4) {\n      const [p1, p2] = [...coordinates];\n      const angle1 = bearing(p1, p2);\n      const p3 = coordinates[coordinates.length - 3];\n      const p4 = coordinates[coordinates.length - 4];\n      const angle2 = bearing(p3, p4);\n\n      const angles = { first: [], second: [] };\n      // calculate 3 right angle points for first and last points in lineString\n      [1, 2, 3].forEach(factor => {\n        const newAngle1 = angle1 + factor * 90;\n        // convert angles to 0 to -180 for anti-clock and 0 to 180 for clock wise\n        angles.first.push(newAngle1 > 180 ? newAngle1 - 360 : newAngle1);\n        const newAngle2 = angle2 + factor * 90;\n        angles.second.push(newAngle2 > 180 ? newAngle2 - 360 : newAngle2);\n      });\n\n      const distance = turfDistance(point(p1), point(p3));\n      // Draw imaginary right angle lines for both first and last points in lineString\n      // If there is intersection point for any 2 lines, will be the 90 degree point.\n      [0, 1, 2].forEach(indexFirst => {\n        const line1 = lineString([\n          p1,\n          destination(p1, distance, angles.first[indexFirst]).geometry.coordinates\n        ]);\n        [0, 1, 2].forEach(indexSecond => {\n          const line2 = lineString([\n            p3,\n            destination(p3, distance, angles.second[indexSecond]).geometry.coordinates\n          ]);\n          const fc = lineIntersect(line1, line2);\n          if (fc && fc.features.length) {\n            // found the intersect point\n            pt = fc.features[0].geometry.coordinates;\n          }\n        });\n      });\n    }\n    return pt;\n  }\n\n  getCursorAdapter() {\n    return 'cell';\n  }\n}\n","// @flow\n\nimport { BaseGeoJsonEditMode } from './geojson-edit-mode.js';\n\nexport class ViewMode extends BaseGeoJsonEditMode {}\n","// @flow\n\nimport type { FeatureCollection, Feature, Position } from '../geojson-types.js';\nimport type {\n  ModeProps,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../types.js';\nimport { BaseGeoJsonEditMode, type EditHandle } from './geojson-edit-mode.js';\n\nexport class CompositeMode extends BaseGeoJsonEditMode {\n  handlers: Array<BaseGeoJsonEditMode>;\n  options: Object;\n\n  constructor(handlers: Array<BaseGeoJsonEditMode>, options: Object = {}) {\n    super();\n    this.handlers = handlers;\n    this.options = options;\n  }\n\n  _coalesce<T>(callback: BaseGeoJsonEditMode => T, resultEval: ?(T) => boolean = null): T {\n    let result: T;\n\n    for (let i = 0; i < this.handlers.length; i++) {\n      result = callback(this.handlers[i]);\n      if (resultEval ? resultEval(result) : result) {\n        break;\n      }\n    }\n\n    return (result: any);\n  }\n\n  handleClick(event: ClickEvent, props: ModeProps<FeatureCollection>): void {\n    this._coalesce(handler => handler.handleClick(event, props));\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    return this._coalesce(handler => handler.handlePointerMove(event, props));\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>): void {\n    return this._coalesce(handler => handler.handleStartDragging(event, props));\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>): void {\n    return this._coalesce(handler => handler.handleStopDragging(event, props));\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._coalesce(handler => handler.getTentativeFeature());\n  }\n\n  getEditHandlesAdapter(\n    picks: ?Array<Object>,\n    mapCoords: ?Position,\n    props: ModeProps<FeatureCollection>\n  ): EditHandle[] {\n    // TODO: Combine the handles *BUT* make sure if none of the results have\n    // changed to return the same object so that \"editHandles !== this.state.editHandles\"\n    // in editable-geojson-layer works.\n    return this._coalesce(\n      handler => handler.getEditHandlesAdapter(picks, mapCoords, props),\n      handles => Array.isArray(handles) && handles.length > 0\n    );\n  }\n\n  getCursorAdapter(props: ModeProps<FeatureCollection>): ?string {\n    return this._coalesce(handler => handler.getCursorAdapter(props));\n  }\n}\n","// @flow\n\nimport type { Feature, FeatureCollection, Position } from '../geojson-types.js';\nimport type {\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  ModeProps\n} from '../types.js';\nimport type { EditHandle, GeoJsonEditAction } from './geojson-edit-mode.js';\nimport {\n  BaseGeoJsonEditMode,\n  getPickedEditHandle,\n  getPickedEditHandles,\n  getEditHandlesForGeometry\n} from './geojson-edit-mode.js';\n\ntype HandlePicks = { pickedHandle?: EditHandle, potentialSnapHandle?: EditHandle };\n\nexport class SnappableMode extends BaseGeoJsonEditMode {\n  _handler: BaseGeoJsonEditMode;\n  _editHandlePicks: ?HandlePicks;\n  _startDragSnapHandlePosition: Position;\n\n  constructor(handler: BaseGeoJsonEditMode) {\n    super();\n    this._handler = handler;\n  }\n\n  _getSnappedMouseEvent(event: Object, snapPoint: Position): PointerMoveEvent {\n    return Object.assign({}, event, {\n      mapCoords: snapPoint,\n      pointerDownMapCoords: this._startDragSnapHandlePosition\n    });\n  }\n\n  _getEditHandlePicks(event: PointerMoveEvent): HandlePicks {\n    const { picks } = event;\n\n    const potentialSnapHandle = getPickedEditHandles(picks).find(\n      handle => handle.type === 'intermediate'\n    );\n    const handles = { potentialSnapHandle };\n\n    const pickedHandle = getPickedEditHandle(event.pointerDownPicks);\n    if (pickedHandle) {\n      return { ...handles, pickedHandle };\n    }\n\n    return handles;\n  }\n\n  _updatePickedHandlePosition(editAction: GeoJsonEditAction) {\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle && editAction) {\n      const { editContext, updatedData } = editAction;\n      const { featureIndexes } = editContext;\n\n      for (let i = 0; i < featureIndexes.length; i++) {\n        const selectedIndex = featureIndexes[i];\n        const updatedFeature = updatedData.features[selectedIndex];\n\n        const { positionIndexes, featureIndex } = pickedHandle;\n        if (selectedIndex >= 0 && featureIndex === selectedIndex) {\n          const { coordinates } = updatedFeature.geometry;\n          // $FlowFixMe\n          pickedHandle.position = positionIndexes.reduce(\n            (a: any[], b: number) => a[b],\n            coordinates\n          );\n        }\n      }\n    }\n  }\n\n  // If additionalSnapTargets is present in modeConfig and is populated, this\n  // method will return those features along with the features\n  // that live in the current layer. Otherwise, this method will simply return the\n  // features from the current layer\n  _getSnapTargets(props: ModeProps<FeatureCollection>): Feature[] {\n    let { additionalSnapTargets } = props.modeConfig || {};\n    additionalSnapTargets = additionalSnapTargets || [];\n\n    const features = [...props.data.features, ...additionalSnapTargets];\n    return features;\n  }\n\n  _getNonPickedIntermediateHandles(props: ModeProps<FeatureCollection>): EditHandle[] {\n    const handles = [];\n    const features = this._getSnapTargets(props);\n\n    for (let i = 0; i < features.length; i++) {\n      // Filter out the currently selected feature(s)\n      const isCurrentIndexFeatureNotSelected = !props.selectedIndexes.includes(i);\n\n      if (isCurrentIndexFeatureNotSelected) {\n        const { geometry } = features[i];\n        handles.push(...getEditHandlesForGeometry(geometry, i, 'intermediate'));\n      }\n    }\n    return handles;\n  }\n\n  // If no snap handle has been picked, only display the edit handles of the\n  // selected feature. If a snap handle has been picked, display said snap handle\n  // along with all snappable points on all non-selected features.\n  getEditHandlesAdapter(\n    picks: ?Array<Object>,\n    mapCoords: ?Position,\n    props: ModeProps<FeatureCollection>\n  ): any[] {\n    const { enableSnapping } = props.modeConfig || {};\n    const handles = [...this._handler.getEditHandlesAdapter(picks, mapCoords, props)];\n\n    if (!enableSnapping) return handles;\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle) {\n      handles.push(...this._getNonPickedIntermediateHandles(props), pickedHandle);\n      return handles;\n    }\n\n    const { features } = props.data;\n    for (const index of props.selectedIndexes) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index, 'snap'));\n      }\n    }\n\n    return handles.filter(Boolean);\n  }\n\n  _getSnapAwareEvent(event: Object): Object {\n    const { potentialSnapHandle } = this._editHandlePicks || {};\n\n    return potentialSnapHandle && potentialSnapHandle.position\n      ? this._getSnappedMouseEvent(event, potentialSnapHandle.position)\n      : event;\n  }\n\n  handleStartDraggingAdapter(\n    event: StartDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    this._startDragSnapHandlePosition = (getPickedEditHandle(event.picks) || {}).position;\n    return this._handler.handleStartDraggingAdapter(event, props);\n  }\n\n  handleStopDraggingAdapter(\n    event: StopDraggingEvent,\n    props: ModeProps<FeatureCollection>\n  ): ?GeoJsonEditAction {\n    const modeActionSummary = this._handler.handleStopDraggingAdapter(\n      this._getSnapAwareEvent(event),\n      props\n    );\n\n    this._editHandlePicks = null;\n    return modeActionSummary;\n  }\n\n  getCursorAdapter(props: ModeProps<FeatureCollection>): ?string {\n    return this._handler.getCursorAdapter(props);\n  }\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent,\n    props: ModeProps<FeatureCollection>\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const { enableSnapping } = props.modeConfig || {};\n\n    if (enableSnapping) {\n      this._editHandlePicks = this._getEditHandlePicks(event);\n    }\n\n    const modeActionSummary = this._handler.handlePointerMoveAdapter(\n      this._getSnapAwareEvent(event),\n      props\n    );\n    const { editAction } = modeActionSummary;\n    if (editAction) {\n      this._updatePickedHandlePosition(editAction);\n    }\n\n    return modeActionSummary;\n  }\n}\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  DoubleClickEvent\n} from '@nebula.gl/edit-modes';\n\n// Minimum number of pixels the pointer must move from the original pointer down to be considered dragging\nconst MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS = 7;\n\nexport default class EditableLayer extends CompositeLayer {\n  // Overridable interaction event handlers\n  onLayerClick(event: ClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onDoubleClick(event: DoubleClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    // default implementation - do nothing\n  }\n\n  // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  initializeState() {\n    this.setState({\n      _editableLayerState: {\n        // Pointer event handlers\n        pointerHandlers: null,\n        // Picked objects at the time the pointer went down\n        pointerDownPicks: null,\n        // Screen coordinates where the pointer went down\n        pointerDownScreenCoords: null,\n        // Ground coordinates where the pointer went down\n        pointerDownMapCoords: null,\n        // Is the pointer dragging (pointer down + moved at least MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS)\n        isDragging: false\n      }\n    });\n  }\n\n  finalizeState() {\n    this._removePointerHandlers();\n  }\n\n  updateState({ props, changeFlags }: Object) {\n    // unsubscribe previous layer instance's handlers\n    this._removePointerHandlers();\n    this._addPointerHandlers();\n  }\n\n  _removePointerHandlers() {\n    if (this.state._editableLayerState.pointerHandlers) {\n      this.context.gl.canvas.removeEventListener(\n        'pointermove',\n        this.state._editableLayerState.pointerHandlers.onPointerMove\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerdown',\n        this.state._editableLayerState.pointerHandlers.onPointerDown\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerup',\n        this.state._editableLayerState.pointerHandlers.onPointerUp\n      );\n      this.context.gl.canvas.removeEventListener(\n        'dblclick',\n        this.state._editableLayerState.pointerHandlers.onDoubleClick\n      );\n    }\n    this.state._editableLayerState.pointerHandlers = null;\n  }\n\n  _addPointerHandlers() {\n    this.state._editableLayerState.pointerHandlers = {\n      onPointerMove: this._onPointerMove.bind(this),\n      onPointerDown: this._onPointerDown.bind(this),\n      onPointerUp: this._onPointerUp.bind(this),\n      onDoubleClick: this._onDoubleClick.bind(this)\n    };\n\n    this.context.gl.canvas.addEventListener(\n      'pointermove',\n      this.state._editableLayerState.pointerHandlers.onPointerMove\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerdown',\n      this.state._editableLayerState.pointerHandlers.onPointerDown\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerup',\n      this.state._editableLayerState.pointerHandlers.onPointerUp\n    );\n    this.context.gl.canvas.addEventListener(\n      'dblclick',\n      this.state._editableLayerState.pointerHandlers.onDoubleClick\n    );\n  }\n\n  _onDoubleClick(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n    this.onDoubleClick({\n      mapCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerDown(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius,\n      depth: this.props.pickingDepth\n    });\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: screenCoords,\n        pointerDownMapCoords: mapCoords,\n        pointerDownPicks: picks,\n        isDragging: false\n      }\n    });\n  }\n\n  _onPointerMove(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords\n    } = this.state._editableLayerState;\n\n    let { isDragging } = this.state._editableLayerState;\n    let startedDragging = false;\n\n    if (pointerDownScreenCoords) {\n      // Pointer went down and is moving\n\n      // Did it move enough to consider it a drag\n      if (!isDragging && this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n        // OK, this is considered dragging\n\n        // Fire the start dragging event\n        this.onStartDragging({\n          picks: pointerDownPicks,\n          screenCoords,\n          mapCoords,\n          pointerDownScreenCoords,\n          pointerDownMapCoords,\n          sourceEvent: event\n        });\n\n        startedDragging = true;\n\n        isDragging = true;\n        this.setState({\n          _editableLayerState: {\n            ...this.state._editableLayerState,\n            isDragging\n          }\n        });\n      }\n    }\n\n    if (!startedDragging) {\n      const picks = this.context.deck.pickMultipleObjects({\n        x: screenCoords[0],\n        y: screenCoords[1],\n        layerIds: [this.props.id],\n        radius: this.props.pickingRadius,\n        depth: this.props.pickingDepth\n      });\n\n      this.onPointerMove({\n        screenCoords,\n        mapCoords,\n        picks,\n        isDragging,\n        pointerDownPicks,\n        pointerDownScreenCoords,\n        pointerDownMapCoords,\n        sourceEvent: event\n      });\n    }\n  }\n\n  _onPointerUp(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      isDragging\n    } = this.state._editableLayerState;\n\n    if (!pointerDownScreenCoords) {\n      // This is a pointer up without a pointer down (e.g. user pointer downed elsewhere), so ignore\n      return;\n    }\n\n    if (isDragging) {\n      this.onStopDragging({\n        picks: pointerDownPicks,\n        screenCoords,\n        mapCoords,\n        pointerDownScreenCoords,\n        pointerDownMapCoords,\n        sourceEvent: event\n      });\n    } else if (!this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n      this.onLayerClick({\n        picks: pointerDownPicks,\n        screenCoords,\n        mapCoords,\n        sourceEvent: event\n      });\n    }\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: null,\n        pointerDownMapCoords: null,\n        pointerDownPicks: null,\n        isDragging: false\n      }\n    });\n  }\n\n  getScreenCoords(pointerEvent: Object) {\n    return [\n      pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().x,\n      pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().y\n    ];\n  }\n\n  getMapCoords(screenCoords: number[]) {\n    return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n  }\n\n  movedEnoughForDrag(screenCoords1: number[], screenCoords2: number[]) {\n    return (\n      Math.abs(screenCoords1[0] - screenCoords2[0]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS ||\n      Math.abs(screenCoords1[1] - screenCoords2[1]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS\n    );\n  }\n}\n\nEditableLayer.layerName = 'EditableLayer';\n","// @flow\n/* eslint-env browser */\n\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer } from '@deck.gl/layers';\n\nimport {\n  ViewMode,\n  ModifyMode,\n  TranslateMode,\n  ScaleMode,\n  RotateMode,\n  DuplicateMode,\n  SplitPolygonMode,\n  ExtrudeMode,\n  ElevationMode,\n  DrawPointMode,\n  DrawLineStringMode,\n  DrawPolygonMode,\n  DrawRectangleMode,\n  DrawCircleFromCenterMode,\n  DrawCircleByBoundingBoxMode,\n  DrawEllipseByBoundingBoxMode,\n  DrawRectangleUsingThreePointsMode,\n  DrawEllipseUsingThreePointsMode,\n  Draw90DegreePolygonMode,\n  SnappableMode\n} from '@nebula.gl/edit-modes';\n\nimport type {\n  EditAction,\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  GeoJsonEditMode,\n  FeatureCollection\n} from '@nebula.gl/edit-modes';\nimport EditableLayer from './editable-layer.js';\n\nconst DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_POINT_OUTLINE_COLOR = [0xff, 0xff, 0xff, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\n\nconst DEFAULT_EDIT_MODE = DrawPolygonMode;\n\nfunction guideAccessor(accessor) {\n  if (!accessor) {\n    return accessor;\n  }\n  return guideMaybeWrapped => accessor(unwrapGuide(guideMaybeWrapped));\n}\n\n// The object handed to us from deck.gl is different depending on the version of deck.gl used, unwrap as necessary\nfunction unwrapGuide(guideMaybeWrapped) {\n  if (guideMaybeWrapped.__source) {\n    return guideMaybeWrapped.__source.object;\n  } else if (guideMaybeWrapped.sourceFeature) {\n    return guideMaybeWrapped.sourceFeature.feature;\n  }\n  // It is not wrapped, return as is\n  return guideMaybeWrapped;\n}\n\nfunction getEditHandleColor(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleOutlineColor(handle) {\n  return DEFAULT_EDITING_POINT_OUTLINE_COLOR;\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nconst defaultProps = {\n  mode: DrawPolygonMode,\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  pickingRadius: 10,\n  pickingDepth: 5,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'pixels',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineDashJustified: false,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: f =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: f => (f && f.properties && f.properties.lineWidth) || 3,\n  getLineDashArray: (feature, isSelected, mode) =>\n    isSelected && mode !== 'view' ? [7, 4] : [0, 0],\n\n  // Tentative feature rendering\n  getTentativeLineDashArray: (f, mode) => [7, 4],\n  getTentativeLineColor: f => DEFAULT_SELECTED_LINE_COLOR,\n  getTentativeFillColor: f => DEFAULT_SELECTED_FILL_COLOR,\n  getTentativeLineWidth: f => (f && f.properties && f.properties.lineWidth) || 3,\n\n  editHandleType: 'point',\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: true,\n  editHandlePointStrokeWidth: 2,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointOutlineColor: getEditHandleOutlineColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: handle => handle.properties.editHandleType,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // misc\n  billboard: true\n};\n\n// Mapping of mode name to mode class (for legacy purposes)\nconst modeNameMapping = {\n  view: ViewMode,\n\n  // Alter modes\n  modify: ModifyMode,\n  translate: new SnappableMode(new TranslateMode()),\n\n  scale: ScaleMode,\n  rotate: RotateMode,\n  duplicate: DuplicateMode,\n  split: SplitPolygonMode,\n  extrude: ExtrudeMode,\n  elevation: ElevationMode,\n\n  // Draw modes\n  drawPoint: DrawPointMode,\n  drawLineString: DrawLineStringMode,\n  drawPolygon: DrawPolygonMode,\n  drawRectangle: DrawRectangleMode,\n  drawCircleFromCenter: DrawCircleFromCenterMode,\n  drawCircleByBoundingBox: DrawCircleByBoundingBoxMode,\n  drawEllipseByBoundingBox: DrawEllipseByBoundingBoxMode,\n  drawRectangleUsing3Points: DrawRectangleUsingThreePointsMode,\n  drawEllipseUsing3Points: DrawEllipseUsingThreePointsMode,\n  draw90DegreePolygon: Draw90DegreePolygonMode\n};\n\ntype Props = {\n  mode: string | GeoJsonEditMode | Class<GeoJsonEditMode>,\n  onEdit: (EditAction<FeatureCollection>) => void,\n  // TODO: type the rest\n  [string]: any\n};\n\n// type State = {\n//   mode: GeoJsonEditMode,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nexport default class EditableGeoJsonLayer extends EditableLayer {\n  // state: State;\n  // props: Props;\n  // setState: ($Shape<State>) => void;\n\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      lineDashJustified: this.props.lineDashJustified,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n      getLineDashArray: this.selectionAwareAccessor(this.props.getLineDashArray),\n\n      _subLayerProps: {\n        'line-strings': {\n          billboard: this.props.billboard\n        },\n        'polygons-stroke': {\n          billboard: this.props.billboard\n        }\n      },\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineDashArray: [this.props.selectedFeatureIndexes, this.props.mode]\n      }\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createGuidesLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      selectedFeatures: [],\n      editHandles: []\n    });\n  }\n\n  // TODO: is this the best way to properly update state from an outside event handler?\n  shouldUpdateState(opts: any) {\n    // console.log(\n    //   'shouldUpdateState',\n    //   opts.changeFlags.propsOrDataChanged,\n    //   opts.changeFlags.stateChanged\n    // );\n    return super.shouldUpdateState(opts) || opts.changeFlags.stateChanged;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }: {\n    props: Props,\n    oldProps: Props,\n    changeFlags: any\n  }) {\n    super.updateState({ props, changeFlags });\n\n    let mode = this.state.mode;\n    if (changeFlags.propsOrDataChanged) {\n      if (props.mode !== oldProps.mode) {\n        if (typeof props.mode === 'string') {\n          // Lookup the mode based on its name (for legacy purposes)\n          mode = modeNameMapping[props.mode];\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"Deprecated use of passing `mode` as a string. Pass the mode's class constructor instead.\"\n          );\n        } else {\n          mode = props.mode;\n        }\n\n        if (typeof mode === 'function') {\n          const ModeConstructor = mode;\n          mode = new ModeConstructor();\n        }\n\n        if (!mode) {\n          console.warn(`No mode configured for ${String(props.mode)}`); // eslint-disable-line no-console,no-undef\n          // Use default mode\n          mode = DEFAULT_EDIT_MODE;\n        }\n\n        if (mode !== this.state.mode) {\n          this.setState({ mode, cursor: null });\n        }\n      }\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map(elem => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  getModeProps(props: Props) {\n    return {\n      modeConfig: props.modeConfig,\n      data: props.data,\n      selectedIndexes: props.selectedFeatureIndexes,\n      lastPointerMoveEvent: this.state.lastPointerMoveEvent,\n      cursor: this.state.cursor,\n      onEdit: (editAction: EditAction<FeatureCollection>) => {\n        props.onEdit(editAction);\n      },\n      onUpdateCursor: (cursor: ?string) => {\n        this.setState({ cursor });\n      }\n    };\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Object) => accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Object) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Object) {\n    if (sourceLayer.id.endsWith('guides')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isGuide = true;\n    }\n\n    return info;\n  }\n\n  createGuidesLayers() {\n    const mode = this.getActiveMode();\n    const guides: FeatureCollection = mode.getGuides(this.getModeProps(this.props));\n\n    if (!guides || !guides.features.length) {\n      return [];\n    }\n\n    let pointLayerProps;\n    if (this.props.editHandleType === 'icon') {\n      pointLayerProps = {\n        type: IconLayer,\n        iconAtlas: this.props.editHandleIconAtlas,\n        iconMapping: this.props.editHandleIconMapping,\n        sizeScale: this.props.editHandleIconSizeScale,\n        getIcon: guideAccessor(this.props.getEditHandleIcon),\n        getSize: guideAccessor(this.props.getEditHandleIconSize),\n        getColor: guideAccessor(this.props.getEditHandleIconColor),\n        getAngle: guideAccessor(this.props.getEditHandleIconAngle)\n      };\n    } else {\n      pointLayerProps = {\n        type: ScatterplotLayer,\n        radiusScale: this.props.editHandlePointRadiusScale,\n        stroked: this.props.editHandlePointOutline,\n        getLineWidth: this.props.editHandlePointStrokeWidth,\n        radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: guideAccessor(this.props.getEditHandlePointRadius),\n        getFillColor: guideAccessor(this.props.getEditHandlePointColor),\n        getLineColor: guideAccessor(this.props.getEditHandlePointOutlineColor)\n      };\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: `guides`,\n        data: guides,\n        fp64: this.props.fp64,\n        _subLayerProps: {\n          points: pointLayerProps\n        },\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        getLineColor: guideAccessor(this.props.getTentativeLineColor),\n        getLineWidth: guideAccessor(this.props.getTentativeLineWidth),\n        getFillColor: guideAccessor(this.props.getTentativeFillColor),\n        getLineDashArray: guideAccessor(this.props.getTentativeLineDashArray)\n      })\n    );\n\n    return [layer];\n  }\n\n  onLayerClick(event: ClickEvent) {\n    this.getActiveMode().handleClick(event, this.getModeProps(this.props));\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    this.getActiveMode().handleStartDragging(event, this.getModeProps(this.props));\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    this.getActiveMode().handleStopDragging(event, this.getModeProps(this.props));\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    this.setState({ lastPointerMoveEvent: event });\n    this.getActiveMode().handlePointerMove(event, this.getModeProps(this.props));\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    let { cursor } = this.state;\n    if (!cursor) {\n      cursor = isDragging ? 'grabbing' : 'grab';\n    }\n    return cursor;\n  }\n\n  getActiveMode(): GeoJsonEditMode {\n    return this.state.mode;\n  }\n}\n\nEditableGeoJsonLayer.layerName = 'EditableGeoJsonLayer';\nEditableGeoJsonLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\nimport { CompositeLayer } from '@deck.gl/core';\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { polygon } from '@turf/helpers';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\n\nimport EditableGeoJsonLayer from './editable-geojson-layer';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nconst defaultProps = {\n  selectionType: SELECTION_TYPE.RECTANGLE,\n  layerIds: [],\n  onSelect: () => {}\n};\n\nconst EMPTY_DATA = {\n  type: 'FeatureCollection',\n  features: []\n};\n\nconst EXPANSION_KM = 50;\nconst LAYER_ID_GEOJSON = 'selection-geojson';\nconst LAYER_ID_BLOCKER = 'selection-blocker';\n\nconst PASS_THROUGH_PROPS = [\n  'lineWidthScale',\n  'lineWidthMinPixels',\n  'lineWidthMaxPixels',\n  'lineWidthUnits',\n  'lineJointRounded',\n  'lineMiterLimit',\n  'pointRadiusScale',\n  'pointRadiusMinPixels',\n  'pointRadiusMaxPixels',\n  'lineDashJustified',\n  'getLineColor',\n  'getFillColor',\n  'getRadius',\n  'getLineWidth',\n  'getLineDashArray',\n  'getTentativeLineDashArray',\n  'getTentativeLineColor',\n  'getTentativeFillColor',\n  'getTentativeLineWidth'\n];\n\nexport default class SelectionLayer extends CompositeLayer {\n  _selectRectangleObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n\n    const [x1, y1] = this.context.viewport.project(coordinates[0][0]);\n    const [x2, y2] = this.context.viewport.project(coordinates[0][2]);\n\n    const pickingInfos = this.context.deck.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds\n    });\n\n    onSelect({ pickingInfos });\n  }\n\n  _selectPolygonObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n    const mousePoints = coordinates[0].map(c => this.context.viewport.project(c));\n\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    // Use a polygon to hide the outside, because pickObjects()\n    // does not support polygons\n    const landPointsPoly = polygon(coordinates);\n    const bigBuffer = turfBuffer(landPointsPoly, EXPANSION_KM);\n    let bigPolygon;\n    try {\n      // turfDifference throws an exception if the polygon\n      // intersects with itself (TODO: check if true in all versions)\n      bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n    } catch (e) {\n      // invalid selection polygon\n      console.log('turfDifference() error', e); // eslint-disable-line\n      return;\n    }\n\n    this.setState({\n      pendingPolygonSelection: {\n        bigPolygon\n      }\n    });\n\n    const blockerId = `${this.props.id}-${LAYER_ID_BLOCKER}`;\n\n    // HACK, find a better way\n    setTimeout(() => {\n      const pickingInfos = this.context.deck.pickObjects({\n        x,\n        y,\n        width: maxX - x,\n        height: maxY - y,\n        layerIds: [blockerId, ...layerIds]\n      });\n\n      onSelect({\n        pickingInfos: pickingInfos.filter(item => item.layer.id !== this.props.id)\n      });\n    }, 250);\n  }\n\n  renderLayers() {\n    const { pendingPolygonSelection } = this.state;\n\n    const mode =\n      {\n        [SELECTION_TYPE.RECTANGLE]: 'drawRectangle',\n        [SELECTION_TYPE.POLYGON]: 'drawPolygon'\n      }[this.props.selectionType] || 'view';\n\n    const inheritedProps = {};\n    PASS_THROUGH_PROPS.forEach(p => {\n      if (this.props[p] !== undefined) inheritedProps[p] = this.props[p];\n    });\n\n    const layers = [\n      new EditableGeoJsonLayer(\n        this.getSubLayerProps({\n          id: LAYER_ID_GEOJSON,\n          pickable: true,\n          mode,\n          selectedFeatureIndexes: [],\n          data: EMPTY_DATA,\n          onEdit: ({ updatedData, editType }) => {\n            if (editType === 'addFeature') {\n              const { coordinates } = updatedData.features[0].geometry;\n\n              if (this.props.selectionType === SELECTION_TYPE.RECTANGLE) {\n                this._selectRectangleObjects(coordinates);\n              } else if (this.props.selectionType === SELECTION_TYPE.POLYGON) {\n                this._selectPolygonObjects(coordinates);\n              }\n            }\n          },\n          ...inheritedProps\n        })\n      )\n    ];\n\n    if (pendingPolygonSelection) {\n      const { bigPolygon } = pendingPolygonSelection;\n      layers.push(\n        new PolygonLayer(\n          this.getSubLayerProps({\n            id: LAYER_ID_BLOCKER,\n            pickable: true,\n            stroked: false,\n            opacity: 1.0,\n            data: [bigPolygon],\n            getLineColor: obj => [0, 0, 0, 1],\n            getFillColor: obj => [0, 0, 0, 1],\n            getPolygon: o => o.geometry.coordinates\n          })\n        )\n      );\n    }\n\n    return layers;\n  }\n\n  shouldUpdateState({ changeFlags: { stateChanged, propsOrDataChanged } }: Object) {\n    return stateChanged || propsOrDataChanged;\n  }\n}\n\nSelectionLayer.layerName = 'SelectionLayer';\nSelectionLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer, LineLayer } from '@deck.gl/layers';\n\nconst defaultProps = {};\n\nexport default class ElevatedEditHandleLayer extends CompositeLayer {\n  renderLayers() {\n    const handles = new ScatterplotLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-ScatterplotLayer`,\n        data: this.props.data\n      })\n    );\n\n    const lines = new LineLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-LineLayer`,\n        data: this.props.data,\n        pickable: false,\n        getSourcePosition: ({ position }) => [position[0], position[1], 0],\n        getTargetPosition: ({ position }) => [position[0], position[1], position[2] || 0],\n        getColor: [150, 150, 150, 200],\n        getStrokeWidth: 3\n      })\n    );\n\n    return [handles, lines];\n  }\n}\n\nElevatedEditHandleLayer.layerName = 'ElevatedEditHandleLayer';\nElevatedEditHandleLayer.defaultProps = defaultProps;\n","/* eslint-disable camelcase */\nconst INITIAL_STATE = {\n  outlineEnabled: false,\n  outlineRenderShadowmap: false,\n  outlineShadowmap: null\n};\n\nfunction getUniforms({ outlineEnabled, outlineRenderShadowmap, outlineShadowmap } = INITIAL_STATE) {\n  const uniforms = {};\n  if (outlineEnabled !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uEnabled = outlineEnabled;\n  }\n  if (outlineRenderShadowmap !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uRenderOutlines = outlineRenderShadowmap;\n  }\n  if (outlineShadowmap !== undefined) {\n    uniforms.outline_uShadowmap = outlineShadowmap;\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nattribute float instanceZLevel;\nvarying float outline_vzLevel;\nvarying vec4 outline_vPosition;\n\n// Set the z level for the outline shadowmap rendering\nvoid outline_setZLevel(float zLevel) {\n  outline_vzLevel = zLevel;\n}\n\n// Store an adjusted position for texture2DProj\nvoid outline_setUV(vec4 position) {\n  // mat4(\n  //   0.5, 0.0, 0.0, 0.0,\n  //   0.0, 0.5, 0.0, 0.0,\n  //   0.0, 0.0, 0.5, 0.0,\n  //   0.5, 0.5, 0.5, 1.0\n  // ) * position;\n  outline_vPosition = vec4(position.xyz * 0.5 + position.w * 0.5, position.w);\n}\n`;\n\nconst fs = `\\\nuniform bool outline_uEnabled;\nuniform bool outline_uRenderOutlines;\nuniform sampler2D outline_uShadowmap;\n\nvarying float outline_vzLevel;\n// varying vec2 outline_vUV;\nvarying vec4 outline_vPosition;\n\nconst float OUTLINE_Z_LEVEL_ERROR = 0.01;\n\n// Return a darker color in shadowmap\nvec4 outline_filterShadowColor(vec4 color) {\n  return vec4(outline_vzLevel / 255., outline_vzLevel / 255., outline_vzLevel / 255., 1.);\n}\n\n// Return a darker color if in shadowmap\nvec4 outline_filterDarkenColor(vec4 color) {\n  if (outline_uEnabled) {\n    float maxZLevel;\n    if (outline_vPosition.q > 0.0) {\n      maxZLevel = texture2DProj(outline_uShadowmap, outline_vPosition).r * 255.;\n    } else {\n      discard;\n    }\n    if (maxZLevel < outline_vzLevel + OUTLINE_Z_LEVEL_ERROR) {\n      vec4(color.rgb * 0.5, color.a);\n    } else {\n      discard;\n    }\n  }\n  return color;\n}\n\n// if enabled and rendering outlines - Render depth to shadowmap\n// if enabled and rendering colors - Return a darker color if in shadowmap\n// if disabled, just return color\nvec4 outline_filterColor(vec4 color) {\n  if (outline_uEnabled) {\n    return outline_uRenderOutlines ?\n      outline_filterShadowColor(color) :\n      outline_filterDarkenColor(color);\n  }\n  return color;\n}\n`;\n\nexport default {\n  name: 'outline',\n  vs,\n  fs,\n  getUniforms\n};\n","import { PathLayer } from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport { Framebuffer, Texture2D } from '@luma.gl/core';\nimport outline from '../../shaderlib/outline/outline';\n\n// TODO - this should be built into assembleShaders\nfunction injectShaderCode({ source, code = '' }) {\n  const INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nconst VS_CODE = `\\\n  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n`;\n\nconst FS_CODE = `\\\n  gl_FragColor = outline_filterColor(gl_FragColor);\n`;\n\nconst defaultProps = {\n  getZLevel: { type: 'accessor', value: 0 }\n};\n\nexport default class PathOutlineLayer extends PathLayer {\n  // Override getShaders to inject the outline module\n  getShaders() {\n    const shaders = super.getShaders();\n    return Object.assign({}, shaders, {\n      modules: shaders.modules.concat([outline]),\n      vs: injectShaderCode({ source: shaders.vs, code: VS_CODE }),\n      fs: injectShaderCode({ source: shaders.fs, code: FS_CODE })\n    });\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    // Create an outline \"shadow\" map\n    // TODO - we should create a single outlineMap for all layers\n    this.setState({\n      outlineFramebuffer: new Framebuffer(context.gl),\n      dummyTexture: new Texture2D(context.gl)\n    });\n\n    // Create an attribute manager\n    this.state.attributeManager.addInstanced({\n      instanceZLevel: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateZLevels,\n        accessor: 'getZLevel'\n      }\n    });\n  }\n\n  // Override draw to add render module\n  draw({ moduleParameters = {}, parameters, uniforms, context }) {\n    // Need to calculate same uniforms as base layer\n    const {\n      rounded,\n      miterLimit,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n      dashJustified\n    } = this.props;\n\n    uniforms = Object.assign({}, uniforms, {\n      jointType: Number(rounded),\n      alignMode: Number(dashJustified),\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    });\n\n    // Render the outline shadowmap (based on segment z orders)\n    const { outlineFramebuffer, dummyTexture } = this.state;\n    outlineFramebuffer.resize();\n    outlineFramebuffer.clear({ color: true, depth: true });\n\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: true,\n      outlineShadowmap: dummyTexture\n    });\n\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: 0,\n        widthScale: this.props.widthScale * 1.3\n      }),\n      parameters: {\n        depthTest: false,\n        // Biggest value needs to go into buffer\n        blendEquation: GL.MAX\n      },\n      framebuffer: outlineFramebuffer\n    });\n\n    // Now use the outline shadowmap to render the lines (with outlines)\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: false,\n      outlineShadowmap: outlineFramebuffer\n    });\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        widthScale: this.props.widthScale\n      }),\n      parameters: {\n        depthTest: false\n      }\n    });\n  }\n\n  calculateZLevels(attribute) {\n    const { getZLevel } = this.props;\n    const { pathTesselator } = this.state;\n\n    attribute.value = pathTesselator._updateAttribute({\n      target: attribute.value,\n      size: 1,\n      getValue: (object, index) => [getZLevel(object, index) || 0]\n    });\n  }\n}\n\nPathOutlineLayer.layerName = 'PathOutlineLayer';\nPathOutlineLayer.defaultProps = defaultProps;\n","import { Geometry } from '@luma.gl/core';\n\nexport default class Arrow2DGeometry extends Geometry {\n  constructor(opts = {}) {\n    super(\n      Object.assign({}, opts, {\n        attributes: getArrowAttributes(opts)\n      })\n    );\n  }\n}\n\nfunction getArrowAttributes({ length = 1, headSize = 0.2, tailWidth = 0.05, tailStart = 0.05 }) {\n  const texCoords = [\n    // HEAD\n    0.5,\n    1.0,\n    0,\n    0.5 - headSize / 2,\n    1.0 - headSize,\n    0,\n    0.5 + headSize / 2,\n    1.0 - headSize,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    tailStart,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 - tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0\n  ];\n\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\n\n  // Center and scale\n  const positions = new Array(texCoords.length);\n  for (let i = 0; i < texCoords.length / 3; i++) {\n    const i3 = i * 3;\n    positions[i3 + 0] = (texCoords[i3 + 0] - 0.5) * length;\n    positions[i3 + 1] = (texCoords[i3 + 1] - 0.5) * length;\n    positions[i3 + 2] = 0;\n  }\n  return {\n    positions: new Float32Array(positions),\n    normals: new Float32Array(normals),\n    texCoords: new Float32Array(texCoords)\n  };\n}\n","import { Vector2 } from 'math.gl';\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  let lineLength = 0;\n  for (let i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n  return lineLength;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_DIRECTION = { forward: true, backward: false };\n\nexport default function createPathMarkers({\n  data,\n  getPath = x => x.path,\n  getDirection = x => x.direction,\n  getColor = x => DEFAULT_COLOR,\n  getMarkerPercentages = x => [0.5],\n  projectFlat\n}) {\n  const markers = [];\n\n  for (const object of data) {\n    const path = getPath(object);\n    const direction = getDirection(object) || DEFAULT_DIRECTION;\n    const color = getColor(object);\n\n    const vPoints = path.map(p => new Vector2(p));\n    const vPointsReverse = vPoints.slice(0).reverse();\n\n    // calculate total length\n    const lineLength = getLineLength(vPoints);\n\n    // Ask for where to put markers\n    const percentages = getMarkerPercentages(object, { lineLength });\n\n    // Create the markers\n    for (const percentage of percentages) {\n      if (direction.forward) {\n        const marker = createMarkerAlongPath({\n          path: vPoints,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n\n      if (direction.backward) {\n        const marker = createMarkerAlongPath({\n          path: vPointsReverse,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n    }\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath({ path, percentage, lineLength, color, object, projectFlat }) {\n  const distanceAlong = lineLength * percentage;\n  let currentDistance = 0;\n  let previousDistance = 0;\n  let i = 0;\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n    previousDistance = currentDistance;\n  }\n\n  const vDirection = path[i + 1]\n    .clone()\n    .subtract(path[i])\n    .normalize();\n  const along = distanceAlong - previousDistance;\n  const vCenter = vDirection\n    .clone()\n    .multiply(new Vector2(along, along))\n    .add(path[i]);\n\n  const vDirection2 = new Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n  const angle = (-vDirection2.verticalAngle() * 180) / Math.PI;\n\n  return { position: [vCenter.x, vCenter.y, 0], angle, color, object };\n}\n","import { Vector3, clamp } from 'math.gl';\n\n// Return the closest point on a line segment\nexport function getClosestPointOnLine({ p, p1, p2, clampToLine = true }) {\n  const lineVector = new Vector3(p2).subtract(p1);\n  const pointVector = new Vector3(p).subtract(p1);\n  let dotProduct = lineVector.dot(pointVector);\n  if (clampToLine) {\n    dotProduct = clamp(dotProduct, 0, 1);\n  }\n  return lineVector.lerp(dotProduct);\n}\n\n// Return the closest point on a line segment\nexport function getClosestPointOnPolyline({ p, points }) {\n  p = new Vector3(p);\n  let pClosest = null;\n  let distanceSquared = Infinity;\n  let index = -1;\n  for (let i = 0; i < points.length - 1; ++i) {\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const pClosestOnLine = getClosestPointOnLine({ p, p1, p2 });\n    const distanceToLineSquared = p.distanceSquared(pClosestOnLine);\n    if (distanceToLineSquared < distanceSquared) {\n      distanceSquared = distanceToLineSquared;\n      pClosest = pClosestOnLine;\n      index = i;\n    }\n  }\n  return {\n    point: pClosest,\n    index,\n    p1: points[index],\n    p2: points[index + 1],\n    distanceSquared,\n    distance: Math.sqrt(distanceSquared)\n  };\n}\n","import { CompositeLayer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport PathOutlineLayer from '../path-outline-layer/path-outline-layer';\nimport Arrow2DGeometry from './arrow-2d-geometry';\n\nimport createPathMarkers from './create-path-markers';\nimport { getClosestPointOnPolyline } from './polyline';\n\nconst DISTANCE_FOR_MULTI_ARROWS = 0.1;\nconst ARROW_HEAD_SIZE = 0.2;\nconst ARROW_TAIL_WIDTH = 0.05;\n// const ARROW_CENTER_ADJUST = -0.8;\n\nconst DEFAULT_MARKER_LAYER = SimpleMeshLayer;\n\nconst DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH })\n};\n\nconst defaultProps = Object.assign({}, PathOutlineLayer.defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n\n  sizeScale: 100,\n  fp64: false,\n\n  hightlightIndex: -1,\n  highlightPoint: null,\n\n  getPath: x => x.path,\n  getColor: x => x.color,\n  getMarkerColor: x => [0, 0, 0, 255],\n  getDirection: x => x.direction,\n  getMarkerPercentages: (object, { lineLength }) =>\n    lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5]\n});\n\nexport default class PathMarkerLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      markers: [],\n      mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n      closestPoint: null\n    };\n  }\n\n  projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n    if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n      const [dx, dy] = viewport.metersToLngLatDelta(xyz);\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    } else if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n      const [dx, dy] = xyz;\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    }\n\n    return viewport.projectFlat(xyz);\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n      const {\n        data,\n        getPath,\n        getDirection,\n        getMarkerColor,\n        getMarkerPercentages,\n        coordinateSystem,\n        coordinateOrigin\n      } = this.props;\n      const { viewport } = this.context;\n      const projectFlat = o => this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n      this.state.markers = createPathMarkers({\n        data,\n        getPath,\n        getDirection,\n        getColor: getMarkerColor,\n        getMarkerPercentages,\n        projectFlat\n      });\n      this._recalculateClosestPoint();\n    }\n    if (changeFlags.propsChanged) {\n      if (props.point !== oldProps.point) {\n        this._recalculateClosestPoint();\n      }\n    }\n  }\n\n  _recalculateClosestPoint() {\n    const { highlightPoint, highlightIndex } = this.props;\n    if (highlightPoint && highlightIndex >= 0) {\n      const object = this.props.data[highlightIndex];\n      const points = this.props.getPath(object);\n      const { point } = getClosestPointOnPolyline({ points, p: highlightPoint });\n      this.state.closestPoints = [\n        {\n          position: point\n        }\n      ];\n    } else {\n      this.state.closestPoints = [];\n    }\n  }\n\n  getPickingInfo({ info }) {\n    return Object.assign(info, {\n      // override object with picked feature\n      object: (info.object && info.object.path) || info.object\n    });\n  }\n\n  renderLayers() {\n    return [\n      new PathOutlineLayer(\n        this.props,\n        this.getSubLayerProps({\n          id: 'paths',\n          // Note: data has to be passed explicitly like this to avoid being empty\n          data: this.props.data\n        })\n      ),\n      new this.props.MarkerLayer(\n        this.getSubLayerProps(\n          Object.assign({}, this.props.markerLayerProps, {\n            id: 'markers',\n            data: this.state.markers,\n            getOrientation: x => [0, -x.angle, 0],\n            getColor: x => x.color,\n            sizeScale: this.props.sizeScale,\n            fp64: this.props.fp64,\n            pickable: false,\n            parameters: {\n              blend: false,\n              depthTest: false\n            }\n          })\n        )\n      ),\n      this.state.closestPoints &&\n        new ScatterplotLayer({\n          id: `${this.props.id}-highlight`,\n          data: this.state.closestPoints,\n          fp64: this.props.fp64\n        })\n    ];\n  }\n}\n\nPathMarkerLayer.layerName = 'PathMarkerLayer';\nPathMarkerLayer.defaultProps = defaultProps;\n","// @flow\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\n\nexport default class JunctionScatterplotLayer extends CompositeLayer {\n  static layerName = 'JunctionScatterplotLayer';\n  static defaultProps = {\n    ...ScatterplotLayer.defaultProps,\n    getFillColor: d => [0, 0, 0, 255],\n    getStrokeColor: d => [255, 255, 255, 255],\n    getInnerRadius: d => 1\n  };\n\n  renderLayers() {\n    const { id, getFillColor, getStrokeColor, getInnerRadius, updateTriggers } = this.props;\n\n    // data needs to be passed explicitly after deck.gl 5.3\n    return [\n      // the full circles\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-full`,\n        data: this.props.data,\n        getLineColor: getStrokeColor,\n        updateTriggers: {\n          ...updateTriggers,\n          getStrokeColor: updateTriggers.getStrokeColor\n        }\n      }),\n      // the inner part\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-inner`,\n        data: this.props.data,\n        getFillColor,\n        getRadius: getInnerRadius,\n        pickable: false,\n        updateTriggers: {\n          ...updateTriggers,\n          getFillColor: updateTriggers.getFillColor,\n          getRadius: updateTriggers.getInnerRadius\n        }\n      })\n    ];\n  }\n}\n","// @flow\nimport { PathMarkerLayer } from '@nebula.gl/layers';\nimport { MAX } from '@luma.gl/constants';\n\nimport { ArrowStyles, DEFAULT_STYLE, MAX_ARROWS } from '../style';\nimport NebulaLayer from '../nebula-layer';\nimport { toDeckColor } from '../utils';\nimport DeckCache from '../deck-renderer/deck-cache';\n\nconst NEBULA_TO_DECK_DIRECTIONS = {\n  [ArrowStyles.NONE]: { forward: false, backward: false },\n  [ArrowStyles.FORWARD]: { forward: true, backward: false },\n  [ArrowStyles.BACKWARD]: { forward: false, backward: true },\n  [ArrowStyles.BOTH]: { forward: true, backward: true }\n};\n\nexport default class SegmentsLayer extends NebulaLayer {\n  deckCache: DeckCache<*, *>;\n  noBlend: boolean;\n  highlightColor: [number, number, number, number];\n  arrowSize: number;\n  rounded: boolean;\n  dashed: boolean;\n  markerLayerProps: ?Object;\n\n  constructor(config: Object) {\n    super(config);\n    this.deckCache = new DeckCache(config.getData, data => config.toNebulaFeature(data));\n    this.enableSelection = true;\n    const {\n      enablePicking = true,\n      noBlend = false,\n      rounded = true,\n      dashed = false,\n      markerLayerProps = null\n    } = config;\n    Object.assign(this, { enablePicking, noBlend, rounded, dashed, markerLayerProps });\n  }\n\n  getMouseOverSegment(): any {\n    // TODO: remove references\n    return null;\n  }\n\n  _calcMarkerPercentages(nf: Object): number[] {\n    const { arrowPercentages } = nf.style;\n    if (arrowPercentages) {\n      return arrowPercentages;\n    }\n\n    const arrowStyle = nf.style.arrowStyle || DEFAULT_STYLE.arrowStyle;\n    if (arrowStyle === ArrowStyles.NONE) return [];\n\n    const arrowCount = Math.min(nf.style.arrowCount || DEFAULT_STYLE.arrowCount, MAX_ARROWS);\n    return [[0.5], [0.33, 0.66], [0.25, 0.5, 0.75]][arrowCount - 1];\n  }\n\n  _getHighlightedObjectIndex({ nebula }: Object): number {\n    const { deckglMouseOverInfo } = nebula;\n    if (deckglMouseOverInfo) {\n      const { originalLayer, index } = deckglMouseOverInfo;\n      if (originalLayer === this) {\n        return index;\n      }\n    }\n\n    // no object\n    return -1;\n  }\n\n  render({ nebula }: Object) {\n    const defaultColor = [0x0, 0x0, 0x0, 0xff];\n    const { objects, updateTrigger } = this.deckCache;\n\n    return new PathMarkerLayer({\n      id: `segments-${this.id}`,\n      data: objects,\n      opacity: 1,\n      fp64: false,\n      rounded: this.rounded,\n      pickable: true,\n      sizeScale: this.arrowSize || 6,\n      parameters: {\n        depthTest: false,\n        blend: !this.noBlend,\n        blendEquation: MAX\n      },\n      getPath: nf => nf.geoJson.geometry.coordinates,\n      getColor: nf => toDeckColor(nf.style.lineColor, defaultColor),\n      getWidth: nf => nf.style.lineWidthMeters || 1,\n      getZLevel: nf => nf.style.zLevel * 255,\n      getDirection: nf => NEBULA_TO_DECK_DIRECTIONS[nf.style.arrowStyle],\n      getMarkerColor: nf => toDeckColor(nf.style.arrowColor, defaultColor),\n      getMarkerPercentages: this._calcMarkerPercentages,\n      updateTriggers: { all: updateTrigger },\n\n      highlightedObjectIndex: this._getHighlightedObjectIndex({ nebula }),\n      highlightColor: toDeckColor(this.highlightColor),\n\n      dashJustified: this.dashed,\n      getDashArray: this.dashed ? nf => nf.style.dashArray : null,\n      markerLayerProps:\n        this.markerLayerProps || (PathMarkerLayer: Object).defaultProps.markerLayerProps,\n\n      nebulaLayer: this\n    });\n  }\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst styles = {\n  toolboxItem: {\n    flexBasis: '50%'\n  }\n};\n\nexport const Toolbox = styled.div`\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  color: #f0f0f0;\n  padding: 0;\n  width: 230px;\n  height: 100%;\n  font-family: Arial, Helvetica, sans-serif;\n  font-size: 16px;\n  overflow: scroll;\n  z-index: 999;\n`;\n\nexport const ToolboxRow = props => <div>{props.children}</div>;\nexport const ToolboxControl = props => <div style={styles.toolboxItem}>{props.children}</div>;\n\nexport const ToolboxTitle = styled.div`\n  background: rgba(39, 45, 59, 0.8);\n  font-size: 16px;\n  height: 44px;\n  display: flex;\n  align-items: center;\n  padding: 0px 8px;\n`;\n\nconst buttonBackground = props =>\n  props.selected ? 'rgba(30, 84, 183, 0.8)' : 'rgba(23, 28, 41, 0.8)';\n\nexport const ToolboxButton = styled.button`\n  display: block;\n  width: 100%;\n  border: none;\n  color: #f0f0f0;\n  background: ${buttonBackground};\n  text-align: left;\n  font-size: 16px;\n  outline: none;\n  height: 44px;\n  cursor: pointer;\n\n  &:hover {\n    background: #276ef1;\n  }\n`;\n\nconst ToolboxCheckboxContainer = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  border: none;\n  color: #f0f0f0;\n  background: ${buttonBackground};\n  text-align: left;\n  text-transform: capitalize;\n  font-size: 16px;\n  outline: none;\n  height: 44px;\n  cursor: pointer;\n\n  &:hover {\n    background: #276ef1;\n  }\n`;\n\nexport const ToolboxCheckbox = props => (\n  <label>\n    <ToolboxCheckboxContainer>\n      <input {...{ ...props, children: null }} />\n      {props.children}\n    </ToolboxCheckboxContainer>\n  </label>\n);\n","// @flow\n/* eslint-env browser */\n\nimport window from 'global/window';\nimport React, { Component } from 'react';\nimport DeckGL from '@deck.gl/react';\nimport { MapView, MapController } from '@deck.gl/core';\nimport { StaticMap } from 'react-map-gl';\nimport GL from '@luma.gl/constants';\nimport circle from '@turf/circle';\n\nimport {\n  EditableGeoJsonLayer,\n  SelectionLayer,\n  type EditMode,\n  ModifyMode,\n  TranslateMode,\n  ScaleMode,\n  RotateMode,\n  DuplicateMode,\n  SplitPolygonMode,\n  ExtrudeMode,\n  ElevationMode,\n  DrawPointMode,\n  DrawLineStringMode,\n  DrawPolygonMode,\n  DrawRectangleMode,\n  DrawCircleByBoundingBoxMode,\n  DrawCircleFromCenterMode,\n  DrawEllipseByBoundingBoxMode,\n  DrawEllipseUsingThreePointsMode,\n  DrawRectangleUsingThreePointsMode,\n  Draw90DegreePolygonMode,\n  ViewMode,\n  CompositeMode,\n  SnappableMode,\n  ElevatedEditHandleLayer,\n  PathMarkerLayer,\n  SELECTION_TYPE\n} from 'nebula.gl';\n\nimport sampleGeoJson from '../data/sample-geojson.json';\n\nimport iconSheet from '../data/edit-handles.png';\n\nimport {\n  Toolbox,\n  ToolboxControl,\n  ToolboxTitle,\n  ToolboxRow,\n  ToolboxButton,\n  ToolboxCheckbox\n} from './toolbox';\n\nconst COMPOSITE_MODE = new CompositeMode([new DrawLineStringMode(), new ModifyMode()]);\n\nconst styles = {\n  mapContainer: {\n    alignItems: 'stretch',\n    display: 'flex',\n    height: '100vh'\n  },\n  checkbox: {\n    margin: 10\n  }\n};\n\nconst initialViewport = {\n  bearing: 0,\n  height: 0,\n  latitude: 37.76,\n  longitude: -122.44,\n  pitch: 0,\n  width: 0,\n  zoom: 11\n};\n\nconst ALL_MODES = [\n  {\n    category: 'View',\n    modes: [{ label: 'View', mode: ViewMode }]\n  },\n  {\n    category: 'Alter',\n    modes: [\n      { label: 'Modify', mode: ModifyMode },\n      { label: 'Elevation', mode: ElevationMode },\n      { label: 'Translate', mode: new SnappableMode(new TranslateMode()) },\n      { label: 'Rotate', mode: RotateMode },\n      { label: 'Scale', mode: ScaleMode },\n      { label: 'Duplicate', mode: DuplicateMode },\n      { label: 'Extrude', mode: ExtrudeMode },\n      { label: 'Split', mode: SplitPolygonMode }\n    ]\n  },\n  {\n    category: 'Draw',\n    modes: [\n      { label: 'Draw Point', mode: DrawPointMode },\n      { label: 'Draw LineString', mode: DrawLineStringMode },\n      { label: 'Draw Polygon', mode: DrawPolygonMode },\n      { label: 'Draw 90° Polygon', mode: Draw90DegreePolygonMode },\n      { label: 'Draw Rectangle', mode: DrawRectangleMode },\n      { label: 'Draw Rectangle Using 3 Points', mode: DrawRectangleUsingThreePointsMode },\n      { label: 'Draw Circle From Center', mode: DrawCircleFromCenterMode },\n      { label: 'Draw Circle By Diameter', mode: DrawCircleByBoundingBoxMode },\n      { label: 'Draw Ellipse By Bounding Box', mode: DrawEllipseByBoundingBoxMode },\n      { label: 'Draw Ellipse Using 3 Points', mode: DrawEllipseUsingThreePointsMode }\n    ]\n  },\n  {\n    category: 'Composite',\n    modes: [{ label: 'Draw LineString + Modify', mode: COMPOSITE_MODE }]\n  }\n];\n\nconst POLYGON_DRAWING_MODES = [\n  DrawPolygonMode,\n  Draw90DegreePolygonMode,\n  DrawRectangleMode,\n  DrawRectangleUsingThreePointsMode,\n  DrawCircleFromCenterMode,\n  DrawCircleByBoundingBoxMode,\n  DrawEllipseByBoundingBoxMode,\n  DrawEllipseUsingThreePointsMode\n];\n\nconst EMPTY_FEATURE_COLLECTION = {\n  type: 'FeatureCollection',\n  features: []\n};\n\nfunction hex2rgb(hex: string) {\n  const value = parseInt(hex, 16);\n  return [16, 8, 0].map(shift => ((value >> shift) & 0xff) / 255);\n}\n\nconst FEATURE_COLORS = [\n  '00AEE4',\n  'DAF0E3',\n  '9BCC32',\n  '07A35A',\n  'F7DF90',\n  'EA376C',\n  '6A126A',\n  'FCB09B',\n  'B0592D',\n  'C1B5E3',\n  '9C805B',\n  'CCDFE5'\n].map(hex2rgb);\n\n// TODO edit-modes:  delete once fully on EditMode implementation and just use handle.properties.editHandleType...\n// Unwrap the edit handle object from either layer implementation\nfunction getEditHandleTypeFromEitherLayer(handleOrFeature) {\n  if (handleOrFeature.__source) {\n    return handleOrFeature.__source.object.properties.editHandleType;\n  } else if (handleOrFeature.sourceFeature) {\n    return handleOrFeature.sourceFeature.feature.properties.editHandleType;\n  } else if (handleOrFeature.properties) {\n    return handleOrFeature.properties.editHandleType;\n  }\n\n  return handleOrFeature.type;\n}\n\nfunction getEditHandleColor(handle: {}) {\n  switch (getEditHandleTypeFromEitherLayer(handle)) {\n    case 'existing':\n      return [0xff, 0x80, 0x00, 0xff];\n    case 'snap':\n      return [0xc0, 0x80, 0xf0, 0xff];\n    case 'intermediate':\n    default:\n      return [0xff, 0xc0, 0x80, 0xff];\n  }\n}\n\nexport default class Example extends Component<\n  {},\n  {\n    viewport: Object,\n    testFeatures: any,\n    mode: EditMode | Class<EditMode>,\n    modeConfig: any,\n    pointsRemovable: boolean,\n    selectedFeatureIndexes: number[],\n    editHandleType: string,\n    selectionTool: ?string,\n    showGeoJson: boolean,\n    pathMarkerLayer: boolean,\n    featureMenu: ?{\n      index: number,\n      x: number,\n      y: number\n    }\n  }\n> {\n  constructor() {\n    super();\n\n    this.state = {\n      viewport: initialViewport,\n      testFeatures: sampleGeoJson,\n      mode: DrawPolygonMode,\n      modeConfig: null,\n      pointsRemovable: true,\n      selectedFeatureIndexes: [],\n      editHandleType: 'point',\n      selectionTool: null,\n      showGeoJson: false,\n      pathMarkerLayer: false,\n      featureMenu: null\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this._resize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize);\n  }\n\n  _onChangeViewport = (viewport: Object) => {\n    this.setState({\n      viewport: { ...this.state.viewport, ...viewport }\n    });\n  };\n\n  _onLayerClick = (info: any) => {\n    console.log('onLayerClick', info); // eslint-disable-line\n\n    if (this.state.mode !== ViewMode || this.state.selectionTool) {\n      // don't change selection while editing\n      return;\n    }\n\n    if (info) {\n      console.log(`select editing feature ${info.index}`); // eslint-disable-line\n      // a feature was clicked\n      // TODO: once https://github.com/uber/deck.gl/pull/1918 lands, this will work since it'll work with Multi* geometry types\n      this.setState({ selectedFeatureIndexes: [info.index] });\n    } else {\n      console.log('deselect editing feature'); // eslint-disable-line\n      // open space was clicked, so stop editing\n      this.setState({ selectedFeatureIndexes: [] });\n    }\n  };\n\n  _resize = () => {\n    this.forceUpdate();\n  };\n\n  _loadSample = (type: string) => {\n    if (type === 'mixed') {\n      this.setState({\n        testFeatures: sampleGeoJson,\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'complex') {\n      this.setState({\n        testFeatures: {\n          type: 'FeatureCollection',\n          features: [\n            circle([-122.45, 37.81], 4, { steps: 5000 }),\n            circle([-122.33, 37.81], 4, { steps: 5000 }),\n            circle([-122.45, 37.73], 4, { steps: 5000 }),\n            circle([-122.33, 37.73], 4, { steps: 5000 })\n          ]\n        },\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'blank') {\n      this.setState({\n        testFeatures: EMPTY_FEATURE_COLLECTION,\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'file') {\n      const el = document.createElement('input');\n      el.type = 'file';\n      el.onchange = e => {\n        if (e.target.files && e.target.files[0]) {\n          const reader = new FileReader();\n          reader.onload = ({ target }) => {\n            this._parseStringJson(target.result);\n          };\n          reader.readAsText(e.target.files[0]);\n        }\n      };\n      el.click();\n    }\n  };\n\n  _copy = () => {\n    if (navigator && navigator.clipboard) {\n      navigator.clipboard.writeText(JSON.stringify(this.state.testFeatures));\n    } else {\n      this._error('No navigator.clipboard');\n    }\n  };\n\n  _paste = () => {\n    if (navigator && navigator.clipboard) {\n      navigator.clipboard.readText().then(\n        value => {\n          this._parseStringJson(value);\n        },\n        reason => {\n          this._error(reason);\n        }\n      );\n    } else {\n      this._error('No navigator.clipboard');\n    }\n  };\n\n  _download = () => {\n    const blob = new Blob([JSON.stringify(this.state.testFeatures)], { type: 'octet/stream' });\n    const a = document.createElement('a');\n    a.href = URL.createObjectURL(blob);\n    a.download = 'nebula.geojson';\n    a.click();\n  };\n\n  _parseStringJson = (json: string) => {\n    let testFeatures = null;\n    try {\n      testFeatures = JSON.parse(json);\n      if (Array.isArray(testFeatures)) {\n        testFeatures = {\n          type: 'FeatureCollection',\n          features: testFeatures\n        };\n      }\n      // eslint-disable-next-line\n      console.log('Loaded JSON:', testFeatures);\n      this.setState({ testFeatures });\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  _error = (err: any) => {\n    // eslint-disable-next-line\n    alert(err);\n  };\n\n  _getHtmlColorForFeature(index: number, selected: boolean) {\n    const length = FEATURE_COLORS.length;\n    const color = FEATURE_COLORS[index % length].map(c => c * 255).join(',');\n    const alpha = selected ? 1.0 : 0.7;\n\n    return `rgba(${color}, ${alpha})`;\n  }\n\n  _getDeckColorForFeature(index: number, bright: number, alpha: number) {\n    const length = FEATURE_COLORS.length;\n    const color = FEATURE_COLORS[index % length].map(c => c * bright * 255);\n\n    return [...color, alpha * 255];\n  }\n\n  _renderSelectFeatureCheckbox(index: number, featureType: string) {\n    const { selectedFeatureIndexes } = this.state;\n    return (\n      <div key={index}>\n        <ToolboxCheckbox\n          style={styles.checkbox}\n          type=\"checkbox\"\n          checked={selectedFeatureIndexes.includes(index)}\n          onChange={() => {\n            if (selectedFeatureIndexes.includes(index)) {\n              this.setState({\n                selectedFeatureIndexes: selectedFeatureIndexes.filter(e => e !== index)\n              });\n            } else {\n              this.setState({\n                selectedFeatureIndexes: [...selectedFeatureIndexes, index]\n              });\n            }\n          }}\n        >\n          <span\n            style={{\n              color: this._getHtmlColorForFeature(index, selectedFeatureIndexes.includes(index))\n            }}\n          >\n            {index}\n            {': '}\n            {featureType}\n          </span>\n          <a\n            style={{ position: 'absolute', right: 12 }}\n            onClick={e => {\n              e.preventDefault();\n              e.stopPropagation();\n              this.setState({\n                selectedFeatureIndexes: [index],\n                featureMenu: { index, x: e.clientX, y: e.clientY }\n              });\n            }}\n          >\n            &gt;&gt;\n          </a>\n        </ToolboxCheckbox>\n      </div>\n    );\n  }\n\n  _renderSelectFeatureCheckboxes() {\n    const {\n      testFeatures: { features }\n    } = this.state;\n    const checkboxes = [];\n    for (let i = 0; i < features.length; ++i) {\n      checkboxes.push(this._renderSelectFeatureCheckbox(i, features[i].geometry.type));\n    }\n    return checkboxes;\n  }\n\n  _renderBooleanOperationControls() {\n    const operations = ['union', 'difference', 'intersection'];\n    return (\n      <ToolboxRow key=\"booleanOperations\">\n        <ToolboxTitle>\n          Boolean operation<br />(requires single selection)\n        </ToolboxTitle>\n        <ToolboxControl>\n          {operations.map(operation => (\n            <ToolboxButton\n              key={operation}\n              selected={\n                this.state.modeConfig && this.state.modeConfig.booleanOperation === operation\n              }\n              onClick={() => {\n                if (this.state.modeConfig && this.state.modeConfig.booleanOperation === operation) {\n                  this.setState({ modeConfig: null });\n                } else {\n                  this.setState({ modeConfig: { booleanOperation: operation } });\n                }\n              }}\n            >\n              {operation}\n            </ToolboxButton>\n          ))}\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderDrawLineStringModeControls() {\n    return (\n      <ToolboxRow key=\"drawLineString\">\n        <ToolboxTitle>Draw LineString At Front</ToolboxTitle>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.drawAtFront)}\n            onChange={event =>\n              this.setState({\n                modeConfig: {\n                  drawAtFront: Boolean(event.target.checked)\n                }\n              })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderModifyModeControls() {\n    return (\n      <ToolboxRow key=\"modify\">\n        <ToolboxTitle>Allow removing points</ToolboxTitle>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={this.state.pointsRemovable}\n            onChange={() => this.setState({ pointsRemovable: !this.state.pointsRemovable })}\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSplitModeControls() {\n    return (\n      <ToolboxRow key=\"split\">\n        <ToolboxTitle>Constrain to 90&deg;</ToolboxTitle>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.lock90Degree)}\n            onChange={event =>\n              this.setState({ modeConfig: { lock90Degree: Boolean(event.target.checked) } })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSnappingControls() {\n    return (\n      <div key=\"snap\">\n        <ToolboxRow>\n          <ToolboxTitle>Enable snapping</ToolboxTitle>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={Boolean(this.state.modeConfig && this.state.modeConfig.enableSnapping)}\n              onChange={event => {\n                const modeConfig = {\n                  ...this.state.modeConfig,\n                  enableSnapping: Boolean(event.target.checked)\n                };\n                this.setState({ modeConfig });\n              }}\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n      </div>\n    );\n  }\n\n  _renderModeConfigControls() {\n    const controls = [];\n\n    if (POLYGON_DRAWING_MODES.indexOf(this.state.mode) > -1) {\n      controls.push(this._renderBooleanOperationControls());\n    }\n    if (this.state.mode === DrawLineStringMode) {\n      controls.push(this._renderDrawLineStringModeControls());\n    }\n    if (this.state.mode === ModifyMode) {\n      controls.push(this._renderModifyModeControls());\n    }\n    if (this.state.mode === SplitPolygonMode) {\n      controls.push(this._renderSplitModeControls());\n    }\n    if (this.state.mode instanceof SnappableMode) {\n      controls.push(this._renderSnappingControls());\n    }\n\n    return controls;\n  }\n\n  _renderToolBox() {\n    return (\n      <Toolbox>\n        {ALL_MODES.map(category => (\n          <ToolboxRow key={category.category}>\n            <ToolboxTitle>{category.category} Modes</ToolboxTitle>\n            {category.modes.map(({ mode, label }) => (\n              <ToolboxButton\n                key={label}\n                selected={this.state.mode === mode}\n                onClick={() => {\n                  this.setState({ mode, modeConfig: {}, selectionTool: null });\n                }}\n              >\n                {label}\n              </ToolboxButton>\n            ))}\n          </ToolboxRow>\n        ))}\n        {this._renderModeConfigControls()}\n        {this.state.showGeoJson && (\n          <React.Fragment>\n            <ToolboxTitle>GeoJSON</ToolboxTitle>\n            <ToolboxButton onClick={() => this.setState({ showGeoJson: !this.state.showGeoJson })}>\n              hide &#9650;\n            </ToolboxButton>\n            <ToolboxControl>\n              <textarea\n                id=\"geo-json-text\"\n                rows={5}\n                style={{ width: '100%' }}\n                value={JSON.stringify(this.state.testFeatures)}\n                onChange={event => this.setState({ testFeatures: JSON.parse(event.target.value) })}\n              />\n            </ToolboxControl>\n          </React.Fragment>\n        )}\n        {!this.state.showGeoJson && (\n          <React.Fragment>\n            <ToolboxTitle>GeoJSON</ToolboxTitle>\n            <ToolboxButton onClick={() => this.setState({ showGeoJson: !this.state.showGeoJson })}>\n              show &#9660;\n            </ToolboxButton>\n          </React.Fragment>\n        )}\n        <ToolboxButton onClick={() => this._copy()}>Copy</ToolboxButton>\n        <ToolboxButton onClick={() => this._paste()}>Paste</ToolboxButton>\n        <ToolboxButton onClick={() => this._download()}>Download</ToolboxButton>\n        <ToolboxRow>\n          <ToolboxTitle>Load data</ToolboxTitle>\n          <ToolboxControl>\n            <ToolboxButton onClick={() => this._loadSample('mixed')}>Mixed Sample</ToolboxButton>\n            <ToolboxButton onClick={() => this._loadSample('complex')}>\n              Complex Sample\n            </ToolboxButton>\n            <ToolboxButton onClick={() => this._loadSample('blank')}>Blank</ToolboxButton>\n            <ToolboxButton onClick={() => this._loadSample('file')}>Open file...</ToolboxButton>\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxTitle>Options</ToolboxTitle>\n          <ToolboxControl>\n            <ToolboxCheckbox\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'icon'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'icon' ? 'point' : 'icon'\n                })\n              }\n            >\n              Use Icons\n            </ToolboxCheckbox>\n          </ToolboxControl>\n\n          <ToolboxControl>\n            <ToolboxCheckbox\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'elevated'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'elevated' ? 'point' : 'elevated'\n                })\n              }\n            >\n              Use ElevatedEditHandleLayer\n            </ToolboxCheckbox>\n          </ToolboxControl>\n\n          <ToolboxControl>\n            <ToolboxCheckbox\n              type=\"checkbox\"\n              checked={this.state.pathMarkerLayer}\n              onChange={() =>\n                this.setState({\n                  pathMarkerLayer: !this.state.pathMarkerLayer\n                })\n              }\n            >\n              Use PathMarkerLayer\n            </ToolboxCheckbox>\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxTitle>Select Features</ToolboxTitle>\n          <ToolboxControl>\n            <ToolboxButton\n              onClick={() =>\n                this.setState({ selectedFeatureIndexes: [], selectionTool: SELECTION_TYPE.NONE })\n              }\n            >\n              Clear Selection\n            </ToolboxButton>\n            <ToolboxButton\n              onClick={() =>\n                this.setState({ mode: ViewMode, selectionTool: SELECTION_TYPE.RECTANGLE })\n              }\n            >\n              Rect Select\n            </ToolboxButton>\n            <ToolboxButton\n              onClick={() =>\n                this.setState({ mode: ViewMode, selectionTool: SELECTION_TYPE.POLYGON })\n              }\n            >\n              Lasso Select\n            </ToolboxButton>\n          </ToolboxControl>\n        </ToolboxRow>\n        <ToolboxTitle>Features</ToolboxTitle>\n        <ToolboxRow>{this._renderSelectFeatureCheckboxes()}</ToolboxRow>\n      </Toolbox>\n    );\n  }\n\n  renderStaticMap(viewport: Object) {\n    return <StaticMap {...viewport} mapStyle={'mapbox://styles/mapbox/dark-v10'} />;\n  }\n\n  _featureMenuClick(action: string) {\n    const { index } = this.state.featureMenu || {};\n    let testFeatures = this.state.testFeatures;\n\n    if (action === 'delete') {\n      const features = [...testFeatures.features];\n      features.splice(index, 1);\n      testFeatures = Object.assign({}, testFeatures, {\n        features\n      });\n    } else if (action === 'split') {\n      // TODO\n    } else if (action === 'info') {\n      // eslint-disable-next-line\n      console.log(testFeatures.features[index]);\n    }\n\n    this.setState({ featureMenu: null, testFeatures });\n  }\n\n  _renderFeatureMenu({ x, y, index }: Object) {\n    return (\n      <div style={{ position: 'fixed', top: y - 40, left: x + 20 }}>\n        <ToolboxButton onClick={() => this._featureMenuClick('delete')}>Delete</ToolboxButton>\n        <ToolboxButton onClick={() => this._featureMenuClick('split')}>Split</ToolboxButton>\n        <ToolboxButton onClick={() => this._featureMenuClick('info')}>Info</ToolboxButton>\n        <ToolboxButton onClick={() => this._featureMenuClick('')}>Close</ToolboxButton>\n      </div>\n    );\n  }\n\n  customizeLayers(layers: Object[]) {}\n\n  onEdit = ({ updatedData, editType, editContext }) => {\n    let updatedSelectedFeatureIndexes = this.state.selectedFeatureIndexes;\n    if (!['movePosition', 'extruding', 'rotating', 'translating', 'scaling'].includes(editType)) {\n      // Don't log edits that happen as the pointer moves since they're really chatty\n      const updatedDataInfo = featuresToInfoString(updatedData);\n      // eslint-disable-next-line\n      console.log('onEdit', editType, editContext, updatedDataInfo);\n    }\n    if (editType === 'removePosition' && !this.state.pointsRemovable) {\n      // This is a simple example of custom handling of edits\n      // reject the edit\n      return;\n    }\n    if (editType === 'addFeature' && this.state.mode !== DuplicateMode) {\n      const { featureIndexes } = editContext;\n      // Add the new feature to the selection\n      updatedSelectedFeatureIndexes = [...this.state.selectedFeatureIndexes, ...featureIndexes];\n    }\n    this.setState({\n      testFeatures: updatedData,\n      selectedFeatureIndexes: updatedSelectedFeatureIndexes\n    });\n  };\n\n  getFillColor = (feature, isSelected) => {\n    const index = this.state.testFeatures.features.indexOf(feature);\n    return isSelected\n      ? this._getDeckColorForFeature(index, 1.0, 0.5)\n      : this._getDeckColorForFeature(index, 0.5, 0.5);\n  };\n\n  getLineColor = (feature, isSelected) => {\n    const index = this.state.testFeatures.features.indexOf(feature);\n    return isSelected\n      ? this._getDeckColorForFeature(index, 1.0, 1.0)\n      : this._getDeckColorForFeature(index, 0.5, 1.0);\n  };\n\n  render() {\n    const { testFeatures, selectedFeatureIndexes, mode } = this.state;\n    let { modeConfig } = this.state;\n\n    const viewport = {\n      ...this.state.viewport,\n      height: window.innerHeight,\n      width: window.innerWidth\n    };\n\n    if (mode === ElevationMode) {\n      modeConfig = {\n        ...modeConfig,\n        viewport,\n        calculateElevationChange: opts =>\n          ElevationMode.calculateElevationChangeWithViewport(viewport, opts)\n      };\n    } else if (mode === ModifyMode) {\n      modeConfig = {\n        ...modeConfig,\n        viewport\n      };\n    } else if (mode instanceof SnappableMode && modeConfig && modeConfig.enableSnapping) {\n      // Snapping can be accomplished to features that aren't rendered in the same layer\n      modeConfig = {\n        ...modeConfig,\n        additionalSnapTargets: [\n          {\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'Polygon',\n              coordinates: [\n                [\n                  [-122.52235, 37.734008],\n                  [-122.52217, 37.712706],\n                  [-122.49436, 37.711979],\n                  [-122.49725, 37.734306],\n                  [-122.52235, 37.734008]\n                ]\n              ]\n            }\n          }\n        ]\n      };\n    }\n\n    // Demonstrate how to override sub layer properties\n    let _subLayerProps = null;\n    if (this.state.editHandleType === 'elevated') {\n      _subLayerProps = {\n        guides: {\n          _subLayerProps: {\n            points: {\n              type: ElevatedEditHandleLayer,\n              getFillColor: [0, 255, 0]\n            }\n          }\n        }\n      };\n    }\n\n    if (this.state.pathMarkerLayer) {\n      _subLayerProps = Object.assign(_subLayerProps || {}, {\n        geojson: {\n          _subLayerProps: {\n            'line-strings': {\n              type: PathMarkerLayer,\n              getMarkerColor: x => [255, 255, 255, 255],\n              sizeScale: 1500\n            }\n          }\n        }\n      });\n    }\n\n    const editableGeoJsonLayer = new EditableGeoJsonLayer({\n      id: 'geojson',\n      data: testFeatures,\n      selectedFeatureIndexes,\n      mode,\n      modeConfig,\n      autoHighlight: false,\n\n      // Editing callbacks\n      onEdit: this.onEdit,\n\n      editHandleType: this.state.editHandleType,\n\n      // test using icons for edit handles\n      editHandleIconAtlas: iconSheet,\n      editHandleIconMapping: {\n        intermediate: {\n          x: 0,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        },\n        existing: {\n          x: 58,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        }\n      },\n      getEditHandleIcon: d => getEditHandleTypeFromEitherLayer(d),\n      getEditHandleIconSize: 40,\n      getEditHandleIconColor: getEditHandleColor,\n\n      // Specify the same GeoJsonLayer props\n      // lineWidthMinPixels: 2,\n      pointRadiusMinPixels: 5,\n      // getLineDashArray: () => [0, 0],\n\n      // Accessors receive an isSelected argument\n      getFillColor: this.getFillColor,\n      getLineColor: this.getLineColor,\n\n      // Can customize editing points props\n      getEditHandlePointColor: getEditHandleColor,\n      editHandlePointRadiusScale: 2,\n\n      // customize tentative feature style\n      // getTentativeLineDashArray: () => [7, 4],\n      // getTentativeLineColor: () => [0x8f, 0x8f, 0x8f, 0xff],\n\n      _subLayerProps,\n\n      parameters: {\n        depthTest: true,\n        depthMask: false,\n\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA]\n      }\n    });\n\n    const layers = [editableGeoJsonLayer];\n\n    if (this.state.selectionTool) {\n      layers.push(\n        new SelectionLayer({\n          id: 'selection',\n          selectionType: this.state.selectionTool,\n          onSelect: ({ pickingInfos }) => {\n            this.setState({ selectedFeatureIndexes: pickingInfos.map(pi => pi.index) });\n          },\n          layerIds: ['geojson'],\n\n          getTentativeFillColor: () => [255, 0, 255, 100],\n          getTentativeLineColor: () => [0, 0, 255, 255],\n          getTentativeLineDashArray: () => [0, 0],\n          lineWidthMinPixels: 3\n        })\n      );\n    }\n\n    this.customizeLayers(layers);\n\n    return (\n      <div style={styles.mapContainer}>\n        <link href=\"https://api.mapbox.com/mapbox-gl-js/v0.44.0/mapbox-gl.css\" rel=\"stylesheet\" />\n        <DeckGL\n          viewState={viewport}\n          getCursor={editableGeoJsonLayer.getCursor.bind(editableGeoJsonLayer)}\n          layers={layers}\n          views={\n            new MapView({\n              id: 'basemap',\n              controller: {\n                type: MapController,\n                doubleClickZoom: this.state.mode === 'view' && !this.state.selectionTool\n              }\n            })\n          }\n          onClick={this._onLayerClick}\n          onViewStateChange={({ viewState }) => this.setState({ viewport: viewState })}\n        >\n          {this.renderStaticMap(viewport)}\n        </DeckGL>\n        {this._renderToolBox()}\n        {this.state.featureMenu && this._renderFeatureMenu(this.state.featureMenu)}\n      </div>\n    );\n  }\n}\n\nfunction featuresToInfoString(featureCollection: any): string {\n  const info = featureCollection.features.map(\n    feature => `${feature.geometry.type}(${getPositionCount(feature.geometry)})`\n  );\n\n  return JSON.stringify(info);\n}\n\nfunction getPositionCount(geometry): number {\n  const flatMap = (f, arr) => arr.reduce((x, y) => [...x, ...f(y)], []);\n\n  const { type, coordinates } = geometry;\n  switch (type) {\n    case 'Point':\n      return 1;\n    case 'LineString':\n    case 'MultiPoint':\n      return coordinates.length;\n    case 'Polygon':\n    case 'MultiLineString':\n      return flatMap(x => x, coordinates).length;\n    case 'MultiPolygon':\n      return flatMap(x => flatMap(y => y, x), coordinates).length;\n    default:\n      throw Error(`Unknown geometry type: ${type}`);\n  }\n}\n","import React, { Component } from 'react';\nimport styled from 'styled-components';\n\nimport Example from '../../../examples/advanced/example';\n\nconst Container = styled.div`\n  width: 100%;\n  height: calc(100vh - 4rem);\n  margin-top: 4rem;\n`;\n\nexport default class GeoJsonEditor extends Component {\n  render() {\n    return (\n      <Container id=\"geoJsonEditorContainer\">\n        <Example />\n      </Container>\n    );\n  }\n}\n","module.exports = \"data:image/png;base64,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\""],"sourceRoot":""}