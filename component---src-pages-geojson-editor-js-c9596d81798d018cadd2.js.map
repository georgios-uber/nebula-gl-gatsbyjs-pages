{"version":3,"sources":["webpack:///../modules/main/src/lib/style.js","webpack:///../modules/main/src/lib/deck-renderer/deck-drawer.js","webpack:///../modules/main/src/lib/nebula-layer.js","webpack:///../modules/edit-modes/src/lib/edit-mode.js","webpack:///../modules/edit-modes/src/lib/immutable-feature-collection.js","webpack:///../modules/edit-modes/src/lib/geojson-edit-mode.js","webpack:///../modules/edit-modes/src/lib/view-mode.js","webpack:///../modules/edit-modes/src/lib/draw-polygon-mode.js","webpack:///../modules/layers/src/mode-handlers/mode-handler.js","webpack:///../modules/layers/src/mode-handlers/view-handler.js","webpack:///../modules/layers/src/utils.js","webpack:///../modules/layers/src/mode-handlers/modify-handler.js","webpack:///../modules/layers/src/mode-handlers/elevation-handler.js","webpack:///../modules/layers/src/mode-handlers/snappable-handler.js","webpack:///../modules/layers/src/mode-handlers/translate-handler.js","webpack:///../modules/layers/src/mode-handlers/duplicate-handler.js","webpack:///../modules/layers/src/mode-handlers/rotate-handler.js","webpack:///../modules/layers/src/mode-handlers/scale-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-point-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-line-string-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-90degree-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/two-click-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-rectangle-handler.js","webpack:///../modules/layers/src/mode-handlers/split-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/three-click-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-rectangle-using-three-points-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-circle-from-center-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-circle-by-bounding-box-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-ellipse-by-bounding-box-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-ellipse-using-three-points-handler.js","webpack:///../modules/layers/src/mode-handlers/extrude-handler.js","webpack:///../modules/layers/src/layers/editable-layer.js","webpack:///../modules/layers/src/layers/editable-geojson-layer.js","webpack:///../modules/layers/src/layers/editable-layer-edit-mode-poc.js","webpack:///../modules/layers/src/layers/editable-geojson-layer-edit-mode-poc.js","webpack:///../modules/layers/src/layers/selection-layer.js","webpack:///../modules/layers/src/layers/elevated-edit-handle-layer.js","webpack:///../modules/layers/src/shaderlib/outline/outline.js","webpack:///../modules/layers/src/layers/path-outline-layer/path-outline-layer.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer-vertex.glsl.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer-fragment.glsl.js","webpack:///../modules/layers/src/layers/path-marker-layer/arrow-2d-geometry.js","webpack:///../modules/layers/src/layers/path-marker-layer/create-path-markers.js","webpack:///../modules/layers/src/layers/path-marker-layer/polyline.js","webpack:///../modules/layers/src/layers/path-marker-layer/path-marker-layer.js","webpack:///../modules/layers/src/layers/junction-scatterplot-layer.js","webpack:///../modules/layers/src/mode-handlers/composite-mode-handler.js","webpack:///../modules/main/src/lib/layers/segments-layer.js","webpack:///../examples/deck/toolbox.js","webpack:///../examples/deck/example.js","webpack:///./src/pages/geojson-editor.js","webpack:///../examples/data/edit-handles.png"],"names":["ArrowStyles","SELECTION_TYPE","EventEmitter","BaseEditMode","_proto","prototype","getState","this","state","updateState","_this","prevState","changedEvents","data","modeConfig","selectedIndexes","guides","fn","handleClick","handlePointerMove","handleStartDragging","handleStopDragging","onDataChanged","onModeConfigChanged","onSelectedIndexesChanged","onGuidesChanged","getData","getModeConfig","getSelectedIndexes","getGuides","getCursor","cursor","onEdit","editAction","onUpdateGuides","onUpdateCursor","ImmutableFeatureCollection","featureCollection","getObject","replacePosition","geometry","features","featureIndex","isPolygonal","updatedGeometry","Object","assign","coordinates","immutablyReplacePosition","positionIndexes","updatedPosition","replaceGeometry","removePosition","Error","immutablyRemovePosition","type","polygon","holeIndex","length","removeHoleIfNecessary","prunePolygonIfNecessary","lineStringIndex","lineString","pruneMultiLineStringIfNecessary","polygonIndex","outerRing","pruneMultiPolygonIfNecessary","pruneGeometryIfNecessary","addPosition","immutablyAddPosition","positionToAdd","updatedFeature","concat","slice","addFeature","feature","getUpdatedPosition","previousPosition","elevation","updated","hole","DEFAULT_EDIT_HANDLES","BaseGeoJsonEditMode","_BaseEditMode","call","_clickSequence","setFeatureCollection","inheritsLoose_default","getFeatureCollection","getImmutableFeatureCollection","getSelectedFeature","getSelectedGeometry","getSelectedFeaturesAsFeatureCollection","getSelectedFeatureIndexes","map","selectedIndex","_refreshEditHandles","setModeConfig","console","setSelectedFeatureIndexes","_setTentativeFeature","tentativeFeature","getClickSequence","resetClickSequence","getTentativeFeature","getEditHandles","editHandles","getEditHandlesAdapter","picks","mapCoords","_refreshCursor","currentCursor","updatedCursor","getCursorAdapter","isDragging","_ref3","isSelectionPicked","pickedIndexes","_ref4","index","some","getAddFeatureAction","geometryAsAny","updatedData","properties","editType","editContext","featureIndexes","getAddManyFeaturesAction","initialIndex","updatedIndexes","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref5","next","done","value","getAddFeatureOrBooleanPolygonAction","selectedFeature","booleanOperation","turfUnion","turfDifference","turfIntersect","handleClickAdapter","event","_this$handlePointerMo","handlePointerMoveAdapter","cancelMapPan","handleStartDraggingAdapter","handleStopDraggingAdapter","push","getEditHandlesForCoordinates","positionIndexPrefix","editHandleType","i","position","ViewMode","_BaseGeoJsonEditMode","apply","arguments","geojson_edit_mode_BaseGeoJsonEditMode","DrawPolygonMode","handles","a","b","_a","getEditHandlesForGeometry","clickedEditHandle","info","find","pick","isGuide","object","getPickedEditHandle","clickSequence","polygonToAdd","fakePointerMoveEvent","screenCoords","pointerDownPicks","pointerDownScreenCoords","pointerDownMapCoords","sourceEvent","_ref","result","ModeHandler","_modeConfig","_selectedFeatureIndexes","indexes","_tentativeFeature","_ref2","groundCoords","mode_handler_getPickedEditHandle","isEditingHandle","mode_handler_getIntermediatePosition","position1","position2","mode_handler_getEditHandlesForGeometry","mode_handler_getEditHandlesForCoordinates","ViewHandler","_ModeHandler","mode_handler_ModeHandler","generatePointsParallelToLinePoints","p1","p2","pt","point","ddistance","pointToLineDistance","lineBearing","bearing","orthogonalBearing","isPointToLeftOfLine","p3","destination","p4","ModifyHandler","_handles","_index","featureAsPick","includes","intermediatePoint","referencePoint","recursivelyTraverseNestedArrays","array","prefix","lineStringFeature","toLineString","candidateIntermediatePoint","nearestPointOnLine","dist","_intermediatePoint","line","inPoint","ignored","_updatedData","_lastPointerMovePicks","editHandle","Boolean","selectedFeatureIndexes","defaultCalculateElevationChange","ElevationHandler","_ModifyHandler","makeElevatedEvent","_ref2$minElevation","minElevation","_ref2$maxElevation","maxElevation","_ref2$calculateElevat","calculateElevationChange","Math","params","calculateElevationChangeWithViewport","viewport","PI","zoom","modify_handler_ModifyHandler","SnappableHandler","handler","_handler","_getSnappedMouseEvent","snapPoint","pointerDownGroundCoords","_startDragSnapHandlePosition","_getEditHandlePicks","potentialSnapHandle","pickedHandle","_updatePickedHandlePosition","_editHandlePicks","reduce","_getSnapTargets","additionalSnapTargets","_getNonPickedIntermediateHandles","enableSnapping","_performSnapIfRequired","_isSnapped","_ref6","_performUnsnapIfRequired","_getSnapAwareEvent","modeActionSummary","TranslateHandler","_isTranslatable","_geometryBeforeTranslate","getTranslateAction","startDragPoint","currentPoint","distanceMoved","turfDistance","direction","turfBearing","movedFeatures","turfTransformTranslate","movedFeature","DuplicateHandler","_TranslateHandler","translate_handler_TranslateHandler","RotateHandler","_isRotatable","_geometryBeingRotated","getRotateAction","startPosition","angle","centroid","bearing1","getRotationAngle","turfCentroid","rotatedFeatures","turfTransformRotate","ScaleHandler","_isScalable","_geometryBeingScaled","getScaleAction","factor","startDistance","getScaleFactor","scaledFeatures","turfTransformScale","origin","DrawPointHandler","DrawLineStringHandler","selectedGeometry","drawAtFront","DrawPolygonHandler","Draw90DegreePolygonHandler","finalizedCoordinates","coords","getIntermediatePoint","tc","angle1","angle2","angles","first","second","forEach","newAngle1","newAngle2","distance","indexFirst","line1","indexSecond","line2","fc","lineIntersect","TwoClickPolygonHandler","DrawRectangleHandler","_TwoClickPolygonHandl","corner1","corner2","bboxPolygon","two_click_polygon_handler_TwoClickPolygonHandler","SplitPolygonHandler","calculateGroundCoords","lock90Degree","firstPoint","turfPolygonToLine","lines","minDistance","Number","MAX_SAFE_INTEGER","closestPoint","distanceFromOrigin","lastBearing","currentDistance","units","destination_default","lastPoint","approximatePoint","isPointInPolygon","booleanPointInPolygon","isLineInterectingWithPolygon","splitPolygon","_modeConfig$gap","gap","_modeConfig$units","buffer","turfBuffer","_updatedGeometry$geom","updatedCoordinates","c","agg","prev","p","ThreeClickPolygonHandler","DrawRectangleUsingThreePointsHandler","_ThreeClickPolygonHan","_generatePointsParall","three_click_polygon_handler_ThreeClickPolygonHandler","DrawCircleFromCenterHandler","_modeConfig$steps","steps","options","centerCoordinates","radius","circle","DrawCircleByBoundingBoxHandler","firstClickedPoint","getIntermediatePosition","DrawEllipseByBoundingBoxHandler","minX","minY","maxX","maxY","polygonPoints","xSemiAxis","ySemiAxis","ellipse","DrawEllipseUsingThreePointsHandler","ExtrudeHandler","_len","args","_key","isPointAdded","size","coordinatesSize","nextPositionIndexes","getPointForPositionIndexes","prevPositionIndexes","isOrthogonal","_generatePointsParall2","getBearing","prevPoint","nextPoint","prevAngle","nextAngle","EditableLayer","onLayerClick","onDoubleClick","onStartDragging","onStopDragging","onPointerMove","initializeState","setState","_editableLayerState","pointerHandlers","finalizeState","_removePointerHandlers","props","changeFlags","_addPointerHandlers","context","gl","canvas","removeEventListener","onPointerDown","onPointerUp","_onPointerMove","bind","_onPointerDown","_onPointerUp","_onDoubleClick","addEventListener","getScreenCoords","getGroundCoords","deck","pickMultipleObjects","x","y","layerIds","id","pickingRadius","depth","pickingDepth","_this$state$_editable","movedEnoughForDrag","_this$state$_editable2","pointerEvent","getBoundingClientRect","unproject","screenCoords1","screenCoords2","CompositeLayer","DEFAULT_LINE_COLOR","DEFAULT_FILL_COLOR","DEFAULT_SELECTED_LINE_COLOR","DEFAULT_SELECTED_FILL_COLOR","DEFAULT_EDITING_EXISTING_POINT_COLOR","DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","DEFAULT_EDITING_SNAP_POINT_COLOR","DEFAULT_EDITING_EXISTING_POINT_RADIUS","DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","DEFAULT_EDITING_SNAP_POINT_RADIUS","getEditHandleColor","handle","defaultProps","mode","pickable","fp64","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","lineWidthUnits","lineJointRounded","lineMiterLimit","pointRadiusScale","pointRadiusMinPixels","pointRadiusMaxPixels","lineDashJustified","getLineColor","isSelected","getFillColor","getRadius","f","getLineWidth","lineWidth","getLineDashArray","getTentativeLineDashArray","getTentativeLineColor","getTentativeFillColor","getTentativeLineWidth","editHandleParameters","editHandleLayerProps","editHandlePointRadiusScale","editHandlePointOutline","editHandlePointStrokeWidth","editHandlePointRadiusMinPixels","editHandlePointRadiusMaxPixels","getEditHandlePointColor","getEditHandlePointRadius","editHandleIconAtlas","editHandleIconMapping","editHandleIconSizeScale","getEditHandleIcon","getEditHandleIconSize","getEditHandleIconColor","getEditHandleIconAngle","billboard","modeHandlers","view","view_handler_ViewHandler","modify","elevation_handler_ElevationHandler","extrude","extrude_handler_ExtrudeHandler","rotate","rotate_handler_RotateHandler","translate","snappable_handler_SnappableHandler","duplicate","duplicate_handler_DuplicateHandler","scale","scale_handler_ScaleHandler","drawPoint","draw_point_handler_DrawPointHandler","drawLineString","draw_line_string_handler_DrawLineStringHandler","drawPolygon","draw_polygon_handler_DrawPolygonHandler","draw90DegreePolygon","draw_90degree_polygon_handler_Draw90DegreePolygonHandler","split","split_polygon_handler_SplitPolygonHandler","drawRectangle","draw_rectangle_handler_DrawRectangleHandler","drawRectangleUsing3Points","draw_rectangle_using_three_points_handler_DrawRectangleUsingThreePointsHandler","drawCircleFromCenter","draw_circle_from_center_handler_DrawCircleFromCenterHandler","drawCircleByBoundingBox","draw_circle_by_bounding_box_handler_DrawCircleByBoundingBoxHandler","drawEllipseByBoundingBox","draw_ellipse_by_bounding_box_handler_DrawEllipseByBoundingBoxHandler","drawEllipseUsing3Points","draw_ellipse_using_three_points_handler_DrawEllipseUsingThreePointsHandler","EditableGeoJsonLayer","renderLayers","subLayerProps","getSubLayerProps","selectionAwareAccessor","_subLayerProps","line-strings","polygons-stroke","updateTriggers","layers","geojson_layer","_EditableLayer","selectedFeatures","shouldUpdateState","oldProps","oldContext","stateChanged","modeHandler","propsOrDataChanged","dataChanged","updateTentativeFeature","updateEditHandles","elem","accessor","isFeatureSelected","indexOf","getPickingInfo","sourceLayer","createEditHandleLayers","layer","sharedProps","layerName","parameters","icon_layer","iconAtlas","iconMapping","sizeScale","getIcon","getSize","getColor","getAngle","getPosition","d","scatterplot_layer","radiusScale","outline","strokeWidth","radiusMinPixels","radiusMaxPixels","EditHandleType","createTentativeLayers","_this2","autoHighlight","setLayerNeedsUpdate","_this$state$modeHandl","EditableLayer_EDIT_MODE_POC","getMapCoords","editable_geojson_layer_edit_mode_poc_getEditHandleColor","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_EXISTING_POINT_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_SNAP_POINT_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_SELECTED_LINE_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_LINE_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_SELECTED_FILL_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_FILL_COLOR","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_EXISTING_POINT_RADIUS","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_SNAP_POINT_RADIUS","editable_geojson_layer_edit_mode_poc_DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","view_mode_ViewMode","draw_polygon_mode_DrawPolygonMode","EditableGeoJsonLayer_EDIT_MODE_POC","partialState","updateModeState","setNeedsRedraw","_this3","getActiveModeHandler","selectionType","onSelect","EMPTY_DATA","PASS_THROUGH_PROPS","SelectionLayer","_selectRectangleObjects","_this$props","_this$context$viewpor","project","x1","y1","_this$context$viewpor2","x2","y2","pickingInfos","pickObjects","width","height","_selectPolygonObjects","bigPolygon","_this$props2","mousePoints","allX","mousePoint","allY","landPointsPoly","bigBuffer","e","pendingPolygonSelection","blockerId","setTimeout","filter","item","_SELECTION_TYPE$RECTA","inheritedProps","undefined","editable_geojson_layer_EditableGeoJsonLayer","polygon_layer","opacity","obj","getPolygon","o","_ref2$changeFlags","ElevatedEditHandleLayer","line_layer","getSourcePosition","getTargetPosition","getStrokeWidth","INITIAL_STATE","outlineEnabled","outlineRenderShadowmap","outlineShadowmap","name","vs","fs","getUniforms","_temp","uniforms","injectShaderCode","source","_ref$code","code","PathOutlineLayer","getShaders","shaders","_PathLayer","modules","outlineFramebuffer","core_dist_esm","dummyTexture","attributeManager","addInstanced","instanceZLevel","GL","UNSIGNED_BYTE","update","calculateZLevels","draw","moduleParameters","rounded","miterLimit","widthScale","widthMinPixels","widthMaxPixels","dashJustified","jointType","alignMode","_this$state","color","model","updateModuleSettings","depthTest","blendEquation","MAX","framebuffer","getZLevel","pathTesselator","attribute","_updateAttribute","target","getValue","PathLayer","fp64LowPart","RADIAN_PER_DEGREE","getTexture","src","opts","urls","then","textures","catch","error","Promise","resolve","getTextureFromData","validateGeometryAttributes","attributes","condition","message","assert","getGeometry","positions","mesh","texture","min","depthFunc","LEQUAL","lightSettings","getYaw","getPitch","getRoll","MeshLayer","use64bitProjection","getAttributeManager","instancePositions","instancePositions64xy","calculateInstancePositions64xyLow","instanceRotations","calculateInstanceRotations","instanceColors","defaultValue","emptyTexture","Uint8Array","_updateFP64","setTexture","delete","getModel","render","isInstanced","shaderCache","sampler","hasTexture","setUniforms","isFP64","use64bitPositions","Float32Array","_iterator2","_isArray2","_i2","Layer","Arrow2DGeometry","_Geometry","getArrowAttributes","Geometry","_ref$length","_ref$headSize","headSize","_ref$tailWidth","tailWidth","_ref$tailStart","tailStart","texCoords","i3","normals","getLineLength","vPoints","lineLength","DEFAULT_COLOR","DEFAULT_DIRECTION","forward","backward","createMarkerAlongPath","path","percentage","projectFlat","distanceAlong","previousDistance","along","vCenter","normalize","vDirection","vector2","subtract","verticalAngle","getClosestPointOnLine","_ref$clampToLine","clampToLine","lineVector","vector3","pointVector","dotProduct","clamp","DEFAULT_MARKER_LAYER","mesh_layer_MeshLayer","DEFAULT_MARKER_LAYER_PROPS","arrow_2d_geometry_Arrow2DGeometry","MarkerLayer","markerLayerProps","hightlightIndex","highlightPoint","getPath","getMarkerColor","getDirection","getMarkerPercentages","PathMarkerLayer","markers","coordinateSystem","COORDINATE_SYSTEM","METER_OFFSETS","_viewport$metersToLng","xyz","dx","dy","coordinateOrigin","LNGLAT_OFFSETS","_dx","_y","updateTriggersChanged","_ref$getPath","_ref$getDirection","_ref$getColor","create_path_markers_DEFAULT_COLOR","_ref$getMarkerPercent","vPointsReverse","reverse","marker","createPathMarkers","_recalculateClosestPoint","propsChanged","highlightIndex","points","pClosest","distanceSquared","Infinity","pClosestOnLine","distanceToLineSquared","getClosestPointOnPolyline","closestPoints","path_outline_layer_PathOutlineLayer","blend","JunctionScatterplotLayer","getStrokeColor","getInnerRadius","ScatterplotLayer","CompositeModeHandler","handlers","_coalesce","resultEval","callback","_NEBULA_TO_DECK_DIREC","styles","toolbox","top","left","background","padding","borderRadius","border","fontFamily","fontSize","toolboxRow","display","flexWrap","toolboxRowWrapping","marginBottom","toolboxDivider","borderBottom","toolboxItem","flexBasis","toolboxLabel","ToolboxRow","react_default","createElement","style","children","ToolboxRowWrapping","ToolboxLabel","ToolboxControl","ToolboxDivider","EditableGeoJsonLayerImpl","window","mapContainer","alignItems","checkbox","margin","initialViewport","latitude","longitude","pitch","ALL_MODES","category","modes","POLYGON_DRAWING_MODES","drawLineString+modify","composite_mode_handler_CompositeModeHandler","example_getEditHandleColor","Example","_Component","_onChangeViewport","_onLayerClick","selectionTool","_resize","forceUpdate","_loadSample","testFeatures","sample_geojson","pointsRemovable","showGeoJson","componentDidMount","componentWillUnmount","_renderSelectFeatureCheckbox","toolbox_ToolboxLabel","key","checked","onChange","featureType","_renderSelectFeatureCheckboxes","checkboxes","_renderBooleanOperationControls","toolbox_ToolboxRow","toolbox_ToolboxControl","operation","backgroundColor","onClick","_renderDrawLineStringModeControls","_this4","_renderModifyModeControls","_this5","_renderSplitModeControls","_this6","_renderSnappingControls","_this7","_renderModeConfigControls","controls","_renderToolBox","_this8","ToolboxStyles","toolbox_ToolboxRowWrapping","paddingRight","toolbox_ToolboxDivider","Fragment","rows","JSON","renderStaticMap","dist_esm","customizeLayers","_this9","innerHeight","innerWidth","editableGeoJsonLayer","updatedSelectedFeatureIndexes","elevated_edit_handle_layer_ElevatedEditHandleLayer","edit_handles_default","intermediate","mask","existing","depthMask","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","selection_layer_SelectionLayer","pi","href","rel","esm_deckgl","viewState","views","esm","controller","doubleClickZoom","onViewStateChange","Component","Container","styled","div","withConfig","displayName","componentId","GeoJsonEditor","example_Example","module","exports"],"mappings":"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","file":"component---src-pages-geojson-editor-js-c9596d81798d018cadd2.js","sourcesContent":["// @flow\n// Describes the arrow style of polylines\nexport const ArrowStyles = {\n  NONE: 0,\n  FORWARD: 1,\n  BACKWARD: 2,\n  BOTH: 3\n};\n\nexport const DEFAULT_ARROWS = 1;\nexport const MAX_ARROWS = 3;\n\nexport const DEFAULT_STYLE = {\n  arrowColor: [0, 0, 0, 1],\n  arrowCount: DEFAULT_ARROWS,\n  arrowStyle: ArrowStyles.NONE,\n  fillColor: [0, 0, 0, 1],\n  lineColor: [0, 0, 0, 1],\n  lineWidthMeters: 5,\n  outlineRadiusMeters: 0,\n  opacity: 1,\n  zLevel: 0\n};\n","// @flow\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { point, polygon } from '@turf/helpers';\nimport turfBbox from '@turf/bbox';\nimport turfBboxPolygon from '@turf/bbox-polygon';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\nimport turfDistance from '@turf/distance';\n\nconst POLYGON_LINE_COLOR = [0, 255, 0, 255];\nconst POLYGON_FILL_COLOR = [255, 255, 255, 90];\nconst POLYGON_LINE_WIDTH = 2;\nconst POLYGON_DASHES = [20, 20];\nconst POLYGON_THRESHOLD = 0.01;\nconst EXPANSION_KM = 10;\nconst LAYER_ID_VIEW = 'DeckDrawerView';\nconst LAYER_ID_PICK = 'DeckDrawerPick';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nexport default class DeckDrawer {\n  nebula: Object;\n  usePolygon: boolean;\n  validPolygon: boolean;\n  landPoints: [number, number][];\n  mousePoints: [number, number][];\n\n  constructor(nebula: Object) {\n    this.nebula = nebula;\n    this.usePolygon = false;\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _getLayerIds() {\n    // TODO: sort by mouse priority\n    return this.nebula.deckgl.props.layers\n      .filter(l => l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enableSelection)\n      .map(l => l.id);\n  }\n\n  _selectFromPickingInfos(pickingInfos: Object[]) {\n    const objects = pickingInfos.map(\n      ({ layer, index, object }) =>\n        object.original || layer.props.nebulaLayer.deckCache.originals[index]\n    );\n    this.nebula.props.onSelection(objects);\n  }\n\n  _getBoundingBox(): Object {\n    const { mousePoints } = this;\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    return { x, y, width: maxX - x, height: maxY - y };\n  }\n\n  _selectRectangleObjects() {\n    if (this.landPoints.length !== 2) return;\n\n    const [x1, y1] = this.mousePoints[0];\n    const [x2, y2] = this.mousePoints[1];\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds: this._getLayerIds()\n    });\n\n    this._selectFromPickingInfos(pickingInfos);\n  }\n\n  _selectPolygonObjects() {\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      ...this._getBoundingBox(),\n      layerIds: [LAYER_ID_PICK, ...this._getLayerIds()]\n    });\n\n    this._selectFromPickingInfos(pickingInfos.filter(item => item.layer.id !== LAYER_ID_PICK));\n  }\n\n  _getMousePosFromEvent(event: Object): [number, number] {\n    const { offsetX, offsetY } = event;\n    return [offsetX, offsetY];\n  }\n\n  handleEvent(\n    event: Object,\n    lngLat: [number, number],\n    selectionType: number\n  ): { redraw: boolean, deactivate: boolean } {\n    // capture all events (mouse-up is needed to prevent us stuck in moving map)\n    if (event.type !== 'mouseup') event.stopPropagation();\n\n    this.usePolygon = selectionType === SELECTION_TYPE.POLYGON;\n\n    let redraw = false;\n    let deactivate = false;\n\n    const { usePolygon, landPoints, mousePoints } = this;\n\n    if (event.type === 'mousedown') {\n      if (usePolygon && landPoints.length) {\n        // if landPoints.length is zero we want to insert two points (so we let it run the else)\n        // also don't insert if polygon is invalid\n        if (this.landPoints.length < 3 || this.validPolygon) {\n          landPoints.push(lngLat);\n          mousePoints.push(this._getMousePosFromEvent(event));\n        }\n      } else {\n        this.landPoints = [lngLat, lngLat];\n        const m = this._getMousePosFromEvent(event);\n        this.mousePoints = [m, m];\n      }\n      redraw = true;\n    } else if (event.type === 'mousemove' && landPoints.length) {\n      // update last point\n      landPoints[landPoints.length - 1] = lngLat;\n      mousePoints[mousePoints.length - 1] = this._getMousePosFromEvent(event);\n      redraw = true;\n    } else if (event.type === 'mouseup') {\n      if (usePolygon) {\n        // check to see if completed\n        // TODO: Maybe double-click to finish?\n        if (\n          landPoints.length > 4 &&\n          turfDistance(landPoints[0], landPoints[landPoints.length - 1]) < POLYGON_THRESHOLD &&\n          this.validPolygon\n        ) {\n          this._selectPolygonObjects();\n          this.reset();\n          redraw = true;\n          deactivate = true;\n        }\n      } else {\n        this._selectRectangleObjects();\n        this.reset();\n        redraw = true;\n        deactivate = true;\n      }\n    }\n\n    return { redraw, deactivate };\n  }\n\n  reset() {\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _makeStartPointHighlight(center: [number, number]): number[] {\n    const buffer = turfBuffer(point(center), POLYGON_THRESHOLD / 4.0);\n    return turfBboxPolygon(turfBbox(buffer)).geometry.coordinates;\n  }\n\n  render() {\n    const data = [];\n    const dataPick = [];\n\n    if (!this.usePolygon && this.landPoints.length === 2) {\n      // Use mouse points instead of land points so we get the right shape\n      // no matter what bearing is.\n      const [[x1, y1], [x2, y2]] = this.mousePoints;\n      const selPolygon = [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]].map(mousePos =>\n        this.nebula.unprojectMousePosition(mousePos)\n      );\n      data.push({\n        polygon: selPolygon,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n    } else if (this.usePolygon && this.landPoints.length) {\n      data.push({\n        polygon: this.landPoints,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n\n      // Hack: use a polygon to hide the outside, because pickObjects()\n      // does not support polygons\n      if (this.landPoints.length >= 3) {\n        const landPointsPoly = polygon([[...this.landPoints, this.landPoints[0]]]);\n        const bigBuffer = turfBuffer(point(this.landPoints[0]), EXPANSION_KM);\n        let bigPolygon;\n        try {\n          // turfDifference throws an exception if the polygon\n          // intersects with itself\n          bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n          dataPick.push({\n            polygon: bigPolygon.geometry.coordinates,\n            fillColor: [0, 0, 0, 1]\n          });\n          this.validPolygon = true;\n        } catch (e) {\n          // invalid selection polygon\n          this.validPolygon = false;\n        }\n      }\n    }\n\n    if (this.landPoints.length) {\n      // highlight start point\n      data.push({\n        polygon: this._makeStartPointHighlight(this.landPoints[0]),\n        lineColor: [0, 0, 0, 0],\n        fillColor: POLYGON_LINE_COLOR\n      });\n    }\n\n    // Hack to make the PolygonLayer() stay active,\n    // otherwise it takes 3 seconds (!) to init!\n    // TODO: fix this\n    data.push({ polygon: [[0, 0]] });\n    dataPick.push({ polygon: [[0, 0]] });\n\n    return [\n      new PolygonLayer({\n        id: LAYER_ID_VIEW,\n        data,\n        fp64: false,\n        opacity: 1.0,\n        pickable: false,\n        lineWidthMinPixels: POLYGON_LINE_WIDTH,\n        lineWidthMaxPixels: POLYGON_LINE_WIDTH,\n        lineDashJustified: true,\n        getLineDashArray: x => POLYGON_DASHES,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        getPolygon: o => o.polygon\n      }),\n      new PolygonLayer({\n        id: LAYER_ID_PICK,\n        data: dataPick,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        fp64: false,\n        opacity: 1.0,\n        stroked: false,\n        pickable: true,\n        getPolygon: o => o.polygon\n      })\n    ];\n  }\n}\n","// @flow\nimport EventEmitter from 'events';\nimport uuid from 'uuid';\n\nimport Feature from './feature';\n\nexport default class NebulaLayer extends EventEmitter {\n  getData: () => Object[];\n  toNebulaFeature: (data: Object) => Feature;\n  id: string;\n  helperLayers: Object[];\n\n  // flags\n  usesMapEvents: boolean = false;\n  enablePicking: boolean = false;\n  enableSelection: boolean = false;\n  //\n\n  constructor({ getData, on, toNebulaFeature }: Object) {\n    super();\n    this.id = uuid.v4();\n    this.getData = getData;\n    this.toNebulaFeature = toNebulaFeature;\n    this.helperLayers = [];\n\n    if (on) {\n      Object.keys(on).forEach(key => this.on(key, on[key]));\n    }\n  }\n\n  render(config: Object): mixed {\n    return null;\n  }\n}\n","// @flow\n\nimport type {\n  EditAction,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../types.js';\n\nexport type ModeState<TData, TGuides> = {\n  // The data being edited, this can be an array or an object\n  data: TData,\n\n  // Additional configuration for this mode\n  modeConfig: any,\n\n  // The indexes of the selected features\n  selectedIndexes: number[],\n\n  // Features that can be used as a guide for editing the data\n  guides: ?TGuides,\n\n  // The cursor type, as a [CSS Cursor](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor)\n  cursor: string,\n\n  // Callback used to notify applications of an edit action\n  onEdit: (editAction: EditAction<TData>) => void,\n\n  // Callback used to update guides\n  onUpdateGuides: (guides: ?TGuides) => void,\n\n  // Callback used to update cursor\n  onUpdateCursor: (cursor: string) => void\n};\n\nexport interface EditMode<TData, TGuides> {\n  // Called every time something in `state` changes\n  updateState(state: ModeState<TData, TGuides>): void;\n\n  // Called when the pointer went down and up without dragging regardless of whether something was picked\n  handleClick(event: ClickEvent): void;\n\n  // Called when the pointer moved, regardless of whether the pointer is down, up, and whether something was picked\n  handlePointerMove(event: PointerMoveEvent): void;\n\n  // Called when the pointer went down on something rendered by this layer and the pointer started to move\n  handleStartDragging(event: StartDraggingEvent): void;\n\n  // Called when the pointer went down on something rendered by this layer, the pointer moved, and now the pointer is up\n  handleStopDragging(event: StopDraggingEvent): void;\n}\n\nexport class BaseEditMode<TData, TGuides> implements EditMode<TData, TGuides> {\n  state: ModeState<TData, TGuides>;\n\n  getState(): ModeState<TData, TGuides> {\n    return this.state;\n  }\n\n  updateState(state: ModeState<TData, TGuides>) {\n    const prevState = this.state;\n    const changedEvents: ((prevState: ModeState<TData, TGuides>) => void)[] = [];\n    if (!this.state || this.state.data !== state.data) {\n      changedEvents.push(this.onDataChanged);\n    }\n    if (!this.state || this.state.modeConfig !== state.modeConfig) {\n      changedEvents.push(this.onModeConfigChanged);\n    }\n    if (!this.state || this.state.selectedIndexes !== state.selectedIndexes) {\n      changedEvents.push(this.onSelectedIndexesChanged);\n    }\n    if (!this.state || this.state.guides !== state.guides) {\n      changedEvents.push(this.onGuidesChanged);\n    }\n    this.state = state;\n\n    changedEvents.forEach(fn => fn.bind(this)(prevState));\n  }\n\n  // Overridable user interaction handlers\n  handleClick(event: ClickEvent): void {}\n  handlePointerMove(event: PointerMoveEvent): void {}\n  handleStartDragging(event: StartDraggingEvent): void {}\n  handleStopDragging(event: StopDraggingEvent): void {}\n\n  // Convenience functions to handle state changes\n  onDataChanged(prevState: ModeState<TData, TGuides>): void {}\n  onModeConfigChanged(prevState: ModeState<TData, TGuides>): void {}\n  onSelectedIndexesChanged(prevState: ModeState<TData, TGuides>): void {}\n  onGuidesChanged(prevState: ModeState<TData, TGuides>): void {}\n\n  // Convenience functions to access state\n  getData(): TData {\n    return this.state.data;\n  }\n  getModeConfig(): any {\n    return this.state.modeConfig;\n  }\n  getSelectedIndexes(): number[] {\n    return this.state.selectedIndexes;\n  }\n  getGuides(): ?TGuides {\n    return this.state && this.state.guides;\n  }\n  getCursor(): string {\n    return this.state && this.state.cursor;\n  }\n  onEdit(editAction: EditAction<TData>): void {\n    this.state.onEdit(editAction);\n  }\n  onUpdateGuides(guides: ?TGuides): void {\n    this.state.onUpdateGuides(guides);\n  }\n  onUpdateCursor(cursor: string): void {\n    this.state.onUpdateCursor(cursor);\n  }\n}\n","// @flow\n\nimport type {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  Polygon,\n  MultiLineString,\n  MultiPolygon,\n  Position,\n  PolygonCoordinates\n} from '../geojson-types.js';\n\nexport class ImmutableFeatureCollection {\n  featureCollection: FeatureCollection;\n\n  constructor(featureCollection: FeatureCollection) {\n    this.featureCollection = featureCollection;\n  }\n\n  getObject() {\n    return this.featureCollection;\n  }\n\n  /**\n   * Replaces the position deeply nested withing the given feature's geometry.\n   * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position to replace\n   * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n   */\n  replacePosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    updatedPosition: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyReplacePosition(\n        geometry.coordinates,\n        positionIndexes,\n        updatedPosition,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion to remove\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  removePosition(featureIndex: number, positionIndexes: number[]): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw Error(`Can't remove a position from a Point or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'MultiPoint' &&\n      // only 1 point left\n      geometry.coordinates.length < 2\n    ) {\n      throw Error(`Can't remove the last point of a MultiPoint or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'LineString' &&\n      // only 2 positions\n      geometry.coordinates.length < 3\n    ) {\n      throw Error(`Can't remove position. LineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'Polygon' &&\n      // outer ring is a triangle\n      geometry.coordinates[0].length < 5 &&\n      // trying to remove from outer ring\n      positionIndexes[0] === 0\n    ) {\n      throw Error(`Can't remove position. Polygon's outer ring must have at least four positions`);\n    }\n    if (\n      geometry.type === 'MultiLineString' &&\n      // only 1 LineString left\n      geometry.coordinates.length === 1 &&\n      // only 2 positions\n      geometry.coordinates[0].length < 3\n    ) {\n      throw Error(`Can't remove position. MultiLineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'MultiPolygon' &&\n      // only 1 polygon left\n      geometry.coordinates.length === 1 &&\n      // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 &&\n      // trying to remove from first polygon\n      positionIndexes[0] === 0 &&\n      // trying to remove from outer ring\n      positionIndexes[1] === 0\n    ) {\n      throw Error(\n        `Can't remove position. MultiPolygon's outer ring must have at least four positions`\n      );\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)\n    };\n\n    // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n    pruneGeometryIfNecessary(updatedGeometry);\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion that will preceed the new position\n   * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  addPosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    positionToAdd: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw new Error('Unable to add a position to a Point feature');\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyAddPosition(\n        geometry.coordinates,\n        positionIndexes,\n        positionToAdd,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  replaceGeometry(featureIndex: number, geometry: Geometry): ImmutableFeatureCollection {\n    const updatedFeature: any = {\n      ...this.featureCollection.features[featureIndex],\n      geometry\n    };\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [\n        ...this.featureCollection.features.slice(0, featureIndex),\n        updatedFeature,\n        ...this.featureCollection.features.slice(featureIndex + 1)\n      ]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  addFeature(feature: Feature): ImmutableFeatureCollection {\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [...this.featureCollection.features, feature]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n}\n\nfunction getUpdatedPosition(updatedPosition: Position, previousPosition: Position): Position {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    const elevation = (previousPosition: any)[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  updatedPosition: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyReplacePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      updatedPosition,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyRemovePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyRemovePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyAddPosition(\n  coordinates: any,\n  positionIndexes: number[],\n  positionToAdd: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      positionToAdd,\n      ...coordinates.slice(positionIndexes[0])\n    ];\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyAddPosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      positionToAdd,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction pruneGeometryIfNecessary(geometry: Geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry: Polygon) {\n  const polygon = geometry.coordinates;\n\n  // If any hole is no longer a polygon, remove the hole entirely\n  for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry: MultiLineString) {\n  for (let lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    const lineString = geometry.coordinates[lineStringIndex];\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1);\n      // Keep the index the same\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry: MultiPolygon) {\n  for (let polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    const polygon = geometry.coordinates[polygonIndex];\n    const outerRing = polygon[0];\n\n    // If the outer ring is no longer a polygon, remove the whole polygon\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1);\n      // It was removed, so keep the index the same\n      polygonIndex--;\n    }\n\n    for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon: PolygonCoordinates, holeIndex: number) {\n  const hole = polygon[holeIndex];\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n  return false;\n}\n","// @flow\n\nimport turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\n\nimport type {\n  EditAction,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  Pick\n} from '../types.js';\nimport type { FeatureCollection, Feature, Polygon, Geometry, Position } from '../geojson-types.js';\nimport type { ModeState } from './edit-mode.js';\nimport { EditMode, BaseEditMode } from './edit-mode.js';\n\nimport { ImmutableFeatureCollection } from './immutable-feature-collection.js';\n\nexport type EditHandleType = 'existing' | 'intermediate' | 'snap';\n\nexport type EditHandle = {\n  position: Position,\n  positionIndexes: number[],\n  featureIndex: number,\n  type: EditHandleType\n};\n\nexport type GeoJsonEditAction = EditAction<FeatureCollection>;\nexport type ModeHandlerGuides = { tentativeFeature: ?Feature, editHandles: EditHandle[] };\n\nconst DEFAULT_EDIT_HANDLES: EditHandle[] = [];\n\n// Main interface for `EditMode`s that edit GeoJSON\nexport type GeoJsonEditMode = EditMode<FeatureCollection, ModeHandlerGuides>;\n\nexport class BaseGeoJsonEditMode extends BaseEditMode<FeatureCollection, ModeHandlerGuides> {\n  // TODO: add underscore\n  featureCollection: ImmutableFeatureCollection;\n  _clickSequence: Position[] = [];\n\n  constructor(featureCollection?: FeatureCollection) {\n    super();\n    if (featureCollection) {\n      this.setFeatureCollection(featureCollection);\n    }\n  }\n\n  getFeatureCollection(): FeatureCollection {\n    return this.featureCollection.getObject();\n  }\n\n  getImmutableFeatureCollection(): ImmutableFeatureCollection {\n    return this.featureCollection;\n  }\n\n  getSelectedFeature(): ?Feature {\n    if (this.getSelectedIndexes().length === 1) {\n      return this.featureCollection.getObject().features[this.getSelectedIndexes()[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(): ?Geometry {\n    const feature = this.getSelectedFeature();\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(): FeatureCollection {\n    const { features } = this.featureCollection.getObject();\n    const selectedFeatures = this.getSelectedFeatureIndexes().map(\n      selectedIndex => features[selectedIndex]\n    );\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures\n    };\n  }\n\n  onDataChanged(): void {\n    this.setFeatureCollection(this.getData());\n    this._refreshEditHandles();\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.featureCollection = new ImmutableFeatureCollection(featureCollection);\n  }\n\n  // TODO: delete me\n  setModeConfig(modeConfig: any): void {\n    console.warn('TODO: call to obsolete setModeConfig'); // eslint-disable-line\n  }\n\n  // TODO: delete me\n  getSelectedFeatureIndexes(): number[] {\n    return this.getSelectedIndexes();\n  }\n\n  // TODO: delete me\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    console.warn('TODO: call to obsolete setSelectedFeatureIndexes'); // eslint-disable-line\n  }\n\n  onSelectedIndexesChanged(): void {\n    this._setTentativeFeature(null);\n  }\n\n  onGuidesChanged(prevState: ModeState<FeatureCollection, ModeHandlerGuides>): void {\n    const guides = this.getGuides();\n\n    if (!guides) {\n      // Reset the click sequence\n      this._clickSequence = [];\n    }\n\n    if (\n      prevState &&\n      prevState.guides &&\n      guides &&\n      prevState.guides.tentativeFeature !== guides.tentativeFeature\n    ) {\n      // re-calculate edit handles\n      this._refreshEditHandles();\n    }\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeFeature(): ?Feature {\n    const { tentativeFeature } = this.getGuides() || {};\n    return tentativeFeature;\n  }\n\n  getEditHandles(): EditHandle[] {\n    const { editHandles } = this.getGuides() || { editHandles: DEFAULT_EDIT_HANDLES };\n    return editHandles;\n  }\n\n  // TODO: delete me once mode handlers do getEditHandles lazily\n  _setTentativeFeature(tentativeFeature: ?Feature): void {\n    this.getState().onUpdateGuides({\n      tentativeFeature,\n      editHandles: this.getEditHandles()\n    });\n  }\n\n  // TODO: delete me once mode handlers do getEditHandles lazily\n  _refreshEditHandles(picks?: Array<Object>, mapCoords?: Position): void {\n    this.getState().onUpdateGuides({\n      tentativeFeature: this.getTentativeFeature(),\n      editHandles: this.getEditHandlesAdapter(picks, mapCoords)\n    });\n  }\n\n  _refreshCursor(): void {\n    const currentCursor = this.getCursor();\n    const updatedCursor = this.getCursorAdapter({ isDragging: false });\n\n    if (currentCursor !== updatedCursor) {\n      this.onUpdateCursor(updatedCursor);\n    }\n  }\n\n  /**\n   * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.\n   *\n   * @param featureIndex The index of the feature to get edit handles\n   */\n  getEditHandlesAdapter(\n    picks?: Array<Object>,\n    mapCoords?: Position,\n    tentativeFeature?: ?Feature\n  ): EditHandle[] {\n    return DEFAULT_EDIT_HANDLES;\n  }\n\n  getCursorAdapter({ isDragging }: { isDragging: boolean }): string {\n    return 'cell';\n  }\n\n  isSelectionPicked(picks: Pick[]): boolean {\n    if (!picks.length) return false;\n    const pickedIndexes = picks.map(({ index }) => index);\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    return selectedFeatureIndexes.some(index => pickedIndexes.includes(index));\n  }\n\n  getAddFeatureAction(geometry: Geometry): GeoJsonEditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const geometryAsAny: any = geometry;\n\n    const updatedData = this.getImmutableFeatureCollection()\n      .addFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: geometryAsAny\n      })\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: [updatedData.features.length - 1]\n      }\n    };\n  }\n\n  getAddManyFeaturesAction(featureCollection: FeatureCollection): GeoJsonEditAction {\n    const features = featureCollection.features;\n    let updatedData = this.getImmutableFeatureCollection();\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of features) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: updatedIndexes\n      }\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(geometry: Polygon): ?GeoJsonEditAction {\n    const selectedFeature = this.getSelectedFeature();\n    const modeConfig = this.getModeConfig();\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature = {\n        type: 'Feature',\n        geometry\n      };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = this.getSelectedFeatureIndexes()[0];\n\n      const updatedData = this.getImmutableFeatureCollection()\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: GeoJsonEditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        editContext: {\n          featureIndexes: [featureIndex]\n        }\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(geometry);\n  }\n\n  handleClick(event: ClickEvent): void {\n    const editAction = this.handleClickAdapter(event);\n\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  handlePointerMove(event: PointerMoveEvent): void {\n    const { editAction, cancelMapPan } = this.handlePointerMoveAdapter(event);\n\n    if (cancelMapPan) {\n      // TODO: is there a less hacky way to prevent map panning?\n      // Stop propagation to prevent map panning while dragging an edit handle\n      event.sourceEvent.stopPropagation();\n    }\n\n    this._refreshCursor();\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  handleStartDragging(event: StartDraggingEvent): void {\n    const editAction = this.handleStartDraggingAdapter(event);\n\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent): void {\n    const editAction = this.handleStopDraggingAdapter(event);\n\n    this._refreshEditHandles(event.picks, event.mapCoords);\n    if (editAction) {\n      this.onEdit(editAction);\n    }\n  }\n\n  // TODO: delete these adapters once all ModeHandler implementations don't use them\n  handleClickAdapter(event: ClickEvent): ?GeoJsonEditAction {\n    this._clickSequence.push(event.mapCoords);\n\n    return null;\n  }\n\n  handlePointerMoveAdapter(\n    event: PointerMoveEvent\n  ): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    return { editAction: null, cancelMapPan: false };\n  }\n\n  handleStartDraggingAdapter(event: StartDraggingEvent): ?GeoJsonEditAction {\n    return null;\n  }\n\n  handleStopDraggingAdapter(event: StopDraggingEvent): ?GeoJsonEditAction {\n    return null;\n  }\n}\n\nexport function getPickedEditHandle(picks: ?(any[])): ?EditHandle {\n  const info = picks && picks.find(pick => pick.isGuide);\n  if (info) {\n    return info.object;\n  }\n  return null;\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0\n  ];\n  return intermediatePosition;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n) {\n  let handles: EditHandle[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          position: geometry.coordinates,\n          positionIndexes: [],\n          featureIndex,\n          type: editHandleType\n        }\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    default:\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandle[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      position,\n      positionIndexes: [...positionIndexPrefix, i],\n      featureIndex,\n      type: editHandleType\n    });\n  }\n  return editHandles;\n}\n","// @flow\n\nimport { BaseGeoJsonEditMode } from './geojson-edit-mode.js';\n\nexport class ViewMode extends BaseGeoJsonEditMode {}\n","// @flow\n\nimport type { ClickEvent, PointerMoveEvent } from '../types.js';\nimport type { Polygon, Position } from '../geojson-types.js';\nimport type { GeoJsonEditAction, EditHandle } from './geojson-edit-mode.js';\nimport {\n  BaseGeoJsonEditMode,\n  getPickedEditHandle,\n  getEditHandlesForGeometry\n} from './geojson-edit-mode.js';\n\nexport class DrawPolygonMode extends BaseGeoJsonEditMode {\n  getEditHandlesAdapter(picks?: Array<Object>, mapCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandlesAdapter(picks, mapCoords);\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handleClickAdapter(event: ClickEvent): ?GeoJsonEditAction {\n    super.handleClickAdapter(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?GeoJsonEditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (clickedEditHandle) {\n      // User clicked an edit handle.\n      // Remove it from the click sequence, so it isn't added as a new point.\n      const clickSequence = this.getClickSequence();\n      clickSequence.splice(clickSequence.length - 1, 1);\n    }\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n\n        // Remove the hovered position\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: [[...polygon.coordinates[0].slice(0, -2), polygon.coordinates[0][0]]]\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      mapCoords: event.mapCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownMapCoords: null,\n      sourceEvent: null\n    };\n\n    this.handlePointerMoveAdapter(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  handlePointerMoveAdapter({\n    mapCoords\n  }: PointerMoveEvent): { editAction: ?GeoJsonEditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, mapCoords]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, mapCoords, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\n// TODO: delete this once all mode handlers derive from GeoJsonEditMode\n\nimport turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\n\nimport { ImmutableFeatureCollection } from '@nebula.gl/edit-modes';\nimport type {\n  FeatureCollection,\n  Feature,\n  Polygon,\n  Geometry,\n  Position\n} from '@nebula.gl/edit-modes';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DeckGLPick\n} from '../event-types.js';\n\nexport type EditHandleType = 'existing' | 'intermediate' | 'snap';\n\nexport type EditHandle = {\n  position: Position,\n  positionIndexes: number[],\n  featureIndex: number,\n  type: EditHandleType\n};\n\nexport type EditAction = {\n  updatedData: FeatureCollection,\n  editType: string,\n  featureIndexes: number[],\n  editContext: any\n};\n\nexport class ModeHandler {\n  // TODO: add underscore\n  featureCollection: ImmutableFeatureCollection;\n  _tentativeFeature: ?Feature;\n  _modeConfig: any = null;\n  _selectedFeatureIndexes: number[] = [];\n  _clickSequence: Position[] = [];\n\n  constructor(featureCollection?: FeatureCollection) {\n    if (featureCollection) {\n      this.setFeatureCollection(featureCollection);\n    }\n  }\n\n  getFeatureCollection(): FeatureCollection {\n    return this.featureCollection.getObject();\n  }\n\n  getImmutableFeatureCollection(): ImmutableFeatureCollection {\n    return this.featureCollection;\n  }\n\n  getSelectedFeature(): ?Feature {\n    if (this._selectedFeatureIndexes.length === 1) {\n      return this.featureCollection.getObject().features[this._selectedFeatureIndexes[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(): ?Geometry {\n    const feature = this.getSelectedFeature();\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(): FeatureCollection {\n    const { features } = this.featureCollection.getObject();\n    const selectedFeatures = this.getSelectedFeatureIndexes().map(\n      selectedIndex => features[selectedIndex]\n    );\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures\n    };\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.featureCollection = new ImmutableFeatureCollection(featureCollection);\n  }\n\n  getModeConfig(): any {\n    return this._modeConfig;\n  }\n\n  setModeConfig(modeConfig: any): void {\n    if (this._modeConfig === modeConfig) {\n      return;\n    }\n\n    this._modeConfig = modeConfig;\n    this._setTentativeFeature(null);\n  }\n\n  getSelectedFeatureIndexes(): number[] {\n    return this._selectedFeatureIndexes;\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    if (this._selectedFeatureIndexes === indexes) {\n      return;\n    }\n\n    this._selectedFeatureIndexes = indexes;\n    this._setTentativeFeature(null);\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._tentativeFeature;\n  }\n\n  // TODO: remove the underscore\n  _setTentativeFeature(tentativeFeature: ?Feature): void {\n    this._tentativeFeature = tentativeFeature;\n    if (!tentativeFeature) {\n      // Reset the click sequence\n      this._clickSequence = [];\n    }\n  }\n\n  /**\n   * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.\n   *\n   * @param featureIndex The index of the feature to get edit handles\n   */\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    return [];\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return 'cell';\n  }\n\n  isSelectionPicked(picks: DeckGLPick[]): boolean {\n    if (!picks.length) return false;\n    const pickedIndexes = picks.map(({ index }) => index);\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    return selectedFeatureIndexes.some(index => pickedIndexes.includes(index));\n  }\n\n  getAddFeatureAction(geometry: Geometry): EditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const geometryAsAny: any = geometry;\n\n    const updatedData = this.getImmutableFeatureCollection()\n      .addFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: geometryAsAny\n      })\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      featureIndexes: [updatedData.features.length - 1],\n      editContext: null\n    };\n  }\n\n  getAddManyFeaturesAction(featureCollection: FeatureCollection): EditAction {\n    const features = featureCollection.features;\n    let updatedData = this.getImmutableFeatureCollection();\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of features) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      featureIndexes: updatedIndexes,\n      editContext: null\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(geometry: Polygon): ?EditAction {\n    const selectedFeature = this.getSelectedFeature();\n    const modeConfig = this.getModeConfig();\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature = {\n        type: 'Feature',\n        geometry\n      };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = this.getSelectedFeatureIndexes()[0];\n\n      const updatedData = this.getImmutableFeatureCollection()\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: EditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        featureIndexes: [featureIndex],\n        editContext: null\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(geometry);\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    this._clickSequence.push(event.groundCoords);\n\n    return null;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    return { editAction: null, cancelMapPan: false };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    return null;\n  }\n}\n\nexport function getPickedEditHandle(picks: ?(any[])): ?EditHandle {\n  const info = picks && picks.find(pick => pick.isEditingHandle);\n  if (info) {\n    return info.object;\n  }\n  return null;\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0\n  ];\n  return intermediatePosition;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n) {\n  let handles: EditHandle[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          position: geometry.coordinates,\n          positionIndexes: [],\n          featureIndex,\n          type: editHandleType\n        }\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    default:\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandle[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      position,\n      positionIndexes: [...positionIndexPrefix, i],\n      featureIndex,\n      type: editHandleType\n    });\n  }\n  return editHandles;\n}\n","// @flow\n\nimport type { Position } from '@nebula.gl/edit-modes';\nimport type { EditHandle } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class ViewHandler extends ModeHandler {\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    return [];\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { point } from '@turf/helpers';\nimport type { Position, LineString } from '@nebula.gl/edit-modes';\n\nexport function toDeckColor(\n  color?: ?[number, number, number, number],\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  groundCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  const pt = point(groundCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n","// @flow\n\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { point, lineString as toLineString } from '@turf/helpers';\nimport type { Position } from '@nebula.gl/edit-modes';\nimport { recursivelyTraverseNestedArrays } from '../utils.js';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class ModifyHandler extends ModeHandler {\n  _lastPointerMovePicks: *;\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = [];\n    const { features } = this.featureCollection.getObject();\n\n    for (const index of this.getSelectedFeatureIndexes()) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index));\n      } else {\n        console.warn(`selectedFeatureIndexes out of range ${index}`); // eslint-disable-line no-console,no-undef\n      }\n    }\n\n    // intermediate edit handle\n    if (picks && picks.length && groundCoords) {\n      const existingEditHandle = picks.find(\n        pick => pick.isEditingHandle && pick.object && pick.object.type === 'existing'\n      );\n      // don't show intermediate point when too close to an existing edit handle\n      const featureAsPick = !existingEditHandle && picks.find(pick => !pick.isEditingHandle);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        !featureAsPick.object.geometry.type.includes('Point') &&\n        this.getSelectedFeatureIndexes().includes(featureAsPick.index)\n      ) {\n        let intermediatePoint = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(groundCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.nearestPointOnLine(\n              lineStringFeature,\n              referencePoint\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index }\n          } = intermediatePoint;\n          handles = [\n            ...handles,\n            {\n              position,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n              featureIndex: featureAsPick.index,\n              type: 'intermediate'\n            }\n          ];\n        }\n      }\n    }\n\n    return handles;\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  nearestPointOnLine(line: any, inPoint: any): any {\n    // TODO: implement 3D nearestPointOnLine\n    return nearestPointOnLine(line, inPoint);\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const clickedEditHandle = getPickedEditHandle(event.picks);\n\n    if (clickedEditHandle && clickedEditHandle.featureIndex >= 0) {\n      if (clickedEditHandle.type === 'existing') {\n        let updatedData;\n        try {\n          updatedData = this.getImmutableFeatureCollection()\n            .removePosition(clickedEditHandle.featureIndex, clickedEditHandle.positionIndexes)\n            .getObject();\n        } catch (ignored) {\n          // This happens if user attempts to remove the last point\n        }\n\n        if (updatedData) {\n          editAction = {\n            updatedData,\n            editType: 'removePosition',\n            featureIndexes: [clickedEditHandle.featureIndex],\n            editContext: {\n              positionIndexes: clickedEditHandle.positionIndexes,\n              position: clickedEditHandle.position\n            }\n          };\n        }\n      } else if (clickedEditHandle.type === 'intermediate') {\n        const updatedData = this.getImmutableFeatureCollection()\n          .addPosition(\n            clickedEditHandle.featureIndex,\n            clickedEditHandle.positionIndexes,\n            clickedEditHandle.position\n          )\n          .getObject();\n\n        if (updatedData) {\n          editAction = {\n            updatedData,\n            editType: 'addPosition',\n            featureIndexes: [clickedEditHandle.featureIndex],\n            editContext: {\n              positionIndexes: clickedEditHandle.positionIndexes,\n              position: clickedEditHandle.position\n            }\n          };\n        }\n      }\n    }\n    return editAction;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    this._lastPointerMovePicks = event.picks;\n\n    let editAction: ?EditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const updatedData = this.getImmutableFeatureCollection()\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'movePosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n\n    return { editAction, cancelMapPan };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle && editHandle.type === 'intermediate') {\n      const updatedData = this.getImmutableFeatureCollection()\n        .addPosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const updatedData = this.getImmutableFeatureCollection()\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'finishMovePosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    const picks = this._lastPointerMovePicks;\n\n    if (picks && picks.length > 0) {\n      const handlePicked = picks.some(pick => pick.isEditingHandle);\n      if (handlePicked) {\n        return 'cell';\n      }\n    }\n\n    return isDragging ? 'grabbing' : 'grab';\n  }\n}\n","// @flow\n\nimport type { Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { getPickedEditHandle } from './mode-handler.js';\nimport { ModifyHandler } from './modify-handler.js';\n\nfunction defaultCalculateElevationChange({\n  pointerDownScreenCoords,\n  screenCoords\n}: {\n  pointerDownScreenCoords: Position,\n  screenCoords: Position\n}) {\n  return 10 * (pointerDownScreenCoords[1] - screenCoords[1]);\n}\n\nexport class ElevationHandler extends ModifyHandler {\n  makeElevatedEvent(event: PointerMoveEvent | StopDraggingEvent, position: Position): Object {\n    if (!event.pointerDownScreenCoords) {\n      return event;\n    }\n\n    const {\n      minElevation = 0,\n      maxElevation = 20000,\n      calculateElevationChange = defaultCalculateElevationChange\n    } =\n      this._modeConfig || {};\n\n    // $FlowFixMe - really, I know it has something at index 2\n    let elevation = position.length === 3 ? position[2] : 0;\n\n    // calculateElevationChange is configurable becase (at this time) modes are not aware of the viewport\n    elevation += calculateElevationChange({\n      pointerDownScreenCoords: event.pointerDownScreenCoords,\n      screenCoords: event.screenCoords\n    });\n    elevation = Math.min(elevation, maxElevation);\n    elevation = Math.max(elevation, minElevation);\n\n    return Object.assign({}, event, {\n      groundCoords: [position[0], position[1], elevation]\n    });\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n    const position = editHandle ? editHandle.position : event.groundCoords;\n    return super.handlePointerMove(this.makeElevatedEvent(event, position));\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    const editHandle = getPickedEditHandle(event.picks);\n    const position = editHandle ? editHandle.position : event.groundCoords;\n    return super.handleStopDragging(this.makeElevatedEvent(event, position));\n  }\n\n  getCursor(params: { isDragging: boolean }): string {\n    let cursor = super.getCursor(params);\n    if (cursor === 'cell') {\n      cursor = 'ns-resize';\n    }\n    return cursor;\n  }\n\n  static calculateElevationChangeWithViewport(\n    viewport: any,\n    {\n      pointerDownScreenCoords,\n      screenCoords\n    }: {\n      pointerDownScreenCoords: Position,\n      screenCoords: Position\n    }\n  ): number {\n    // Source: https://gis.stackexchange.com/a/127949/111804\n    const metersPerPixel =\n      (156543.03392 * Math.cos((viewport.latitude * Math.PI) / 180)) / Math.pow(2, viewport.zoom);\n\n    return (metersPerPixel * (pointerDownScreenCoords[1] - screenCoords[1])) / 2;\n  }\n}\n","// @flow\n\nimport type { Feature, FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditHandle, EditAction } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\ntype HandlePicks = { pickedHandle?: EditHandle, potentialSnapHandle?: EditHandle };\n\nexport class SnappableHandler extends ModeHandler {\n  _handler: ModeHandler;\n  _editHandlePicks: ?HandlePicks;\n  _startDragSnapHandlePosition: Position;\n  _isSnapped: boolean;\n\n  constructor(handler: ModeHandler) {\n    super();\n    this._handler = handler;\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this._handler.setFeatureCollection(featureCollection);\n  }\n\n  setModeConfig(modeConfig: any): void {\n    this._modeConfig = modeConfig;\n    this._handler.setModeConfig(modeConfig);\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    this._handler.setSelectedFeatureIndexes(indexes);\n  }\n\n  _getSnappedMouseEvent(event: Object, snapPoint: Position): PointerMoveEvent {\n    return Object.assign({}, event, {\n      groundCoords: snapPoint,\n      pointerDownGroundCoords: this._startDragSnapHandlePosition\n    });\n  }\n\n  _getEditHandlePicks(event: PointerMoveEvent): HandlePicks {\n    const { picks } = event;\n\n    const potentialSnapHandle = picks.find(\n      pick => pick.object && pick.object.type === 'intermediate'\n    );\n    const handles = { potentialSnapHandle: potentialSnapHandle && potentialSnapHandle.object };\n\n    const pickedHandle = getPickedEditHandle(event.pointerDownPicks);\n    if (pickedHandle) {\n      return { ...handles, pickedHandle };\n    }\n\n    return handles;\n  }\n\n  _updatePickedHandlePosition(editAction: EditAction) {\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle && editAction) {\n      const { featureIndexes, updatedData } = editAction;\n\n      for (let i = 0; i < featureIndexes.length; i++) {\n        const selectedIndex = featureIndexes[i];\n        const updatedFeature = updatedData.features[selectedIndex];\n\n        const { positionIndexes, featureIndex } = pickedHandle;\n        if (selectedIndex >= 0 && featureIndex === selectedIndex) {\n          const { coordinates } = updatedFeature.geometry;\n          // $FlowFixMe\n          pickedHandle.position = positionIndexes.reduce(\n            (a: any[], b: number) => a[b],\n            coordinates\n          );\n        }\n      }\n    }\n  }\n\n  // If additionalSnapTargets is present in modeConfig and is populated, this\n  // method will return those features along with the features\n  // that live in the current layer. Otherwise, this method will simply return the\n  // features from the current layer\n  _getSnapTargets(): Feature[] {\n    let { additionalSnapTargets } = this.getModeConfig() || {};\n    additionalSnapTargets = additionalSnapTargets || [];\n\n    const features = [\n      ...this._handler.featureCollection.getObject().features,\n      ...additionalSnapTargets\n    ];\n    return features;\n  }\n\n  _getNonPickedIntermediateHandles(): EditHandle[] {\n    const handles = [];\n    const features = this._getSnapTargets();\n\n    for (let i = 0; i < features.length; i++) {\n      // Filter out the currently selected feature(s)\n      const isCurrentIndexFeatureNotSelected =\n        i < features.length && !this._handler.getSelectedFeatureIndexes().includes(i);\n\n      if (isCurrentIndexFeatureNotSelected) {\n        const { geometry } = features[i];\n        handles.push(...getEditHandlesForGeometry(geometry, i, 'intermediate'));\n      }\n    }\n    return handles;\n  }\n\n  // If no snap handle has been picked, only display the edit handles of the\n  // selected feature. If a snap handle has been picked, display said snap handle\n  // along with all snappable points on all non-selected features.\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): any[] {\n    const { enableSnapping } = this._modeConfig || {};\n    const handles = this._handler.getEditHandles(picks, groundCoords);\n\n    if (!enableSnapping) return handles;\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle) {\n      handles.push(...this._getNonPickedIntermediateHandles(), pickedHandle);\n      return handles;\n    }\n\n    const { features } = this._handler.featureCollection.getObject();\n    for (const index of this._handler.getSelectedFeatureIndexes()) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index, 'snap'));\n      }\n    }\n\n    return handles.filter(Boolean);\n  }\n\n  _performSnapIfRequired() {\n    if (this._isSnapped) return;\n    const { pickedHandle, potentialSnapHandle } = this._editHandlePicks || {};\n    if (pickedHandle && potentialSnapHandle) {\n      this._isSnapped = true;\n    }\n  }\n\n  // Unsnapping only occurs after the user snaps two polygons but continues to drag the\n  // cursor past the point of resistance.\n  _performUnsnapIfRequired() {\n    if (!this._isSnapped) return;\n\n    const { potentialSnapHandle } = this._editHandlePicks || {};\n    if (!potentialSnapHandle) {\n      this._isSnapped = false;\n    }\n  }\n\n  _getSnapAwareEvent(event: Object): Object {\n    const { potentialSnapHandle } = this._editHandlePicks || {};\n\n    return potentialSnapHandle && potentialSnapHandle.position\n      ? this._getSnappedMouseEvent(event, potentialSnapHandle.position)\n      : event;\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    this._startDragSnapHandlePosition = (getPickedEditHandle(event.picks) || {}).position;\n    return this._handler.handleStartDragging(event);\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    const modeActionSummary = this._handler.handleStopDragging(this._getSnapAwareEvent(event));\n\n    this._editHandlePicks = null;\n    this._isSnapped = false;\n    return modeActionSummary;\n  }\n\n  getCursor(event: { isDragging: boolean }): string {\n    return this._handler.getCursor(event);\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const { enableSnapping } = this._handler.getModeConfig() || {};\n\n    if (enableSnapping) {\n      this._editHandlePicks = this._getEditHandlePicks(event);\n      if (this._editHandlePicks) {\n        this._performSnapIfRequired();\n        this._performUnsnapIfRequired();\n      }\n    }\n\n    const modeActionSummary = this._handler.handlePointerMove(this._getSnapAwareEvent(event));\n    const { editAction } = modeActionSummary;\n    if (editAction) {\n      this._updatePickedHandlePosition(editAction);\n    }\n\n    return modeActionSummary;\n  }\n}\n","// @flow\n\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfTransformTranslate from '@turf/transform-translate';\nimport { point } from '@turf/helpers';\nimport type { FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class TranslateHandler extends ModeHandler {\n  _geometryBeforeTranslate: ?FeatureCollection;\n  _isTranslatable: boolean;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isTranslatable =\n      Boolean(this._geometryBeforeTranslate) || this.isSelectionPicked(event.picks);\n\n    if (!this._isTranslatable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'translating'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'translated'\n      );\n      this._geometryBeforeTranslate = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isTranslatable) {\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getTranslateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string\n  ): ?EditAction {\n    if (!this._geometryBeforeTranslate) {\n      return null;\n    }\n    const p1 = point(startDragPoint);\n    const p2 = point(currentPoint);\n\n    const distanceMoved = turfDistance(p1, p2);\n    const direction = turfBearing(p1, p2);\n\n    const movedFeatures = turfTransformTranslate(\n      this._geometryBeforeTranslate,\n      distanceMoved,\n      direction\n    );\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = movedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n","// @flow\n\nimport type { StartDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TranslateHandler } from './translate-handler';\n\nexport class DuplicateHandler extends TranslateHandler {\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection();\n\n    return this._geometryBeforeTranslate\n      ? this.getAddManyFeaturesAction(this._geometryBeforeTranslate)\n      : null;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isTranslatable) {\n      return 'copy';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport turfTransformRotate from '@turf/transform-rotate';\nimport type { FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class RotateHandler extends ModeHandler {\n  _isRotatable: boolean;\n  _geometryBeingRotated: ?FeatureCollection;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isRotatable = Boolean(this._geometryBeingRotated) || this.isSelectionPicked(event.picks);\n\n    if (!this._isRotatable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'rotating'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isRotatable) {\n      return null;\n    }\n\n    this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'rotated'\n      );\n      this._geometryBeingRotated = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isRotatable) {\n      // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getRotateAction(startDragPoint: Position, currentPoint: Position, editType: string): EditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingRotated);\n    const angle = getRotationAngle(centroid, startPosition, currentPoint);\n\n    const rotatedFeatures = turfTransformRotate(this._geometryBeingRotated, angle);\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = rotatedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n\nfunction getRotationAngle(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const bearing1 = turfBearing(centroid, startDragPoint);\n  const bearing2 = turfBearing(centroid, currentPoint);\n  return bearing2 - bearing1;\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfDistance from '@turf/distance';\nimport turfTransformScale from '@turf/transform-scale';\nimport type { FeatureCollection, Position } from '@nebula.gl/edit-modes';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class ScaleHandler extends ModeHandler {\n  _isScalable: boolean;\n  _geometryBeingScaled: ?FeatureCollection;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isScalable = Boolean(this._geometryBeingScaled) || this.isSelectionPicked(event.picks);\n\n    if (!this._isScalable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'scaling'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isScalable) {\n      return null;\n    }\n\n    this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(event.pointerDownGroundCoords, event.groundCoords, 'scaled');\n      this._geometryBeingScaled = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isScalable) {\n      // TODO: look at doing SVG cursors to get a better \"scale\" cursor\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getScaleAction(startDragPoint: Position, currentPoint: Position, editType: string): EditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingScaled);\n    const factor = getScaleFactor(centroid, startPosition, currentPoint);\n    const scaledFeatures = turfTransformScale(this._geometryBeingScaled, factor, {\n      origin: centroid\n    });\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = scaledFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n\nfunction getScaleFactor(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const startDistance = turfDistance(centroid, startDragPoint);\n  const endDistance = turfDistance(centroid, currentPoint);\n  return endDistance / startDistance;\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class DrawPointHandler extends ModeHandler {\n  handleClick({ groundCoords }: ClickEvent): ?EditAction {\n    const geometry = {\n      type: 'Point',\n      coordinates: groundCoords\n    };\n\n    return this.getAddFeatureAction(geometry);\n  }\n}\n","// @flow\n\nimport type { Position, LineString } from '@nebula.gl/edit-modes';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class DrawLineStringHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    let editAction: ?EditAction = null;\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const selectedGeometry = this.getSelectedGeometry();\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      console.warn(`drawLineString mode only supported for single LineString selection`); // eslint-disable-line\n      this.resetClickSequence();\n      return null;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Extend the LineString\n      const lineString: LineString = selectedGeometry;\n\n      let positionIndexes = [lineString.coordinates.length];\n\n      const modeConfig = this.getModeConfig();\n      if (modeConfig && modeConfig.drawAtFront) {\n        positionIndexes = [0];\n      }\n      const featureIndex = selectedFeatureIndexes[0];\n      const updatedData = this.getImmutableFeatureCollection()\n        .addPosition(featureIndex, positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        featureIndexes: [featureIndex],\n        editContext: {\n          positionIndexes,\n          position: event.groundCoords\n        }\n      };\n\n      this.resetClickSequence();\n    } else if (clickSequence.length === 2 && tentativeFeature) {\n      // Add a new LineString\n      const geometry: any = tentativeFeature.geometry;\n      editAction = this.getAddFeatureAction(geometry);\n\n      this.resetClickSequence();\n    }\n\n    return editAction;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n\n    const clickSequence = this.getClickSequence();\n    const groundCoords = event.groundCoords;\n\n    let startPosition: ?Position = null;\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const selectedGeometry = this.getSelectedGeometry();\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      // unsupported\n      return result;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Draw an extension line starting from one end of the selected LineString\n      startPosition = selectedGeometry.coordinates[selectedGeometry.coordinates.length - 1];\n\n      const modeConfig = this.getModeConfig();\n      if (modeConfig && modeConfig.drawAtFront) {\n        startPosition = selectedGeometry.coordinates[0];\n      }\n    } else if (clickSequence.length === 1) {\n      startPosition = clickSequence[0];\n    }\n\n    if (startPosition) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: {\n          type: 'LineString',\n          coordinates: [startPosition, groundCoords]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport type { Polygon, Position } from '@nebula.gl/edit-modes';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class DrawPolygonHandler extends ModeHandler {\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandles(picks, groundCoords);\n\n    if (this._tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(this._tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (this._tentativeFeature && this._tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (this._tentativeFeature && this._tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?EditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (clickedEditHandle) {\n      // User clicked an edit handle.\n      // Remove it from the click sequence, so it isn't added as a new point.\n      const clickSequence = this.getClickSequence();\n      clickSequence.splice(clickSequence.length - 1, 1);\n    }\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n\n        // Remove the hovered position\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: [[...polygon.coordinates[0].slice(0, -2), polygon.coordinates[0][0]]]\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      groundCoords: event.groundCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownGroundCoords: null,\n      sourceEvent: null\n    };\n    this.handlePointerMove(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, groundCoords]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, groundCoords, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport lineIntersect from '@turf/line-intersect';\nimport turfDistance from '@turf/distance';\nimport { point, lineString } from '@turf/helpers';\nimport type { Polygon, Position } from '@nebula.gl/edit-modes';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class Draw90DegreePolygonHandler extends ModeHandler {\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandles(picks, groundCoords);\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[0][clickSequence.length - 1];\n    } else if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[clickSequence.length - 1];\n    }\n\n    let p3;\n    if (clickSequence.length === 1) {\n      p3 = groundCoords;\n    } else {\n      const p1 = clickSequence[clickSequence.length - 2];\n      const p2 = clickSequence[clickSequence.length - 1];\n      [p3] = generatePointsParallelToLinePoints(p1, p2, groundCoords);\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, p3]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, p3, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?EditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: this.finalizedCoordinates([...polygon.coordinates[0]])\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      groundCoords: event.groundCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownGroundCoords: null,\n      sourceEvent: null\n    };\n    this.handlePointerMove(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  finalizedCoordinates(coords: Position[]) {\n    // Remove the hovered position\n    let coordinates = [[...coords.slice(0, -2), coords[0]]];\n    let pt = this.getIntermediatePoint([...coords]);\n    if (!pt) {\n      // if intermediate point with 90 degree not available\n      // try remove the last clicked point and get the intermediate point.\n      const tc = [...coords];\n      tc.splice(-3, 1);\n      pt = this.getIntermediatePoint([...tc]);\n      if (pt) {\n        coordinates = [[...coords.slice(0, -3), pt, coords[0]]];\n      }\n    } else {\n      coordinates = [[...coords.slice(0, -2), pt, coords[0]]];\n    }\n    return coordinates;\n  }\n\n  getIntermediatePoint(coordinates: Position[]) {\n    let pt;\n    if (coordinates.length > 4) {\n      const [p1, p2] = [...coordinates];\n      const angle1 = bearing(p1, p2);\n      const p3 = coordinates[coordinates.length - 3];\n      const p4 = coordinates[coordinates.length - 4];\n      const angle2 = bearing(p3, p4);\n\n      const angles = { first: [], second: [] };\n      // calculate 3 right angle points for first and last points in lineString\n      [1, 2, 3].forEach(factor => {\n        const newAngle1 = angle1 + factor * 90;\n        // convert angles to 0 to -180 for anti-clock and 0 to 180 for clock wise\n        angles.first.push(newAngle1 > 180 ? newAngle1 - 360 : newAngle1);\n        const newAngle2 = angle2 + factor * 90;\n        angles.second.push(newAngle2 > 180 ? newAngle2 - 360 : newAngle2);\n      });\n\n      const distance = turfDistance(point(p1), point(p3));\n      // Draw imaginary right angle lines for both first and last points in lineString\n      // If there is intersection point for any 2 lines, will be the 90 degree point.\n      [0, 1, 2].forEach(indexFirst => {\n        const line1 = lineString([\n          p1,\n          destination(p1, distance, angles.first[indexFirst]).geometry.coordinates\n        ]);\n        [0, 1, 2].forEach(indexSecond => {\n          const line2 = lineString([\n            p3,\n            destination(p3, distance, angles.second[indexSecond]).geometry.coordinates\n          ]);\n          const fc = lineIntersect(line1, line2);\n          if (fc && fc.features.length) {\n            // found the intersect point\n            pt = fc.features[0].geometry.coordinates;\n          }\n        });\n      });\n    }\n    return pt;\n  }\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport { ModeHandler } from './mode-handler.js';\nimport type { EditAction } from './mode-handler.js';\n\nexport class TwoClickPolygonHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 1 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\n\nexport class DrawRectangleHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.groundCoords;\n    this._setTentativeFeature(bboxPolygon([corner1[0], corner1[1], corner2[0], corner2[1]]));\n\n    return result;\n  }\n}\n","// @flow\n\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport turfDifference from '@turf/difference';\nimport turfBuffer from '@turf/buffer';\nimport lineIntersect from '@turf/line-intersect';\nimport { lineString } from '@turf/helpers';\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfDestination from '@turf/destination';\nimport turfPolygonToLine from '@turf/polygon-to-line';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class SplitPolygonHandler extends ModeHandler {\n  calculateGroundCoords(clickSequence: any, groundCoords: any) {\n    const modeConfig = this.getModeConfig();\n    if (!modeConfig || !modeConfig.lock90Degree || !clickSequence.length) {\n      return groundCoords;\n    }\n    if (clickSequence.length === 1) {\n      // if first point is clicked, then find closest polygon point and build ~90deg vector\n      const firstPoint = clickSequence[0];\n      const selectedGeometry = this.getSelectedGeometry();\n      const feature = turfPolygonToLine(selectedGeometry);\n\n      const lines = feature.type === 'FeatureCollection' ? feature.features : [feature];\n      let minDistance = Number.MAX_SAFE_INTEGER;\n      let closestPoint = null;\n      // If Multipolygon, then we should find nearest polygon line and stick split to it.\n      lines.forEach(line => {\n        const snapPoint = nearestPointOnLine(line, firstPoint);\n        const distanceFromOrigin = turfDistance(snapPoint, firstPoint);\n        if (minDistance > distanceFromOrigin) {\n          minDistance = distanceFromOrigin;\n          closestPoint = snapPoint;\n        }\n      });\n\n      if (closestPoint) {\n        // closest point is used as 90degree entry to the polygon\n        const lastBearing = turfBearing(firstPoint, closestPoint);\n        const currentDistance = turfDistance(firstPoint, groundCoords, { units: 'meters' });\n        return turfDestination(firstPoint, currentDistance, lastBearing, {\n          units: 'meters'\n        }).geometry.coordinates;\n      }\n      return groundCoords;\n    }\n    // Allow only 90 degree turns\n    const lastPoint = clickSequence[clickSequence.length - 1];\n    const [approximatePoint] = generatePointsParallelToLinePoints(\n      clickSequence[clickSequence.length - 2],\n      lastPoint,\n      groundCoords\n    );\n    // align point with current ground\n    const nearestPt = nearestPointOnLine(lineString([lastPoint, approximatePoint]), groundCoords)\n      .geometry.coordinates;\n    return nearestPt;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick({\n      ...event,\n      groundCoords: this.calculateGroundCoords(this.getClickSequence(), event.groundCoords)\n    });\n    const editAction: ?EditAction = null;\n    const tentativeFeature = this.getTentativeFeature();\n    const selectedGeometry = this.getSelectedGeometry();\n    const clickSequence = this.getClickSequence();\n\n    if (!selectedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('A polygon must be selected for splitting');\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n    const pt = {\n      type: 'Point',\n      coordinates: clickSequence[clickSequence.length - 1]\n    };\n    const isPointInPolygon = booleanPointInPolygon(pt, selectedGeometry);\n    if (clickSequence.length > 1 && tentativeFeature && !isPointInPolygon) {\n      this.resetClickSequence();\n      const isLineInterectingWithPolygon = lineIntersect(tentativeFeature, selectedGeometry);\n      if (isLineInterectingWithPolygon.features.length === 0) {\n        this._setTentativeFeature(null);\n        return editAction;\n      }\n      return this.splitPolygon();\n    }\n\n    return editAction;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    this._setTentativeFeature({\n      type: 'Feature',\n      geometry: {\n        type: 'LineString',\n        coordinates: [...clickSequence, this.calculateGroundCoords(clickSequence, groundCoords)]\n      }\n    });\n\n    return result;\n  }\n\n  splitPolygon() {\n    const selectedGeometry = this.getSelectedGeometry();\n    const tentativeFeature = this.getTentativeFeature();\n    const featureIndex = this.getSelectedFeatureIndexes()[0];\n    const modeConfig = this.getModeConfig() || {};\n\n    // Default gap in between the polygon\n    let { gap = 0.1, units = 'centimeters' } = modeConfig;\n    if (gap === 0) {\n      gap = 0.1;\n      units = 'centimeters';\n    }\n\n    const buffer = turfBuffer(tentativeFeature, gap, { units });\n    const updatedGeometry = turfDifference(selectedGeometry, buffer);\n    this._setTentativeFeature(null);\n    if (!updatedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('Canceling edit. Split Polygon erased');\n      return null;\n    }\n\n    const { type, coordinates } = updatedGeometry.geometry;\n    let updatedCoordinates = [];\n    if (type === 'Polygon') {\n      // Update the coordinates as per Multipolygon\n      updatedCoordinates = coordinates.map(c => [c]);\n    } else {\n      // Handle Case when Multipolygon has holes\n      updatedCoordinates = coordinates.reduce((agg, prev) => {\n        prev.forEach(p => {\n          agg.push([p]);\n        });\n        return agg;\n      }, []);\n    }\n\n    // Update the type to Mulitpolygon\n    const updatedData = this.getImmutableFeatureCollection().replaceGeometry(featureIndex, {\n      type: 'MultiPolygon',\n      coordinates: updatedCoordinates\n    });\n\n    const editAction: EditAction = {\n      updatedData: updatedData.getObject(),\n      editType: 'split',\n      featureIndexes: [featureIndex],\n      editContext: null\n    };\n\n    return editAction;\n  }\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport { ModeHandler } from './mode-handler.js';\nimport type { EditAction } from './mode-handler.js';\n\nexport class ThreeClickPolygonHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 2 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n}\n","// @flow\n\nimport type { LineString } from '@nebula.gl/edit-modes';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ThreeClickPolygonHandler } from './three-click-polygon-handler.js';\n\nexport class DrawRectangleUsingThreePointsHandler extends ThreeClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const groundCoords = event.groundCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], groundCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const lineString: LineString = {\n        type: 'LineString',\n        coordinates: clickSequence\n      };\n      const [p1, p2] = clickSequence;\n      const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, groundCoords);\n\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [\n            [\n              // Draw a polygon containing all the points of the LineString,\n              // then the points orthogonal to the lineString,\n              // then back to the starting position\n              ...lineString.coordinates,\n              p3,\n              p4,\n              p1\n            ]\n          ]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\n\nexport class DrawCircleFromCenterHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = this.getModeConfig() || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const centerCoordinates = clickSequence[0];\n    const radius = Math.max(distance(centerCoordinates, event.groundCoords), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawCircleByBoundingBoxHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = this.getModeConfig() || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const firstClickedPoint = clickSequence[0];\n    const centerCoordinates = getIntermediatePosition(firstClickedPoint, event.groundCoords);\n    const radius = Math.max(distance(firstClickedPoint, centerCoordinates), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawEllipseByBoundingBoxHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.groundCoords;\n\n    const minX = Math.min(corner1[0], corner2[0]);\n    const minY = Math.min(corner1[1], corner2[1]);\n    const maxX = Math.max(corner1[0], corner2[0]);\n    const maxY = Math.max(corner1[1], corner2[1]);\n\n    const polygonPoints = bboxPolygon([minX, minY, maxX, maxY]).geometry.coordinates[0];\n    const centerCoordinates = getIntermediatePosition(corner1, corner2);\n\n    const xSemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[1])), 0.001);\n    const ySemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[3])), 0.001);\n\n    this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis));\n\n    return result;\n  }\n}\n","// @flow\n\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport bearing from '@turf/bearing';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ThreeClickPolygonHandler } from './three-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawEllipseUsingThreePointsHandler extends ThreeClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const groundCoords = event.groundCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], groundCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const [p1, p2] = clickSequence;\n\n      const centerCoordinates = getIntermediatePosition(p1, p2);\n      const xSemiAxis = Math.max(distance(centerCoordinates, point(groundCoords)), 0.001);\n      const ySemiAxis = Math.max(distance(p1, p2), 0.001) / 2;\n      const options = { angle: bearing(p1, p2) };\n\n      this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis, options));\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport bearing from '@turf/bearing';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { getPickedEditHandle } from './mode-handler.js';\nimport { ModifyHandler } from './modify-handler';\n\nexport class ExtrudeHandler extends ModifyHandler {\n  isPointAdded: boolean = false;\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    this._lastPointerMovePicks = event.picks;\n\n    let editAction: ?EditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, editHandle.featureIndex);\n      if (p1 && p2) {\n        // p3 and p4 are end points for moving (extruding) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.groundCoords);\n\n        const updatedData = this.getImmutableFeatureCollection()\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruding',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: this.nextPositionIndexes(editHandle.positionIndexes, size),\n            position: p3\n          }\n        };\n      }\n    }\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n\n    return { editAction, cancelMapPan };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle && editHandle.type === 'intermediate') {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(editHandle.positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(\n        editHandle.positionIndexes,\n        editHandle.featureIndex\n      );\n\n      if (p1 && p2) {\n        let updatedData = this.getImmutableFeatureCollection();\n        if (!this.isOrthogonal(editHandle.positionIndexes, editHandle.featureIndex, size)) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p2\n          );\n        }\n        if (\n          !this.isOrthogonal(\n            this.prevPositionIndexes(editHandle.positionIndexes, size),\n            editHandle.featureIndex,\n            size\n          )\n        ) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p1\n          );\n          this.isPointAdded = true;\n        }\n\n        editAction = {\n          updatedData: updatedData.getObject(),\n          editType: 'startExtruding',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: editHandle.positionIndexes,\n            position: p1\n          }\n        };\n      }\n    }\n\n    return editAction;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, editHandle.featureIndex);\n\n      if (p1 && p2) {\n        // p3 and p4 are end points for new moved (extruded) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.groundCoords);\n\n        const updatedData = this.getImmutableFeatureCollection()\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruded',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: editHandle.positionIndexes,\n            position: p3\n          }\n        };\n      }\n    }\n    this.isPointAdded = false;\n\n    return editAction;\n  }\n\n  coordinatesSize(positionIndexes: number[], featureIndex: number) {\n    let size = 0;\n    const feature = this.getImmutableFeatureCollection().getObject().features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        size = coordinates[a][b].length;\n      }\n    } else {\n      const [b] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        size = coordinates[b].length;\n      }\n    }\n    return size;\n  }\n\n  getBearing(p1: any, p2: any) {\n    const angle = bearing(p1, p2);\n    if (angle < 0) {\n      return Math.floor(360 + angle);\n    }\n    return Math.floor(angle);\n  }\n\n  isOrthogonal(positionIndexes: number[], featureIndex: number, size: number) {\n    if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n      positionIndexes[positionIndexes.length - 1] = 0;\n    }\n    const prevPoint = this.getPointForPositionIndexes(\n      this.prevPositionIndexes(positionIndexes, size),\n      featureIndex\n    );\n    const nextPoint = this.getPointForPositionIndexes(\n      this.nextPositionIndexes(positionIndexes, size),\n      featureIndex\n    );\n    const currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex);\n    const prevAngle = this.getBearing(currentPoint, prevPoint);\n    const nextAngle = this.getBearing(currentPoint, nextPoint);\n    return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n  }\n\n  nextPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const next = [...positionIndexes];\n    if (next.length) {\n      next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n    }\n    return next;\n  }\n\n  prevPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const prev = [...positionIndexes];\n    if (prev.length) {\n      prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n    }\n    return prev;\n  }\n\n  getPointForPositionIndexes(positionIndexes: number[], featureIndex: number) {\n    let p1;\n    const feature = this.getImmutableFeatureCollection().getObject().features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b, c] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        p1 = coordinates[a][b][c];\n      }\n    } else {\n      const [b, c] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        p1 = coordinates[b][c];\n      }\n    }\n    return p1;\n  }\n}\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  DoubleClickEvent\n} from '../event-types.js';\n\n// Minimum number of pixels the pointer must move from the original pointer down to be considered dragging\nconst MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS = 7;\n\nexport default class EditableLayer extends CompositeLayer {\n  // Overridable interaction event handlers\n  onLayerClick(event: ClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onDoubleClick(event: DoubleClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    // default implementation - do nothing\n  }\n\n  // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  initializeState() {\n    this.setState({\n      _editableLayerState: {\n        // Pointer event handlers\n        pointerHandlers: null,\n        // Picked objects at the time the pointer went down\n        pointerDownPicks: null,\n        // Screen coordinates where the pointer went down\n        pointerDownScreenCoords: null,\n        // Ground coordinates where the pointer went down\n        pointerDownGroundCoords: null,\n        // Is the pointer dragging (pointer down + moved at least MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS)\n        isDragging: false\n      }\n    });\n  }\n\n  finalizeState() {\n    this._removePointerHandlers();\n  }\n\n  updateState({ props, changeFlags }: Object) {\n    // unsubscribe previous layer instance's handlers\n    this._removePointerHandlers();\n    this._addPointerHandlers();\n  }\n\n  _removePointerHandlers() {\n    if (this.state._editableLayerState.pointerHandlers) {\n      this.context.gl.canvas.removeEventListener(\n        'pointermove',\n        this.state._editableLayerState.pointerHandlers.onPointerMove\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerdown',\n        this.state._editableLayerState.pointerHandlers.onPointerDown\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerup',\n        this.state._editableLayerState.pointerHandlers.onPointerUp\n      );\n      this.context.gl.canvas.removeEventListener(\n        'dblclick',\n        this.state._editableLayerState.pointerHandlers.onDoubleClick\n      );\n    }\n    this.state._editableLayerState.pointerHandlers = null;\n  }\n\n  _addPointerHandlers() {\n    this.state._editableLayerState.pointerHandlers = {\n      onPointerMove: this._onPointerMove.bind(this),\n      onPointerDown: this._onPointerDown.bind(this),\n      onPointerUp: this._onPointerUp.bind(this),\n      onDoubleClick: this._onDoubleClick.bind(this)\n    };\n\n    this.context.gl.canvas.addEventListener(\n      'pointermove',\n      this.state._editableLayerState.pointerHandlers.onPointerMove\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerdown',\n      this.state._editableLayerState.pointerHandlers.onPointerDown\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerup',\n      this.state._editableLayerState.pointerHandlers.onPointerUp\n    );\n    this.context.gl.canvas.addEventListener(\n      'dblclick',\n      this.state._editableLayerState.pointerHandlers.onDoubleClick\n    );\n  }\n\n  _onDoubleClick(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n    this.onDoubleClick({\n      groundCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerDown(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius,\n      depth: this.props.pickingDepth\n    });\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: screenCoords,\n        pointerDownGroundCoords: groundCoords,\n        pointerDownPicks: picks,\n        isDragging: false\n      }\n    });\n  }\n\n  _onPointerMove(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords\n    } = this.state._editableLayerState;\n\n    let { isDragging } = this.state._editableLayerState;\n\n    if (pointerDownScreenCoords) {\n      // Pointer went down and is moving\n\n      // Did it move enough to consider it a drag\n      if (!isDragging && this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n        // OK, this is considered dragging\n\n        // Fire the start dragging event\n        this.onStartDragging({\n          picks: pointerDownPicks,\n          screenCoords,\n          groundCoords,\n          pointerDownScreenCoords,\n          pointerDownGroundCoords,\n          sourceEvent: event\n        });\n\n        isDragging = true;\n        this.setState({\n          _editableLayerState: {\n            ...this.state._editableLayerState,\n            isDragging\n          }\n        });\n      }\n    }\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius,\n      depth: this.props.pickingDepth\n    });\n\n    this.onPointerMove({\n      screenCoords,\n      groundCoords,\n      picks,\n      isDragging,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerUp(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords,\n      isDragging\n    } = this.state._editableLayerState;\n\n    if (!pointerDownScreenCoords) {\n      // This is a pointer up without a pointer down (e.g. user pointer downed elsewhere), so ignore\n      return;\n    }\n\n    if (isDragging) {\n      this.onStopDragging({\n        picks: pointerDownPicks,\n        screenCoords,\n        groundCoords,\n        pointerDownScreenCoords,\n        pointerDownGroundCoords,\n        sourceEvent: event\n      });\n    } else if (!this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n      this.onLayerClick({\n        picks: pointerDownPicks,\n        screenCoords,\n        groundCoords,\n        sourceEvent: event\n      });\n    }\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: null,\n        pointerDownGroundCoords: null,\n        pointerDownPicks: null,\n        isDragging: false\n      }\n    });\n  }\n\n  getScreenCoords(pointerEvent: Object) {\n    return [\n      pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().x,\n      pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().y\n    ];\n  }\n\n  getGroundCoords(screenCoords: number[]) {\n    return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n  }\n\n  movedEnoughForDrag(screenCoords1: number[], screenCoords2: number[]) {\n    return (\n      Math.abs(screenCoords1[0] - screenCoords2[0]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS ||\n      Math.abs(screenCoords1[1] - screenCoords2[1]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS\n    );\n  }\n}\n\nEditableLayer.layerName = 'EditableLayer';\n","// @flow\n/* eslint-env browser */\n\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer } from '@deck.gl/layers';\nimport { type Position } from '@nebula.gl/edit-modes';\nimport { ModeHandler } from '../mode-handlers/mode-handler.js';\nimport { ViewHandler } from '../mode-handlers/view-handler.js';\nimport { ModifyHandler } from '../mode-handlers/modify-handler.js';\nimport { ElevationHandler } from '../mode-handlers/elevation-handler.js';\nimport { SnappableHandler } from '../mode-handlers/snappable-handler.js';\nimport { TranslateHandler } from '../mode-handlers/translate-handler.js';\nimport { DuplicateHandler } from '../mode-handlers/duplicate-handler';\nimport { RotateHandler } from '../mode-handlers/rotate-handler.js';\nimport { ScaleHandler } from '../mode-handlers/scale-handler.js';\nimport { DrawPointHandler } from '../mode-handlers/draw-point-handler.js';\nimport { DrawLineStringHandler } from '../mode-handlers/draw-line-string-handler.js';\nimport { DrawPolygonHandler } from '../mode-handlers/draw-polygon-handler.js';\nimport { Draw90DegreePolygonHandler } from '../mode-handlers/draw-90degree-polygon-handler.js';\nimport { DrawRectangleHandler } from '../mode-handlers/draw-rectangle-handler.js';\nimport { SplitPolygonHandler } from '../mode-handlers/split-polygon-handler.js';\nimport { DrawRectangleUsingThreePointsHandler } from '../mode-handlers/draw-rectangle-using-three-points-handler.js';\nimport { DrawCircleFromCenterHandler } from '../mode-handlers/draw-circle-from-center-handler.js';\nimport { DrawCircleByBoundingBoxHandler } from '../mode-handlers/draw-circle-by-bounding-box-handler.js';\nimport { DrawEllipseByBoundingBoxHandler } from '../mode-handlers/draw-ellipse-by-bounding-box-handler.js';\nimport { DrawEllipseUsingThreePointsHandler } from '../mode-handlers/draw-ellipse-using-three-points-handler.js';\n\nimport type { EditAction } from '../mode-handlers/mode-handler.js';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent\n} from '../event-types.js';\nimport { ExtrudeHandler } from '../mode-handlers/extrude-handler.js';\nimport EditableLayer from './editable-layer.js';\n\nconst DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\n\nfunction getEditHandleColor(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nconst defaultProps = {\n  mode: 'modify',\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  pickingRadius: 10,\n  pickingDepth: 5,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'meters',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineDashJustified: false,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: f =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: f => (f && f.properties && f.properties.lineWidth) || 1,\n  getLineDashArray: (feature, isSelected, mode) =>\n    isSelected && mode !== 'view' ? [7, 4] : [0, 0],\n\n  // Tentative feature rendering\n  getTentativeLineDashArray: (f, mode) => [7, 4],\n  getTentativeLineColor: (f, mode) => DEFAULT_SELECTED_LINE_COLOR,\n  getTentativeFillColor: (f, mode) => DEFAULT_SELECTED_FILL_COLOR,\n  getTentativeLineWidth: (f, mode) => (f && f.properties && f.properties.lineWidth) || 1,\n\n  editHandleType: 'point',\n  editHandleParameters: {},\n  editHandleLayerProps: {},\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: false,\n  editHandlePointStrokeWidth: 1,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: handle => handle.type,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // misc\n  billboard: true,\n\n  // Mode handlers\n  modeHandlers: {\n    view: new ViewHandler(),\n    modify: new ModifyHandler(),\n    elevation: new ElevationHandler(),\n    extrude: new ExtrudeHandler(),\n    rotate: new RotateHandler(),\n    translate: new SnappableHandler(new TranslateHandler()),\n    duplicate: new DuplicateHandler(),\n    scale: new ScaleHandler(),\n    drawPoint: new DrawPointHandler(),\n    drawLineString: new DrawLineStringHandler(),\n    drawPolygon: new DrawPolygonHandler(),\n    draw90DegreePolygon: new Draw90DegreePolygonHandler(),\n    split: new SplitPolygonHandler(),\n    drawRectangle: new DrawRectangleHandler(),\n    drawRectangleUsing3Points: new DrawRectangleUsingThreePointsHandler(),\n    drawCircleFromCenter: new DrawCircleFromCenterHandler(),\n    drawCircleByBoundingBox: new DrawCircleByBoundingBoxHandler(),\n    drawEllipseByBoundingBox: new DrawEllipseByBoundingBoxHandler(),\n    drawEllipseUsing3Points: new DrawEllipseUsingThreePointsHandler()\n  }\n};\n\ntype Props = {\n  mode: string,\n  modeHandlers: { [mode: string]: ModeHandler },\n  onEdit: EditAction => void,\n  // TODO: type the rest\n  [string]: any\n};\n\n// type State = {\n//   modeHandler: EditableFeatureCollection,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nexport default class EditableGeoJsonLayer extends EditableLayer {\n  // state: State;\n  // props: Props;\n  // setState: ($Shape<State>) => void;\n\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      lineDashJustified: this.props.lineDashJustified,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n      getLineDashArray: this.selectionAwareAccessor(this.props.getLineDashArray),\n\n      _subLayerProps: {\n        'line-strings': {\n          billboard: this.props.billboard\n        },\n        'polygons-stroke': {\n          billboard: this.props.billboard\n        }\n      },\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineDashArray: [this.props.selectedFeatureIndexes, this.props.mode]\n      }\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createTentativeLayers());\n    layers = layers.concat(this.createEditHandleLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      selectedFeatures: [],\n      editHandles: []\n    });\n  }\n\n  // TODO: figure out how to properly update state from an outside event handler\n  shouldUpdateState({ props, oldProps, context, oldContext, changeFlags }: Object) {\n    if (changeFlags.stateChanged) {\n      return true;\n    }\n    return true;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }: {\n    props: Props,\n    oldProps: Props,\n    changeFlags: any\n  }) {\n    super.updateState({ props, changeFlags });\n\n    let modeHandler: ModeHandler = this.state.modeHandler;\n    if (changeFlags.propsOrDataChanged) {\n      if (props.modeHandlers !== oldProps.modeHandlers || props.mode !== oldProps.mode) {\n        modeHandler = props.modeHandlers[props.mode];\n\n        if (!modeHandler) {\n          console.warn(`No handler configured for mode ${props.mode}`); // eslint-disable-line no-console,no-undef\n          // Use default mode handler\n          modeHandler = new ModeHandler();\n        }\n\n        if (modeHandler !== this.state.modeHandler) {\n          this.setState({ modeHandler });\n        }\n\n        modeHandler.setFeatureCollection(props.data);\n      } else if (changeFlags.dataChanged) {\n        modeHandler.setFeatureCollection(props.data);\n      }\n\n      modeHandler.setModeConfig(props.modeConfig);\n      modeHandler.setSelectedFeatureIndexes(props.selectedFeatureIndexes);\n      this.updateTentativeFeature();\n      this.updateEditHandles();\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map(elem => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Object) => accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Object) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Object) {\n    if (sourceLayer.id.endsWith('-edit-handles')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isEditingHandle = true;\n    }\n\n    return info;\n  }\n\n  createEditHandleLayers() {\n    if (!this.state.editHandles.length) {\n      return [];\n    }\n\n    const sharedProps = {\n      id: `${this.props.editHandleType.layerName || this.props.editHandleType}-edit-handles`,\n      data: this.state.editHandles,\n      fp64: this.props.fp64,\n\n      parameters: this.props.editHandleParameters,\n      ...this.props.editHandleLayerProps\n    };\n\n    let layer;\n\n    switch (this.props.editHandleType) {\n      case 'icon':\n        layer = new IconLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n            iconAtlas: this.props.editHandleIconAtlas,\n            iconMapping: this.props.editHandleIconMapping,\n            sizeScale: this.props.editHandleIconSizeScale,\n            getIcon: this.props.getEditHandleIcon,\n            getSize: this.props.getEditHandleIconSize,\n            getColor: this.props.getEditHandleIconColor,\n            getAngle: this.props.getEditHandleIconAngle,\n\n            getPosition: d => d.position\n          })\n        );\n        break;\n\n      case 'point':\n        layer = new ScatterplotLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n\n            // Proxy editing point props\n            radiusScale: this.props.editHandlePointRadiusScale,\n            outline: this.props.editHandlePointOutline,\n            strokeWidth: this.props.editHandlePointStrokeWidth,\n            radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n            radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n            getRadius: this.props.getEditHandlePointRadius,\n            getColor: this.props.getEditHandlePointColor\n          })\n        );\n        break;\n\n      default:\n        if (typeof this.props.editHandleType === 'function') {\n          const EditHandleType = this.props.editHandleType;\n          layer = new EditHandleType(\n            this.getSubLayerProps({\n              ...sharedProps,\n\n              // Proxy editing point props\n              radiusScale: this.props.editHandlePointRadiusScale,\n              outline: this.props.editHandlePointOutline,\n              strokeWidth: this.props.editHandlePointStrokeWidth,\n              radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n              radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n              getRadius: this.props.getEditHandlePointRadius,\n              getColor: this.props.getEditHandlePointColor\n            })\n          );\n        }\n        break;\n    }\n\n    return [layer];\n  }\n\n  createTentativeLayers() {\n    if (!this.state.tentativeFeature) {\n      return [];\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: 'tentative',\n        data: this.state.tentativeFeature,\n        fp64: this.props.fp64,\n        pickable: false,\n        stroked: true,\n        autoHighlight: false,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        pointRadiusScale: this.props.editHandlePointRadiusScale,\n        outline: this.props.editHandlePointOutline,\n        strokeWidth: this.props.editHandlePointStrokeWidth,\n        pointRadiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        pointRadiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: this.props.getEditHandlePointRadius,\n        getLineColor: feature => this.props.getTentativeLineColor(feature, this.props.mode),\n        getLineWidth: feature => this.props.getTentativeLineWidth(feature, this.props.mode),\n        getFillColor: feature => this.props.getTentativeFillColor(feature, this.props.mode),\n        getLineDashArray: feature =>\n          this.props.getTentativeLineDashArray(\n            feature,\n            this.state.selectedFeatures[0],\n            this.props.mode\n          )\n      })\n    );\n\n    return [layer];\n  }\n\n  updateTentativeFeature() {\n    const tentativeFeature = this.state.modeHandler.getTentativeFeature();\n    if (tentativeFeature !== this.state.tentativeFeature) {\n      this.setState({ tentativeFeature });\n      this.setLayerNeedsUpdate();\n    }\n  }\n\n  updateEditHandles(picks?: Array<Object>, groundCoords?: Position) {\n    const editHandles = this.state.modeHandler.getEditHandles(picks, groundCoords);\n    if (editHandles !== this.state.editHandles) {\n      this.setState({ editHandles });\n      this.setLayerNeedsUpdate();\n    }\n  }\n\n  onLayerClick(event: ClickEvent) {\n    const editAction = this.state.modeHandler.handleClick(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    const editAction = this.state.modeHandler.handleStartDragging(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    const editAction = this.state.modeHandler.handleStopDragging(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    const { groundCoords, picks, sourceEvent } = event;\n\n    const { editAction, cancelMapPan } = this.state.modeHandler.handlePointerMove(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles(picks, groundCoords);\n\n    if (cancelMapPan) {\n      // TODO: find a less hacky way to prevent map panning\n      // Stop propagation to prevent map panning while dragging an edit handle\n      sourceEvent.stopPropagation();\n    }\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    return this.state.modeHandler.getCursor({ isDragging });\n  }\n}\n\nEditableGeoJsonLayer.layerName = 'EditableGeoJsonLayer';\nEditableGeoJsonLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  DoubleClickEvent\n} from '@nebula.gl/edit-modes';\n\n// Minimum number of pixels the pointer must move from the original pointer down to be considered dragging\nconst MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS = 7;\n\n// eslint-disable-next-line camelcase\nexport default class EditableLayer_EDIT_MODE_POC extends CompositeLayer {\n  // Overridable interaction event handlers\n  onLayerClick(event: ClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onDoubleClick(event: DoubleClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    // default implementation - do nothing\n  }\n\n  // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  initializeState() {\n    this.setState({\n      _editableLayerState: {\n        // Pointer event handlers\n        pointerHandlers: null,\n        // Picked objects at the time the pointer went down\n        pointerDownPicks: null,\n        // Screen coordinates where the pointer went down\n        pointerDownScreenCoords: null,\n        // Ground coordinates where the pointer went down\n        pointerDownMapCoords: null,\n        // Is the pointer dragging (pointer down + moved at least MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS)\n        isDragging: false\n      }\n    });\n  }\n\n  finalizeState() {\n    this._removePointerHandlers();\n  }\n\n  updateState({ props, changeFlags }: Object) {\n    // unsubscribe previous layer instance's handlers\n    this._removePointerHandlers();\n    this._addPointerHandlers();\n  }\n\n  _removePointerHandlers() {\n    if (this.state._editableLayerState.pointerHandlers) {\n      this.context.gl.canvas.removeEventListener(\n        'pointermove',\n        this.state._editableLayerState.pointerHandlers.onPointerMove\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerdown',\n        this.state._editableLayerState.pointerHandlers.onPointerDown\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerup',\n        this.state._editableLayerState.pointerHandlers.onPointerUp\n      );\n      this.context.gl.canvas.removeEventListener(\n        'dblclick',\n        this.state._editableLayerState.pointerHandlers.onDoubleClick\n      );\n    }\n    this.state._editableLayerState.pointerHandlers = null;\n  }\n\n  _addPointerHandlers() {\n    this.state._editableLayerState.pointerHandlers = {\n      onPointerMove: this._onPointerMove.bind(this),\n      onPointerDown: this._onPointerDown.bind(this),\n      onPointerUp: this._onPointerUp.bind(this),\n      onDoubleClick: this._onDoubleClick.bind(this)\n    };\n\n    this.context.gl.canvas.addEventListener(\n      'pointermove',\n      this.state._editableLayerState.pointerHandlers.onPointerMove\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerdown',\n      this.state._editableLayerState.pointerHandlers.onPointerDown\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerup',\n      this.state._editableLayerState.pointerHandlers.onPointerUp\n    );\n    this.context.gl.canvas.addEventListener(\n      'dblclick',\n      this.state._editableLayerState.pointerHandlers.onDoubleClick\n    );\n  }\n\n  _onDoubleClick(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n    this.onDoubleClick({\n      mapCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerDown(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius || 10,\n      depth: 2\n    });\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: screenCoords,\n        pointerDownMapCoords: mapCoords,\n        pointerDownPicks: picks,\n        isDragging: false\n      }\n    });\n  }\n\n  _onPointerMove(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords\n    } = this.state._editableLayerState;\n\n    let { isDragging } = this.state._editableLayerState;\n\n    if (pointerDownScreenCoords) {\n      // Pointer went down and is moving\n\n      // Did it move enough to consider it a drag\n      if (!isDragging && this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n        // OK, this is considered dragging\n\n        // Fire the start dragging event\n        this.onStartDragging({\n          picks: pointerDownPicks,\n          screenCoords,\n          mapCoords,\n          pointerDownScreenCoords,\n          pointerDownMapCoords,\n          sourceEvent: event\n        });\n\n        isDragging = true;\n        this.setState({\n          _editableLayerState: {\n            ...this.state._editableLayerState,\n            isDragging\n          }\n        });\n      }\n    }\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius || 10,\n      depth: 2\n    });\n\n    this.onPointerMove({\n      screenCoords,\n      mapCoords,\n      picks,\n      isDragging,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerUp(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      isDragging\n    } = this.state._editableLayerState;\n\n    if (!pointerDownScreenCoords) {\n      // This is a pointer up without a pointer down (e.g. user pointer downed elsewhere), so ignore\n      return;\n    }\n\n    if (isDragging) {\n      this.onStopDragging({\n        picks: pointerDownPicks,\n        screenCoords,\n        mapCoords,\n        pointerDownScreenCoords,\n        pointerDownMapCoords,\n        sourceEvent: event\n      });\n    } else if (!this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n      this.onLayerClick({\n        picks: pointerDownPicks,\n        screenCoords,\n        mapCoords,\n        sourceEvent: event\n      });\n    }\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: null,\n        pointerDownMapCoords: null,\n        pointerDownPicks: null,\n        isDragging: false\n      }\n    });\n  }\n\n  getScreenCoords(pointerEvent: Object) {\n    return [\n      pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().x,\n      pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().y\n    ];\n  }\n\n  getMapCoords(screenCoords: number[]) {\n    return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n  }\n\n  movedEnoughForDrag(screenCoords1: number[], screenCoords2: number[]) {\n    return (\n      Math.abs(screenCoords1[0] - screenCoords2[0]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS ||\n      Math.abs(screenCoords1[1] - screenCoords2[1]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS\n    );\n  }\n}\n\n// eslint-disable-next-line camelcase\nEditableLayer_EDIT_MODE_POC.layerName = 'EditableLayer_EDIT_MODE_POC';\n","// @flow\n/* eslint-env browser */\n\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer } from '@deck.gl/layers';\n\nimport { ViewMode, DrawPolygonMode } from '@nebula.gl/edit-modes';\nimport type {\n  EditAction,\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  GeoJsonEditMode,\n  FeatureCollection\n} from '@nebula.gl/edit-modes';\nimport EditableLayer from './editable-layer-edit-mode-poc.js';\n\nconst DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\n\nfunction getEditHandleColor(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nconst defaultProps = {\n  mode: 'modify',\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  pickingRadius: 10,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'meters',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineDashJustified: false,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: f =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: f => (f && f.properties && f.properties.lineWidth) || 1,\n  getLineDashArray: (feature, isSelected, mode) =>\n    isSelected && mode !== 'view' ? [7, 4] : [0, 0],\n\n  // Tentative feature rendering\n  getTentativeLineDashArray: (f, mode) => [7, 4],\n  getTentativeLineColor: (f, mode) => DEFAULT_SELECTED_LINE_COLOR,\n  getTentativeFillColor: (f, mode) => DEFAULT_SELECTED_FILL_COLOR,\n  getTentativeLineWidth: (f, mode) => (f && f.properties && f.properties.lineWidth) || 1,\n\n  editHandleType: 'point',\n  editHandleParameters: {},\n  editHandleLayerProps: {},\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: false,\n  editHandlePointStrokeWidth: 1,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: handle => handle.type,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // Mode handlers\n  modeHandlers: {\n    view: new ViewMode(),\n    drawPolygon: new DrawPolygonMode()\n  }\n};\n\ntype Props = {\n  mode: string,\n  modeHandlers: { [mode: string]: GeoJsonEditMode },\n  onEdit: (EditAction<FeatureCollection>) => void,\n  // TODO: type the rest\n  [string]: any\n};\n\n// type State = {\n//   modeHandler: EditableFeatureCollection,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\n// eslint-disable-next-line camelcase\nexport default class EditableGeoJsonLayer_EDIT_MODE_POC extends EditableLayer {\n  // state: State;\n  // props: Props;\n  // setState: ($Shape<State>) => void;\n\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      lineDashJustified: this.props.lineDashJustified,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n      getLineDashArray: this.selectionAwareAccessor(this.props.getLineDashArray),\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineDashArray: [this.props.selectedFeatureIndexes, this.props.mode]\n      }\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createTentativeLayers());\n    layers = layers.concat(this.createEditHandleLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      cursor: 'grab',\n      selectedFeatures: [],\n      editHandles: []\n    });\n  }\n\n  setState(partialState: any) {\n    super.setState(partialState);\n    this.updateModeState(this.props);\n  }\n\n  // TODO: figure out how to properly update state from an outside event handler\n  shouldUpdateState() {\n    return true;\n  }\n\n  // shouldUpdateState(opts: Object) {\n  //   let shouldUpdateState = super.shouldUpdateState(opts);\n\n  //   if (opts.changeFlags.stateChanged) {\n  //     shouldUpdateState = true;\n\n  //     // const needsRedraw = this.getNeedsRedraw && this.getNeedsRedraw()\n  //     // console.log(\n  //     //   'calling modeHandler.updateState',\n  //     //   this.getNeedsRedraw(),\n  //     //   this.internalState.needsRedraw,\n  //     //   JSON.stringify(changeFlags)\n  //     // );\n\n  //     this.updateModeState(this.props);\n  //   }\n  //   return shouldUpdateState;\n  // }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }: {\n    props: Props,\n    oldProps: Props,\n    changeFlags: any\n  }) {\n    super.updateState({ props, changeFlags });\n\n    let modeHandler: GeoJsonEditMode = this.state.modeHandler;\n    if (changeFlags.propsOrDataChanged) {\n      if (props.modeHandlers !== oldProps.modeHandlers || props.mode !== oldProps.mode) {\n        modeHandler = props.modeHandlers[props.mode];\n\n        if (!modeHandler) {\n          console.warn(`No handler configured for mode ${props.mode}`); // eslint-disable-line no-console,no-undef\n          // Use default mode handler\n          modeHandler = new ViewMode();\n        }\n\n        if (modeHandler !== this.state.modeHandler) {\n          this.setState({ modeHandler });\n        }\n      }\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map(elem => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  updateModeState(props: Props) {\n    const modeHandler = props.modeHandlers[props.mode];\n\n    modeHandler.updateState({\n      modeConfig: props.modeConfig,\n      data: props.data,\n      selectedIndexes: props.selectedFeatureIndexes,\n      guides: this.state && {\n        tentativeFeature: this.state.tentativeFeature,\n        editHandles: this.state.editHandles\n      },\n      cursor: this.state.cursor,\n      onEdit: (editAction: EditAction<FeatureCollection>) => {\n        props.onEdit(editAction);\n      },\n      onUpdateGuides: guides => {\n        if (guides) {\n          this.setState({\n            tentativeFeature: guides.tentativeFeature,\n            editHandles: guides.editHandles\n          });\n        } else {\n          this.setState({\n            tentativeFeature: null,\n            editHandles: null\n          });\n        }\n        this.setLayerNeedsUpdate();\n        this.setNeedsRedraw();\n      },\n      onUpdateCursor: cursor => {\n        this.setState({ cursor });\n      }\n    });\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Object) => accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Object) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Object) {\n    if (sourceLayer.id.endsWith('-edit-handles')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isGuide = true;\n    }\n\n    return info;\n  }\n\n  createEditHandleLayers() {\n    if (!this.state.editHandles.length) {\n      return [];\n    }\n\n    const sharedProps = {\n      id: `${this.props.editHandleType.layerName || this.props.editHandleType}-edit-handles`,\n      data: this.state.editHandles,\n      fp64: this.props.fp64,\n\n      parameters: this.props.editHandleParameters,\n      ...this.props.editHandleLayerProps\n    };\n\n    let layer;\n\n    switch (this.props.editHandleType) {\n      case 'icon':\n        layer = new IconLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n            iconAtlas: this.props.editHandleIconAtlas,\n            iconMapping: this.props.editHandleIconMapping,\n            sizeScale: this.props.editHandleIconSizeScale,\n            getIcon: this.props.getEditHandleIcon,\n            getSize: this.props.getEditHandleIconSize,\n            getColor: this.props.getEditHandleIconColor,\n            getAngle: this.props.getEditHandleIconAngle,\n\n            getPosition: d => d.position\n          })\n        );\n        break;\n\n      case 'point':\n        layer = new ScatterplotLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n\n            // Proxy editing point props\n            radiusScale: this.props.editHandlePointRadiusScale,\n            outline: this.props.editHandlePointOutline,\n            strokeWidth: this.props.editHandlePointStrokeWidth,\n            radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n            radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n            getRadius: this.props.getEditHandlePointRadius,\n            getColor: this.props.getEditHandlePointColor\n          })\n        );\n        break;\n\n      default:\n        if (typeof this.props.editHandleType === 'function') {\n          const EditHandleType = this.props.editHandleType;\n          layer = new EditHandleType(\n            this.getSubLayerProps({\n              ...sharedProps,\n\n              // Proxy editing point props\n              radiusScale: this.props.editHandlePointRadiusScale,\n              outline: this.props.editHandlePointOutline,\n              strokeWidth: this.props.editHandlePointStrokeWidth,\n              radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n              radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n              getRadius: this.props.getEditHandlePointRadius,\n              getColor: this.props.getEditHandlePointColor\n            })\n          );\n        }\n        break;\n    }\n\n    return [layer];\n  }\n\n  createTentativeLayers() {\n    if (!this.state.tentativeFeature) {\n      return [];\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: 'tentative',\n        data: this.state.tentativeFeature,\n        fp64: this.props.fp64,\n        pickable: false,\n        stroked: true,\n        autoHighlight: false,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        pointRadiusScale: this.props.editHandlePointRadiusScale,\n        outline: this.props.editHandlePointOutline,\n        strokeWidth: this.props.editHandlePointStrokeWidth,\n        pointRadiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        pointRadiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: this.props.getEditHandlePointRadius,\n        getLineColor: feature => this.props.getTentativeLineColor(feature, this.props.mode),\n        getLineWidth: feature => this.props.getTentativeLineWidth(feature, this.props.mode),\n        getFillColor: feature => this.props.getTentativeFillColor(feature, this.props.mode),\n        getLineDashArray: feature =>\n          this.props.getTentativeLineDashArray(\n            feature,\n            this.state.selectedFeatures[0],\n            this.props.mode\n          )\n      })\n    );\n\n    return [layer];\n  }\n\n  onLayerClick(event: ClickEvent) {\n    this.getActiveModeHandler().handleClick(event);\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    this.getActiveModeHandler().handleStartDragging(event);\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    this.getActiveModeHandler().handleStopDragging(event);\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    this.getActiveModeHandler().handlePointerMove(event);\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    return this.state.cursor;\n  }\n\n  getActiveModeHandler(): GeoJsonEditMode {\n    return this.state.modeHandler;\n  }\n}\n\n// eslint-disable-next-line camelcase\nEditableGeoJsonLayer_EDIT_MODE_POC.layerName = 'EditableGeoJsonLayer_EDIT_MODE_POC';\n// eslint-disable-next-line camelcase\nEditableGeoJsonLayer_EDIT_MODE_POC.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\nimport { CompositeLayer } from '@deck.gl/core';\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { polygon } from '@turf/helpers';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\n\nimport EditableGeoJsonLayer from './editable-geojson-layer';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nconst defaultProps = {\n  selectionType: SELECTION_TYPE.RECTANGLE,\n  layerIds: [],\n  onSelect: () => {}\n};\n\nconst EMPTY_DATA = {\n  type: 'FeatureCollection',\n  features: []\n};\n\nconst EXPANSION_KM = 50;\nconst LAYER_ID_GEOJSON = 'selection-geojson';\nconst LAYER_ID_BLOCKER = 'selection-blocker';\n\nconst PASS_THROUGH_PROPS = [\n  'lineWidthScale',\n  'lineWidthMinPixels',\n  'lineWidthMaxPixels',\n  'lineWidthUnits',\n  'lineJointRounded',\n  'lineMiterLimit',\n  'pointRadiusScale',\n  'pointRadiusMinPixels',\n  'pointRadiusMaxPixels',\n  'lineDashJustified',\n  'getLineColor',\n  'getFillColor',\n  'getRadius',\n  'getLineWidth',\n  'getLineDashArray',\n  'getTentativeLineDashArray',\n  'getTentativeLineColor',\n  'getTentativeFillColor',\n  'getTentativeLineWidth'\n];\n\nexport default class SelectionLayer extends CompositeLayer {\n  _selectRectangleObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n\n    const [x1, y1] = this.context.viewport.project(coordinates[0][0]);\n    const [x2, y2] = this.context.viewport.project(coordinates[0][2]);\n\n    const pickingInfos = this.context.deck.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds\n    });\n\n    onSelect({ pickingInfos });\n  }\n\n  _selectPolygonObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n    const mousePoints = coordinates[0].map(c => this.context.viewport.project(c));\n\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    // Use a polygon to hide the outside, because pickObjects()\n    // does not support polygons\n    const landPointsPoly = polygon(coordinates);\n    const bigBuffer = turfBuffer(landPointsPoly, EXPANSION_KM);\n    let bigPolygon;\n    try {\n      // turfDifference throws an exception if the polygon\n      // intersects with itself (TODO: check if true in all versions)\n      bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n    } catch (e) {\n      // invalid selection polygon\n      console.log('turfDifference() error', e); // eslint-disable-line\n      return;\n    }\n\n    this.setState({\n      pendingPolygonSelection: {\n        bigPolygon\n      }\n    });\n\n    const blockerId = `${this.props.id}-${LAYER_ID_BLOCKER}`;\n\n    // HACK, find a better way\n    setTimeout(() => {\n      const pickingInfos = this.context.deck.pickObjects({\n        x,\n        y,\n        width: maxX - x,\n        height: maxY - y,\n        layerIds: [blockerId, ...layerIds]\n      });\n\n      onSelect({\n        pickingInfos: pickingInfos.filter(item => item.layer.id !== this.props.id)\n      });\n    }, 250);\n  }\n\n  renderLayers() {\n    const { pendingPolygonSelection } = this.state;\n\n    const mode =\n      {\n        [SELECTION_TYPE.RECTANGLE]: 'drawRectangle',\n        [SELECTION_TYPE.POLYGON]: 'drawPolygon'\n      }[this.props.selectionType] || 'view';\n\n    const inheritedProps = {};\n    PASS_THROUGH_PROPS.forEach(p => {\n      if (this.props[p] !== undefined) inheritedProps[p] = this.props[p];\n    });\n\n    const layers = [\n      new EditableGeoJsonLayer(\n        this.getSubLayerProps({\n          id: LAYER_ID_GEOJSON,\n          pickable: true,\n          mode,\n          selectedFeatureIndexes: [],\n          data: EMPTY_DATA,\n          onEdit: ({ updatedData, editType }) => {\n            if (editType === 'addFeature') {\n              const { coordinates } = updatedData.features[0].geometry;\n\n              if (this.props.selectionType === SELECTION_TYPE.RECTANGLE) {\n                this._selectRectangleObjects(coordinates);\n              } else if (this.props.selectionType === SELECTION_TYPE.POLYGON) {\n                this._selectPolygonObjects(coordinates);\n              }\n            }\n          },\n          ...inheritedProps\n        })\n      )\n    ];\n\n    if (pendingPolygonSelection) {\n      const { bigPolygon } = pendingPolygonSelection;\n      layers.push(\n        new PolygonLayer(\n          this.getSubLayerProps({\n            id: LAYER_ID_BLOCKER,\n            pickable: true,\n            stroked: false,\n            opacity: 1.0,\n            data: [bigPolygon],\n            getLineColor: obj => [0, 0, 0, 1],\n            getFillColor: obj => [0, 0, 0, 1],\n            getPolygon: o => o.geometry.coordinates\n          })\n        )\n      );\n    }\n\n    return layers;\n  }\n\n  shouldUpdateState({ changeFlags: { stateChanged, propsOrDataChanged } }: Object) {\n    return stateChanged || propsOrDataChanged;\n  }\n}\n\nSelectionLayer.layerName = 'SelectionLayer';\nSelectionLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer, LineLayer } from '@deck.gl/layers';\n\nconst defaultProps = {};\n\nexport default class ElevatedEditHandleLayer extends CompositeLayer {\n  renderLayers() {\n    const handles = new ScatterplotLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-ScatterplotLayer`,\n        data: this.props.data\n      })\n    );\n\n    const lines = new LineLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-LineLayer`,\n        data: this.props.data,\n        pickable: false,\n        getSourcePosition: ({ position }) => [position[0], position[1], 0],\n        getTargetPosition: ({ position }) => [position[0], position[1], position[2] || 0],\n        getColor: [50, 50, 50, 100],\n        getStrokeWidth: 3\n      })\n    );\n\n    return [handles, lines];\n  }\n}\n\nElevatedEditHandleLayer.layerName = 'ElevatedEditHandleLayer';\nElevatedEditHandleLayer.defaultProps = defaultProps;\n","/* eslint-disable camelcase */\nconst INITIAL_STATE = {\n  outlineEnabled: false,\n  outlineRenderShadowmap: false,\n  outlineShadowmap: null\n};\n\nfunction getUniforms({ outlineEnabled, outlineRenderShadowmap, outlineShadowmap } = INITIAL_STATE) {\n  const uniforms = {};\n  if (outlineEnabled !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uEnabled = outlineEnabled;\n  }\n  if (outlineRenderShadowmap !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uRenderOutlines = outlineRenderShadowmap;\n  }\n  if (outlineShadowmap !== undefined) {\n    uniforms.outline_uShadowmap = outlineShadowmap;\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nattribute float instanceZLevel;\nvarying float outline_vzLevel;\nvarying vec4 outline_vPosition;\n\n// Set the z level for the outline shadowmap rendering\nvoid outline_setZLevel(float zLevel) {\n  outline_vzLevel = zLevel;\n}\n\n// Store an adjusted position for texture2DProj\nvoid outline_setUV(vec4 position) {\n  // mat4(\n  //   0.5, 0.0, 0.0, 0.0,\n  //   0.0, 0.5, 0.0, 0.0,\n  //   0.0, 0.0, 0.5, 0.0,\n  //   0.5, 0.5, 0.5, 1.0\n  // ) * position;\n  outline_vPosition = vec4(position.xyz * 0.5 + position.w * 0.5, position.w);\n}\n`;\n\nconst fs = `\\\nuniform bool outline_uEnabled;\nuniform bool outline_uRenderOutlines;\nuniform sampler2D outline_uShadowmap;\n\nvarying float outline_vzLevel;\n// varying vec2 outline_vUV;\nvarying vec4 outline_vPosition;\n\nconst float OUTLINE_Z_LEVEL_ERROR = 0.01;\n\n// Return a darker color in shadowmap\nvec4 outline_filterShadowColor(vec4 color) {\n  return vec4(outline_vzLevel / 255., outline_vzLevel / 255., outline_vzLevel / 255., 1.);\n}\n\n// Return a darker color if in shadowmap\nvec4 outline_filterDarkenColor(vec4 color) {\n  if (outline_uEnabled) {\n    float maxZLevel;\n    if (outline_vPosition.q > 0.0) {\n      maxZLevel = texture2DProj(outline_uShadowmap, outline_vPosition).r * 255.;\n    } else {\n      discard;\n    }\n    if (maxZLevel < outline_vzLevel + OUTLINE_Z_LEVEL_ERROR) {\n      vec4(color.rgb * 0.5, color.a);\n    } else {\n      discard;\n    }\n  }\n  return color;\n}\n\n// if enabled and rendering outlines - Render depth to shadowmap\n// if enabled and rendering colors - Return a darker color if in shadowmap\n// if disabled, just return color\nvec4 outline_filterColor(vec4 color) {\n  if (outline_uEnabled) {\n    return outline_uRenderOutlines ?\n      outline_filterShadowColor(color) :\n      outline_filterDarkenColor(color);\n  }\n  return color;\n}\n`;\n\nexport default {\n  name: 'outline',\n  vs,\n  fs,\n  getUniforms\n};\n","import { PathLayer } from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport { Framebuffer, Texture2D } from '@luma.gl/core';\nimport outline from '../../shaderlib/outline/outline';\n\n// TODO - this should be built into assembleShaders\nfunction injectShaderCode({ source, code = '' }) {\n  const INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nconst VS_CODE = `\\\n  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n`;\n\nconst FS_CODE = `\\\n  gl_FragColor = outline_filterColor(gl_FragColor);\n`;\n\nconst defaultProps = {\n  getZLevel: { type: 'accessor', value: 0 }\n};\n\nexport default class PathOutlineLayer extends PathLayer {\n  // Override getShaders to inject the outline module\n  getShaders() {\n    const shaders = super.getShaders();\n    return Object.assign({}, shaders, {\n      modules: shaders.modules.concat([outline]),\n      vs: injectShaderCode({ source: shaders.vs, code: VS_CODE }),\n      fs: injectShaderCode({ source: shaders.fs, code: FS_CODE })\n    });\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    // Create an outline \"shadow\" map\n    // TODO - we should create a single outlineMap for all layers\n    this.setState({\n      outlineFramebuffer: new Framebuffer(context.gl),\n      dummyTexture: new Texture2D(context.gl)\n    });\n\n    // Create an attribute manager\n    this.state.attributeManager.addInstanced({\n      instanceZLevel: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateZLevels,\n        accessor: 'getZLevel'\n      }\n    });\n  }\n\n  // Override draw to add render module\n  draw({ moduleParameters = {}, parameters, uniforms, context }) {\n    // Need to calculate same uniforms as base layer\n    const {\n      rounded,\n      miterLimit,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n      dashJustified\n    } = this.props;\n\n    uniforms = Object.assign({}, uniforms, {\n      jointType: Number(rounded),\n      alignMode: Number(dashJustified),\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    });\n\n    // Render the outline shadowmap (based on segment z orders)\n    const { outlineFramebuffer, dummyTexture } = this.state;\n    outlineFramebuffer.resize();\n    outlineFramebuffer.clear({ color: true, depth: true });\n\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: true,\n      outlineShadowmap: dummyTexture\n    });\n\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: 0,\n        widthScale: this.props.widthScale * 1.3\n      }),\n      parameters: {\n        depthTest: false,\n        // Biggest value needs to go into buffer\n        blendEquation: GL.MAX\n      },\n      framebuffer: outlineFramebuffer\n    });\n\n    // Now use the outline shadowmap to render the lines (with outlines)\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: false,\n      outlineShadowmap: outlineFramebuffer\n    });\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        widthScale: this.props.widthScale\n      }),\n      parameters: {\n        depthTest: false\n      }\n    });\n  }\n\n  calculateZLevels(attribute) {\n    const { getZLevel } = this.props;\n    const { pathTesselator } = this.state;\n\n    attribute.value = pathTesselator._updateAttribute({\n      target: attribute.value,\n      size: 1,\n      getValue: (object, index) => [getZLevel(object, index) || 0]\n    });\n  }\n}\n\nPathOutlineLayer.layerName = 'PathOutlineLayer';\nPathOutlineLayer.defaultProps = defaultProps;\n","// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { Layer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport { Model, Geometry, loadTextures, Texture2D, fp64 } from '@luma.gl/core';\nconst { fp64LowPart } = fp64;\n\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nconst RADIAN_PER_DEGREE = Math.PI / 180;\n\n// Replacement for the external assert method to reduce bundle size\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(`deck.gl: ${message}`);\n  }\n}\n\n/*\n * Load image data into luma.gl Texture2D objects\n * @param {WebGLContext} gl\n * @param {String|Texture2D|HTMLImageElement|Uint8ClampedArray} src - source of image data\n *   can be url string, Texture2D object, HTMLImageElement or pixel array\n * @returns {Promise} resolves to an object with name -> texture mapping\n */\nfunction getTexture(gl, src, opts) {\n  if (typeof src === 'string') {\n    // Url, load the image\n    return loadTextures(gl, Object.assign({ urls: [src] }, opts))\n      .then(textures => textures[0])\n      .catch(error => {\n        throw new Error(`Could not load texture from ${src}: ${error}`);\n      });\n  }\n  return new Promise(resolve => resolve(getTextureFromData(gl, src, opts)));\n}\n\n/*\n * Convert image data into texture\n * @returns {Texture2D} texture\n */\nfunction getTextureFromData(gl, data, opts) {\n  if (data instanceof Texture2D) {\n    return data;\n  }\n  return new Texture2D(gl, Object.assign({ data }, opts));\n}\n\nfunction validateGeometryAttributes(attributes) {\n  assert(attributes.positions && attributes.normals && attributes.texCoords);\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data) {\n  if (data instanceof Geometry) {\n    validateGeometryAttributes(data.attributes);\n    return data;\n  } else if (data.positions) {\n    validateGeometryAttributes(data);\n    return new Geometry({\n      attributes: data\n    });\n  }\n  throw Error('Invalid mesh');\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  mesh: null,\n  texture: null,\n  sizeScale: { type: 'number', value: 1, min: 0 },\n\n  // TODO - parameters should be merged, not completely overridden\n  parameters: {\n    depthTest: true,\n    depthFunc: GL.LEQUAL\n  },\n  fp64: false,\n  // Optional settings for 'lighting' shader module\n  lightSettings: {},\n\n  getPosition: { type: 'accessor', value: x => x.position },\n  getColor: { type: 'accessor', value: DEFAULT_COLOR },\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  getYaw: { type: 'accessor', value: x => x.yaw || x.angle || 0 },\n  getPitch: { type: 'accessor', value: x => x.pitch || 0 },\n  getRoll: { type: 'accessor', value: x => x.roll || 0 }\n};\n\nexport default class MeshLayer extends Layer {\n  getShaders() {\n    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n    return { vs, fs, modules: [projectModule, 'lighting', 'picking'] };\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instancePositions64xy: {\n        size: 2,\n        accessor: 'getPosition',\n        update: this.calculateInstancePositions64xyLow\n      },\n      instanceRotations: {\n        size: 3,\n        accessor: ['getYaw', 'getPitch', 'getRoll'],\n        update: this.calculateInstanceRotations\n      },\n      instanceColors: {\n        size: 4,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      }\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    const attributeManager = this.getAttributeManager();\n\n    // super.updateState({props, oldProps, changeFlags});\n    if (changeFlags.dataChanged) {\n      attributeManager.invalidateAll();\n    }\n\n    this._updateFP64(props, oldProps);\n\n    if (props.texture !== oldProps.texture) {\n      this.setTexture(props.texture);\n    }\n  }\n\n  _updateFP64(props, oldProps) {\n    if (props.fp64 !== oldProps.fp64) {\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n\n      this.setState({ model: this.getModel(this.context.gl) });\n\n      this.setTexture(this.state.texture);\n\n      const attributeManager = this.getAttributeManager();\n      attributeManager.invalidateAll();\n    }\n  }\n\n  draw({ uniforms }) {\n    const { sizeScale } = this.props;\n\n    this.state.model.render(\n      Object.assign({}, uniforms, {\n        sizeScale\n      })\n    );\n  }\n\n  getModel(gl) {\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: getGeometry(this.props.mesh),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      })\n    );\n  }\n\n  setTexture(src) {\n    const { gl } = this.context;\n    const { model, emptyTexture } = this.state;\n\n    if (src) {\n      getTexture(gl, src).then(texture => {\n        model.setUniforms({ sampler: texture, hasTexture: 1 });\n        this.setState({ texture });\n      });\n    } else {\n      // reset\n      this.state.model.setUniforms({ sampler: emptyTexture, hasTexture: 0 });\n      this.setState({ texture: null });\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const isFP64 = this.use64bitPositions();\n    attribute.constant = !isFP64;\n\n    if (!isFP64) {\n      attribute.value = new Float32Array(2);\n      return;\n    }\n\n    const { data, getPosition } = this.props;\n    const { value } = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = fp64LowPart(position[0]);\n      value[i++] = fp64LowPart(position[1]);\n    }\n  }\n\n  // yaw(z), pitch(y) and roll(x) in radians\n  calculateInstanceRotations(attribute) {\n    const { data, getYaw, getPitch, getRoll } = this.props;\n    const { value, size } = attribute;\n    let i = 0;\n    for (const point of data) {\n      value[i++] = getRoll(point) * RADIAN_PER_DEGREE;\n      value[i++] = getPitch(point) * RADIAN_PER_DEGREE;\n      value[i++] = getYaw(point) * RADIAN_PER_DEGREE;\n    }\n  }\n}\n\nMeshLayer.layerName = 'MeshLayer';\nMeshLayer.defaultProps = defaultProps;\n","export default `\n#define SHADER_NAME mesh-layer-vs\n\n// Scale the model\nuniform float sizeScale;\n\n// Primitive attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\n// Instance attributes\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xy;\nattribute vec3 instanceRotations;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Outputs to fragment shader\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\n\n// yaw(z) pitch(y) roll(x)\nmat3 getRotationMatrix(vec3 rotation) {\n  float sr = sin(rotation.x);\n  float sp = sin(rotation.y);\n  float sw = sin(rotation.z);\n\n  float cr = cos(rotation.x);\n  float cp = cos(rotation.y);\n  float cw = cos(rotation.z);\n\n  return mat3(\n    cw * cp,                  // 0,0\n    sw * cp,                  // 1,0\n    -sp,                      // 2,0\n    -sw * cr + cw * sp * sr,  // 0,1\n    cw * cr + sw * sp * sr,   // 1,1\n    cp * sr,                  // 2,1\n    sw * sr + cw * sp * cr,   // 0,2\n    -cw * sr + sw * sp * cr,  // 1,2\n    cp * cr                   // 2,2\n  );\n}\n\nvoid main(void) {\n  mat3 rotationMatrix = getRotationMatrix(instanceRotations);\n\n  vec3 pos = rotationMatrix * positions;\n  pos = project_scale(pos * sizeScale);\n  // TODO - backward compatibility, remove in next major release\n  if (project_uPixelsPerMeter.y < 0.0) {\n    pos.y = -pos.y;\n  }\n\n  vec4 worldPosition;\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xy, pos, worldPosition);\n\n  // TODO - transform normals\n\n  picking_setPickingColor(instancePickingColors);\n\n  vTexCoord = texCoords;\n  vColor = instanceColors;\n}\n`;\n","export default `\n#define SHADER_NAME mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform vec4 color;\n\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = hasTexture ? texture2D(sampler, vTexCoord) : vColor / 255.;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n`;\n","import { Geometry } from '@luma.gl/core';\n\nexport default class Arrow2DGeometry extends Geometry {\n  constructor(opts = {}) {\n    super(\n      Object.assign({}, opts, {\n        attributes: getArrowAttributes(opts)\n      })\n    );\n  }\n}\n\nfunction getArrowAttributes({ length = 1, headSize = 0.2, tailWidth = 0.05, tailStart = 0.05 }) {\n  const texCoords = [\n    // HEAD\n    0.5,\n    1.0,\n    0,\n    0.5 - headSize / 2,\n    1.0 - headSize,\n    0,\n    0.5 + headSize / 2,\n    1.0 - headSize,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    tailStart,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 - tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0\n  ];\n\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\n\n  // Center and scale\n  const positions = new Array(texCoords.length);\n  for (let i = 0; i < texCoords.length / 3; i++) {\n    const i3 = i * 3;\n    positions[i3 + 0] = (texCoords[i3 + 0] - 0.5) * length;\n    positions[i3 + 1] = (texCoords[i3 + 1] - 0.5) * length;\n    positions[i3 + 2] = 0;\n  }\n  return {\n    positions: new Float32Array(positions),\n    normals: new Float32Array(normals),\n    texCoords: new Float32Array(texCoords)\n  };\n}\n","import { Vector2 } from 'math.gl';\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  let lineLength = 0;\n  for (let i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n  return lineLength;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_DIRECTION = { forward: true, backward: false };\n\nexport default function createPathMarkers({\n  data,\n  getPath = x => x.path,\n  getDirection = x => x.direction,\n  getColor = x => DEFAULT_COLOR,\n  getMarkerPercentages = x => [0.5],\n  projectFlat\n}) {\n  const markers = [];\n\n  for (const object of data) {\n    const path = getPath(object);\n    const direction = getDirection(object) || DEFAULT_DIRECTION;\n    const color = getColor(object);\n\n    const vPoints = path.map(p => new Vector2(p));\n    const vPointsReverse = vPoints.slice(0).reverse();\n\n    // calculate total length\n    const lineLength = getLineLength(vPoints);\n\n    // Ask for where to put markers\n    const percentages = getMarkerPercentages(object, { lineLength });\n\n    // Create the markers\n    for (const percentage of percentages) {\n      if (direction.forward) {\n        const marker = createMarkerAlongPath({\n          path: vPoints,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n\n      if (direction.backward) {\n        const marker = createMarkerAlongPath({\n          path: vPointsReverse,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n    }\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath({ path, percentage, lineLength, color, object, projectFlat }) {\n  const distanceAlong = lineLength * percentage;\n  let currentDistance = 0;\n  let previousDistance = 0;\n  let i = 0;\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n    previousDistance = currentDistance;\n  }\n\n  const vDirection = path[i + 1]\n    .clone()\n    .subtract(path[i])\n    .normalize();\n  const along = distanceAlong - previousDistance;\n  const vCenter = vDirection\n    .clone()\n    .multiply(new Vector2(along, along))\n    .add(path[i]);\n\n  const vDirection2 = new Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n  const angle = (-vDirection2.verticalAngle() * 180) / Math.PI;\n\n  return { position: [vCenter.x, vCenter.y, 0], angle, color, object };\n}\n","import { Vector3, clamp } from 'math.gl';\n\n// Return the closest point on a line segment\nexport function getClosestPointOnLine({ p, p1, p2, clampToLine = true }) {\n  const lineVector = new Vector3(p2).subtract(p1);\n  const pointVector = new Vector3(p).subtract(p1);\n  let dotProduct = lineVector.dot(pointVector);\n  if (clampToLine) {\n    dotProduct = clamp(dotProduct, 0, 1);\n  }\n  return lineVector.lerp(dotProduct);\n}\n\n// Return the closest point on a line segment\nexport function getClosestPointOnPolyline({ p, points }) {\n  p = new Vector3(p);\n  let pClosest = null;\n  let distanceSquared = Infinity;\n  let index = -1;\n  for (let i = 0; i < points.length - 1; ++i) {\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const pClosestOnLine = getClosestPointOnLine({ p, p1, p2 });\n    const distanceToLineSquared = p.distanceSquared(pClosestOnLine);\n    if (distanceToLineSquared < distanceSquared) {\n      distanceSquared = distanceToLineSquared;\n      pClosest = pClosestOnLine;\n      index = i;\n    }\n  }\n  return {\n    point: pClosest,\n    index,\n    p1: points[index],\n    p2: points[index + 1],\n    distanceSquared,\n    distance: Math.sqrt(distanceSquared)\n  };\n}\n","import { CompositeLayer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\nimport PathOutlineLayer from '../path-outline-layer/path-outline-layer';\nimport MeshLayer from '../mesh-layer/mesh-layer';\nimport Arrow2DGeometry from './arrow-2d-geometry';\n\nimport createPathMarkers from './create-path-markers';\nimport { getClosestPointOnPolyline } from './polyline';\n\nconst DISTANCE_FOR_MULTI_ARROWS = 0.1;\nconst ARROW_HEAD_SIZE = 0.2;\nconst ARROW_TAIL_WIDTH = 0.05;\n// const ARROW_CENTER_ADJUST = -0.8;\n\nconst DEFAULT_MARKER_LAYER = MeshLayer;\n\nconst DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH })\n};\n\nconst defaultProps = Object.assign({}, PathOutlineLayer.defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n\n  sizeScale: 100,\n  fp64: false,\n\n  hightlightIndex: -1,\n  highlightPoint: null,\n\n  getPath: x => x.path,\n  getColor: x => x.color,\n  getMarkerColor: x => [0, 0, 0, 255],\n  getDirection: x => x.direction,\n  getMarkerPercentages: (object, { lineLength }) =>\n    lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5]\n});\n\nexport default class PathMarkerLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      markers: [],\n      mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n      closestPoint: null\n    };\n  }\n\n  projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n    if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n      const [dx, dy] = viewport.metersToLngLatDelta(xyz);\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    } else if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n      const [dx, dy] = xyz;\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    }\n\n    return viewport.projectFlat(xyz);\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n      const {\n        data,\n        getPath,\n        getDirection,\n        getMarkerColor,\n        getMarkerPercentages,\n        coordinateSystem,\n        coordinateOrigin\n      } = this.props;\n      const { viewport } = this.context;\n      const projectFlat = o => this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n      this.state.markers = createPathMarkers({\n        data,\n        getPath,\n        getDirection,\n        getColor: getMarkerColor,\n        getMarkerPercentages,\n        projectFlat\n      });\n      this._recalculateClosestPoint();\n    }\n    if (changeFlags.propsChanged) {\n      if (props.point !== oldProps.point) {\n        this._recalculateClosestPoint();\n      }\n    }\n  }\n\n  _recalculateClosestPoint() {\n    const { highlightPoint, highlightIndex } = this.props;\n    if (highlightPoint && highlightIndex >= 0) {\n      const object = this.props.data[highlightIndex];\n      const points = this.props.getPath(object);\n      const { point } = getClosestPointOnPolyline({ points, p: highlightPoint });\n      this.state.closestPoints = [\n        {\n          position: point\n        }\n      ];\n    } else {\n      this.state.closestPoints = [];\n    }\n  }\n\n  getPickingInfo({ info }) {\n    return Object.assign(info, {\n      // override object with picked feature\n      object: (info.object && info.object.path) || info.object\n    });\n  }\n\n  renderLayers() {\n    return [\n      new PathOutlineLayer(\n        this.props,\n        this.getSubLayerProps({\n          id: 'paths',\n          // Note: data has to be passed explicitly like this to avoid being empty\n          data: this.props.data\n        })\n      ),\n      new this.props.MarkerLayer(\n        this.getSubLayerProps(\n          Object.assign({}, this.props.markerLayerProps, {\n            id: 'markers',\n            data: this.state.markers,\n            sizeScale: this.props.sizeScale,\n            fp64: this.props.fp64,\n            pickable: false,\n            parameters: {\n              blend: false,\n              depthTest: false\n            }\n          })\n        )\n      ),\n      this.state.closestPoints &&\n        new ScatterplotLayer({\n          id: `${this.props.id}-highlight`,\n          data: this.state.closestPoints,\n          fp64: this.props.fp64\n        })\n    ];\n  }\n}\n\nPathMarkerLayer.layerName = 'PathMarkerLayer';\nPathMarkerLayer.defaultProps = defaultProps;\n","// @flow\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\n\nexport default class JunctionScatterplotLayer extends CompositeLayer {\n  static layerName = 'JunctionScatterplotLayer';\n  static defaultProps = {\n    ...ScatterplotLayer.defaultProps,\n    getFillColor: d => [0, 0, 0, 255],\n    getStrokeColor: d => [255, 255, 255, 255],\n    getInnerRadius: d => 1\n  };\n\n  renderLayers() {\n    const { id, getFillColor, getStrokeColor, getInnerRadius, updateTriggers } = this.props;\n\n    // data needs to be passed explicitly after deck.gl 5.3\n    return [\n      // the full circles\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-full`,\n        data: this.props.data,\n        getColor: getStrokeColor,\n        updateTriggers: {\n          ...updateTriggers,\n          getColor: updateTriggers.getStrokeColor\n        }\n      }),\n      // the inner part\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-inner`,\n        data: this.props.data,\n        getColor: getFillColor,\n        getRadius: getInnerRadius,\n        pickable: false,\n        updateTriggers: {\n          ...updateTriggers,\n          getColor: updateTriggers.getFillColor,\n          getRadius: updateTriggers.getInnerRadius\n        }\n      })\n    ];\n  }\n}\n","// @flow\n\nimport type { FeatureCollection, Feature, Position } from '@nebula.gl/edit-modes';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../event-types.js';\nimport { ModeHandler, type EditAction, type EditHandle } from './mode-handler.js';\n\nexport class CompositeModeHandler extends ModeHandler {\n  handlers: Array<ModeHandler>;\n  options: Object;\n\n  constructor(handlers: Array<ModeHandler>, options: Object = {}) {\n    super();\n    this.handlers = handlers;\n    this.options = options;\n  }\n\n  _coalesce<T>(callback: ModeHandler => T, resultEval: ?(T) => boolean = null): T {\n    let result: T;\n\n    for (let i = 0; i < this.handlers.length; i++) {\n      result = callback(this.handlers[i]);\n      if (resultEval ? resultEval(result) : result) {\n        break;\n      }\n    }\n\n    return (result: any);\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.handlers.forEach(handler => handler.setFeatureCollection(featureCollection));\n  }\n\n  setModeConfig(modeConfig: any): void {\n    this.handlers.forEach(handler => handler.setModeConfig(modeConfig));\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    this.handlers.forEach(handler => handler.setSelectedFeatureIndexes(indexes));\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleClick(event));\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    return this._coalesce(\n      handler => handler.handlePointerMove(event),\n      result => result && Boolean(result.editAction)\n    );\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleStartDragging(event));\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleStopDragging(event));\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._coalesce(handler => handler.getTentativeFeature());\n  }\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    // TODO: Combine the handles *BUT* make sure if none of the results have\n    // changed to return the same object so that \"editHandles !== this.state.editHandles\"\n    // in editable-geojson-layer works.\n    return this._coalesce(\n      handler => handler.getEditHandles(picks, groundCoords),\n      handles => Array.isArray(handles) && handles.length > 0\n    );\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return this._coalesce(handler => handler.getCursor({ isDragging }));\n  }\n}\n","// @flow\nimport { PathMarkerLayer } from '@nebula.gl/layers';\nimport { MAX } from '@luma.gl/constants';\n\nimport { ArrowStyles, DEFAULT_STYLE, MAX_ARROWS } from '../style';\nimport NebulaLayer from '../nebula-layer';\nimport { toDeckColor } from '../utils';\nimport DeckCache from '../deck-renderer/deck-cache';\n\nconst NEBULA_TO_DECK_DIRECTIONS = {\n  [ArrowStyles.NONE]: { forward: false, backward: false },\n  [ArrowStyles.FORWARD]: { forward: true, backward: false },\n  [ArrowStyles.BACKWARD]: { forward: false, backward: true },\n  [ArrowStyles.BOTH]: { forward: true, backward: true }\n};\n\nexport default class SegmentsLayer extends NebulaLayer {\n  deckCache: DeckCache<*, *>;\n  noBlend: boolean;\n  highlightColor: [number, number, number, number];\n  arrowSize: number;\n  rounded: boolean;\n  dashed: boolean;\n  markerLayerProps: ?Object;\n\n  constructor(config: Object) {\n    super(config);\n    this.deckCache = new DeckCache(config.getData, data => config.toNebulaFeature(data));\n    this.enableSelection = true;\n    const {\n      enablePicking = true,\n      noBlend = false,\n      rounded = true,\n      dashed = false,\n      markerLayerProps = null\n    } = config;\n    Object.assign(this, { enablePicking, noBlend, rounded, dashed, markerLayerProps });\n  }\n\n  getMouseOverSegment(): any {\n    // TODO: remove references\n    return null;\n  }\n\n  _calcMarkerPercentages(nf: Object): number[] {\n    const { arrowPercentages } = nf.style;\n    if (arrowPercentages) {\n      return arrowPercentages;\n    }\n\n    const arrowStyle = nf.style.arrowStyle || DEFAULT_STYLE.arrowStyle;\n    if (arrowStyle === ArrowStyles.NONE) return [];\n\n    const arrowCount = Math.min(nf.style.arrowCount || DEFAULT_STYLE.arrowCount, MAX_ARROWS);\n    return [[0.5], [0.33, 0.66], [0.25, 0.5, 0.75]][arrowCount - 1];\n  }\n\n  _getHighlightedObjectIndex({ nebula }: Object): number {\n    const { deckglMouseOverInfo } = nebula;\n    if (deckglMouseOverInfo) {\n      const { originalLayer, index } = deckglMouseOverInfo;\n      if (originalLayer === this) {\n        return index;\n      }\n    }\n\n    // no object\n    return -1;\n  }\n\n  render({ nebula }: Object) {\n    const defaultColor = [0x0, 0x0, 0x0, 0xff];\n    const { objects, updateTrigger } = this.deckCache;\n\n    return new PathMarkerLayer({\n      id: `segments-${this.id}`,\n      data: objects,\n      opacity: 1,\n      fp64: false,\n      rounded: this.rounded,\n      pickable: true,\n      sizeScale: this.arrowSize || 6,\n      parameters: {\n        depthTest: false,\n        blend: !this.noBlend,\n        blendEquation: MAX\n      },\n      getPath: nf => nf.geoJson.geometry.coordinates,\n      getColor: nf => toDeckColor(nf.style.lineColor, defaultColor),\n      getWidth: nf => nf.style.lineWidthMeters || 1,\n      getZLevel: nf => nf.style.zLevel * 255,\n      getDirection: nf => NEBULA_TO_DECK_DIRECTIONS[nf.style.arrowStyle],\n      getMarkerColor: nf => toDeckColor(nf.style.arrowColor, defaultColor),\n      getMarkerPercentages: this._calcMarkerPercentages,\n      updateTriggers: { all: updateTrigger },\n\n      highlightedObjectIndex: this._getHighlightedObjectIndex({ nebula }),\n      highlightColor: toDeckColor(this.highlightColor),\n\n      dashJustified: this.dashed,\n      getDashArray: this.dashed ? nf => nf.style.dashArray : null,\n      markerLayerProps:\n        this.markerLayerProps || (PathMarkerLayer: Object).defaultProps.markerLayerProps,\n\n      nebulaLayer: this\n    });\n  }\n}\n","import React from 'react';\n\nexport const styles = {\n  toolbox: {\n    position: 'absolute',\n    top: 12,\n    left: 12,\n    background: 'white',\n    padding: 10,\n    borderRadius: 4,\n    border: '1px solid gray',\n    width: 350,\n    fontFamily: 'Arial, Helvetica, sans-serif',\n    fontSize: '13px'\n  },\n  toolboxRow: {\n    display: 'flex',\n    flexWrap: 'wrap'\n  },\n  toolboxRowWrapping: {\n    display: 'flex',\n    marginBottom: '5px',\n    flexWrap: 'wrap'\n  },\n  toolboxDivider: {\n    marginBottom: '5px',\n    borderBottom: '1px solid gray'\n  },\n  toolboxItem: {\n    flexBasis: '50%'\n  },\n  toolboxLabel: {}\n};\n\nexport const ToolboxRow = props => <div style={styles.toolboxRow}>{props.children}</div>;\nexport const ToolboxRowWrapping = props => (\n  <div style={styles.toolboxRowWrapping}>{props.children}</div>\n);\nexport const ToolboxLabel = props => <div style={styles.toolboxLabel}>{props.children}</div>;\nexport const ToolboxControl = props => <div style={styles.toolboxItem}>{props.children}</div>;\nexport const ToolboxDivider = props => <div style={styles.toolboxDivider} />;\n","// @flow\n/* eslint-env browser */\n\nimport window from 'global/window';\nimport React, { Component } from 'react';\nimport DeckGL from '@deck.gl/react';\nimport { MapView, MapController } from '@deck.gl/core';\nimport { StaticMap } from 'react-map-gl';\nimport GL from '@luma.gl/constants';\nimport circle from '@turf/circle';\n\nimport {\n  EditableGeoJsonLayer,\n  EditableGeoJsonLayer_EDIT_MODE_POC as EditableGeoJsonLayerEditModePoc,\n  SelectionLayer,\n  CompositeModeHandler,\n  ModifyHandler,\n  ElevationHandler,\n  DrawLineStringHandler,\n  ElevatedEditHandleLayer,\n  SELECTION_TYPE\n} from 'nebula.gl';\n\nimport sampleGeoJson from '../data/sample-geojson.json';\n\nimport iconSheet from '../data/edit-handles.png';\n\nimport {\n  ToolboxControl,\n  ToolboxDivider,\n  ToolboxLabel,\n  ToolboxRow,\n  ToolboxRowWrapping,\n  styles as ToolboxStyles\n} from './toolbox';\n\n// TODO: once we refactor EditableGeoJsonLayer to use new EditMode interface, this can go away\nlet EditableGeoJsonLayerImpl = EditableGeoJsonLayer;\nif (\n  window.location &&\n  window.location.search &&\n  window.location.search.indexOf('useEditModePoc') !== -1\n) {\n  EditableGeoJsonLayerImpl = EditableGeoJsonLayerEditModePoc;\n}\n\nconst styles = {\n  mapContainer: {\n    alignItems: 'stretch',\n    display: 'flex',\n    height: '100vh'\n  },\n  checkbox: {\n    margin: 10\n  }\n};\n\nconst initialViewport = {\n  bearing: 0,\n  height: 0,\n  latitude: 37.76,\n  longitude: -122.44,\n  pitch: 0,\n  width: 0,\n  zoom: 11\n};\n\nconst ALL_MODES = [\n  { category: 'View', modes: ['view'] },\n  {\n    category: 'Alter',\n    modes: ['modify', 'elevation', 'translate', 'rotate', 'scale', 'duplicate', 'extrude', 'split']\n  },\n  {\n    category: 'Draw',\n    modes: [\n      'drawPoint',\n      'drawLineString',\n      'drawPolygon',\n      'draw90DegreePolygon',\n      'drawRectangle',\n      'drawRectangleUsing3Points',\n      'drawCircleFromCenter',\n      'drawCircleByBoundingBox',\n      'drawEllipseByBoundingBox',\n      'drawEllipseUsing3Points'\n    ]\n  },\n  {\n    category: 'Composite',\n    modes: ['drawLineString+modify']\n  }\n];\n\nconst POLYGON_DRAWING_MODES = [\n  'drawPolygon',\n  'draw90DegreePolygon',\n  'drawRectangle',\n  'drawRectangleUsing3Points',\n  'drawCircleFromCenter',\n  'drawCircleByBoundingBox',\n  'drawEllipseByBoundingBox',\n  'drawEllipseUsing3Points'\n];\n\nconst modeHandlers = Object.assign(\n  {\n    'drawLineString+modify': new CompositeModeHandler([\n      new DrawLineStringHandler(),\n      new ModifyHandler()\n    ])\n  },\n  EditableGeoJsonLayerImpl.defaultProps.modeHandlers\n);\n\nfunction getEditHandleColor(handle: Object) {\n  switch (handle.type) {\n    case 'existing':\n      return [0xff, 0x80, 0x00, 0xff];\n    case 'snap':\n      return [0x7c, 0x00, 0xc0, 0xff];\n    case 'intermediate':\n    default:\n      return [0x0, 0x0, 0x0, 0x80];\n  }\n}\n\nexport default class Example extends Component<\n  {},\n  {\n    viewport: Object,\n    testFeatures: any,\n    mode: string,\n    modeConfig: any,\n    pointsRemovable: boolean,\n    selectedFeatureIndexes: number[],\n    editHandleType: string,\n    selectionTool: ?string,\n    showGeoJson: boolean\n  }\n> {\n  constructor() {\n    super();\n\n    this.state = {\n      viewport: initialViewport,\n      testFeatures: sampleGeoJson,\n      mode: 'drawPolygon',\n      modeConfig: null,\n      pointsRemovable: true,\n      selectedFeatureIndexes: [],\n      editHandleType: 'point',\n      selectionTool: null,\n      showGeoJson: false\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this._resize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize);\n  }\n\n  _onChangeViewport = (viewport: Object) => {\n    this.setState({\n      viewport: { ...this.state.viewport, ...viewport }\n    });\n  };\n\n  _onLayerClick = (info: any) => {\n    console.log('onLayerClick', info); // eslint-disable-line\n\n    if (this.state.mode !== 'view' || this.state.selectionTool) {\n      // don't change selection while editing\n      return;\n    }\n\n    if (info) {\n      console.log(`select editing feature ${info.index}`); // eslint-disable-line\n      // a feature was clicked\n      // TODO: once https://github.com/uber/deck.gl/pull/1918 lands, this will work since it'll work with Multi* geometry types\n      this.setState({ selectedFeatureIndexes: [info.index] });\n    } else {\n      console.log('deselect editing feature'); // eslint-disable-line\n      // open space was clicked, so stop editing\n      this.setState({ selectedFeatureIndexes: [] });\n    }\n  };\n\n  _resize = () => {\n    this.forceUpdate();\n  };\n\n  _loadSample = (type: string) => {\n    if (type === 'mixed') {\n      this.setState({\n        testFeatures: sampleGeoJson,\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'complex') {\n      this.setState({\n        testFeatures: {\n          type: 'FeatureCollection',\n          features: [\n            circle([-122.45, 37.81], 4, { steps: 5000 }),\n            circle([-122.33, 37.81], 4, { steps: 5000 }),\n            circle([-122.45, 37.73], 4, { steps: 5000 }),\n            circle([-122.33, 37.73], 4, { steps: 5000 })\n          ]\n        },\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'blank') {\n      this.setState({\n        testFeatures: {\n          type: 'FeatureCollection',\n          features: []\n        }\n      });\n    }\n  };\n\n  _renderSelectFeatureCheckbox(index: number, featureType: string) {\n    const { selectedFeatureIndexes } = this.state;\n    return (\n      <ToolboxLabel key={index}>\n        <label>\n          <input\n            style={styles.checkbox}\n            type=\"checkbox\"\n            checked={selectedFeatureIndexes.includes(index)}\n            onChange={() => {\n              if (selectedFeatureIndexes.includes(index)) {\n                this.setState({\n                  selectedFeatureIndexes: selectedFeatureIndexes.filter(e => e !== index)\n                });\n              } else {\n                this.setState({\n                  selectedFeatureIndexes: [...selectedFeatureIndexes, index]\n                });\n              }\n            }}\n          />\n          {index}\n          {': '}\n          {featureType}\n        </label>\n      </ToolboxLabel>\n    );\n  }\n\n  _renderSelectFeatureCheckboxes() {\n    const {\n      testFeatures: { features }\n    } = this.state;\n    const checkboxes = [];\n    for (let i = 0; i < features.length; ++i) {\n      checkboxes.push(this._renderSelectFeatureCheckbox(i, features[i].geometry.type));\n    }\n    return checkboxes;\n  }\n\n  _renderBooleanOperationControls() {\n    const operations = ['union', 'difference', 'intersection'];\n    return (\n      <ToolboxRow key=\"booleanOperations\">\n        <ToolboxLabel>Boolean operation (requires single selection)</ToolboxLabel>\n        <ToolboxControl>\n          {operations.map(operation => (\n            <button\n              key={operation}\n              style={{\n                backgroundColor:\n                  this.state.modeConfig && this.state.modeConfig.booleanOperation === operation\n                    ? '#a0cde8'\n                    : ''\n              }}\n              onClick={() => {\n                if (this.state.modeConfig && this.state.modeConfig.booleanOperation === operation) {\n                  this.setState({ modeConfig: null });\n                } else {\n                  this.setState({ modeConfig: { booleanOperation: operation } });\n                }\n              }}\n            >\n              {operation}\n            </button>\n          ))}\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderDrawLineStringModeControls() {\n    return (\n      <ToolboxRow key=\"drawLineString\">\n        <ToolboxLabel>Draw LineString At Front</ToolboxLabel>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.drawAtFront)}\n            onChange={event =>\n              this.setState({\n                modeConfig: {\n                  drawAtFront: Boolean(event.target.checked)\n                }\n              })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderModifyModeControls() {\n    return (\n      <ToolboxRow key=\"modify\">\n        <ToolboxLabel>Allow removing points</ToolboxLabel>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={this.state.pointsRemovable}\n            onChange={() => this.setState({ pointsRemovable: !this.state.pointsRemovable })}\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSplitModeControls() {\n    return (\n      <ToolboxRow key=\"split\">\n        <ToolboxLabel>Constrain to 90&deg;</ToolboxLabel>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.lock90Degree)}\n            onChange={event =>\n              this.setState({ modeConfig: { lock90Degree: Boolean(event.target.checked) } })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSnappingControls() {\n    return (\n      <div key=\"snap\">\n        <ToolboxRow>\n          <ToolboxLabel>Enable snapping</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={Boolean(this.state.modeConfig && this.state.modeConfig.enableSnapping)}\n              onChange={event => {\n                const modeConfig = {\n                  ...this.state.modeConfig,\n                  enableSnapping: Boolean(event.target.checked)\n                };\n                this.setState({ modeConfig });\n              }}\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n      </div>\n    );\n  }\n\n  _renderModeConfigControls() {\n    const controls = [];\n\n    if (POLYGON_DRAWING_MODES.indexOf(this.state.mode) > -1) {\n      controls.push(this._renderBooleanOperationControls());\n    }\n    if (this.state.mode === 'drawLineString') {\n      controls.push(this._renderDrawLineStringModeControls());\n    }\n    if (this.state.mode === 'modify') {\n      controls.push(this._renderModifyModeControls());\n    }\n    if (this.state.mode === 'split') {\n      controls.push(this._renderSplitModeControls());\n    }\n    if (this.state.mode === 'translate') {\n      controls.push(this._renderSnappingControls());\n    }\n\n    return controls;\n  }\n\n  _renderToolBox() {\n    return (\n      <div style={ToolboxStyles.toolbox}>\n        {ALL_MODES.map(category => (\n          <ToolboxRowWrapping key={category.category}>\n            <div style={{ paddingRight: '4px' }}>{category.category} Modes</div>\n            {category.modes.map(mode => (\n              <button\n                key={mode}\n                style={{\n                  margin: '2px',\n                  // padding: '2px 6px',\n                  backgroundColor: this.state.mode === mode ? '#a0cde8' : ''\n                }}\n                onClick={() => {\n                  this.setState({ mode, modeConfig: {}, selectionTool: null });\n                }}\n              >\n                {mode}\n              </button>\n            ))}\n          </ToolboxRowWrapping>\n        ))}\n        {this._renderModeConfigControls()}\n        <ToolboxDivider />\n        {this.state.showGeoJson && (\n          <React.Fragment>\n            <ToolboxLabel>\n              GeoJSON{' '}\n              <button onClick={() => this.setState({ showGeoJson: !this.state.showGeoJson })}>\n                hide &#9650;\n              </button>\n            </ToolboxLabel>\n            <ToolboxControl>\n              <textarea\n                id=\"geo-json-text\"\n                rows={5}\n                style={{ width: '100%' }}\n                value={JSON.stringify(this.state.testFeatures)}\n                onChange={event => this.setState({ testFeatures: JSON.parse(event.target.value) })}\n              />\n            </ToolboxControl>\n          </React.Fragment>\n        )}\n        {!this.state.showGeoJson && (\n          <React.Fragment>\n            <ToolboxLabel>\n              GeoJSON{' '}\n              <button onClick={() => this.setState({ showGeoJson: !this.state.showGeoJson })}>\n                show &#9660;\n              </button>\n            </ToolboxLabel>\n          </React.Fragment>\n        )}\n        <ToolboxDivider />\n        <ToolboxRow>\n          <ToolboxLabel>Load sample data</ToolboxLabel>\n          <ToolboxControl>\n            <button onClick={() => this._loadSample('mixed')}>Mixed</button>\n            <button onClick={() => this._loadSample('complex')}>Complex</button>\n            <button onClick={() => this._loadSample('blank')}>Blank</button>\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxLabel>Use Icons</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'icon'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'icon' ? 'point' : 'icon'\n                })\n              }\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxLabel>Use ElevatedEditHandleLayer</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'elevated'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'elevated' ? 'point' : 'elevated'\n                })\n              }\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxLabel>Select Features</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"button\"\n              value=\"Clear\"\n              onClick={() =>\n                this.setState({ selectedFeatureIndexes: [], selectionTool: SELECTION_TYPE.NONE })\n              }\n            />\n            <input\n              type=\"button\"\n              value=\"Rect\"\n              onClick={() =>\n                this.setState({ mode: 'view', selectionTool: SELECTION_TYPE.RECTANGLE })\n              }\n            />\n            <input\n              type=\"button\"\n              value=\"Lasso\"\n              onClick={() => this.setState({ mode: 'view', selectionTool: SELECTION_TYPE.POLYGON })}\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n        <ToolboxRowWrapping>{this._renderSelectFeatureCheckboxes()}</ToolboxRowWrapping>\n      </div>\n    );\n  }\n\n  renderStaticMap(viewport: Object) {\n    return <StaticMap {...viewport} />;\n  }\n\n  customizeLayers(layers: Object[]) {}\n\n  render() {\n    const { testFeatures, selectedFeatureIndexes, mode } = this.state;\n    let { modeConfig } = this.state;\n\n    const viewport = {\n      ...this.state.viewport,\n      height: window.innerHeight,\n      width: window.innerWidth\n    };\n\n    if (mode === 'elevation') {\n      modeConfig = {\n        calculateElevationChange: opts =>\n          ElevationHandler.calculateElevationChangeWithViewport(viewport, opts)\n      };\n    } else if (mode === 'translate' && modeConfig && modeConfig.enableSnapping) {\n      // Snapping can be accomplished to features that aren't rendered in the same layer\n      modeConfig = {\n        ...modeConfig,\n        additionalSnapTargets: [\n          {\n            type: 'Feature',\n            properties: {},\n            geometry: {\n              type: 'Polygon',\n              coordinates: [\n                [\n                  [-122.52235, 37.734008],\n                  [-122.52217, 37.712706],\n                  [-122.49436, 37.711979],\n                  [-122.49725, 37.734306],\n                  [-122.52235, 37.734008]\n                ]\n              ]\n            }\n          }\n        ]\n      };\n    }\n\n    const editableGeoJsonLayer = new EditableGeoJsonLayerImpl({\n      id: 'geojson',\n      data: testFeatures,\n      selectedFeatureIndexes,\n      modeHandlers,\n      mode,\n      modeConfig,\n      autoHighlight: false,\n\n      // Editing callbacks\n      onEdit: ({ updatedData, editType, featureIndexes, editContext }) => {\n        let updatedSelectedFeatureIndexes = this.state.selectedFeatureIndexes;\n        if (\n          !['movePosition', 'extruding', 'rotating', 'translating', 'scaling'].includes(editType)\n        ) {\n          // Don't log edits that happen as the pointer moves since they're really chatty\n          // eslint-disable-next-line\n          console.log('onEdit', editType, editContext);\n        }\n        if (editType === 'removePosition' && !this.state.pointsRemovable) {\n          // This is a simple example of custom handling of edits\n          // reject the edit\n          return;\n        }\n        if (editType === 'addFeature' && mode !== 'duplicate') {\n          // TODO: once we refactor EditableGeoJsonLayer to use new EditMode interface, this check can go away\n          featureIndexes = featureIndexes || editContext.featureIndexes;\n          // Add the new feature to the selection\n          updatedSelectedFeatureIndexes = [...this.state.selectedFeatureIndexes, ...featureIndexes];\n        }\n        this.setState({\n          testFeatures: updatedData,\n          selectedFeatureIndexes: updatedSelectedFeatureIndexes\n        });\n      },\n\n      // test using icons for edit handles\n      editHandleType:\n        this.state.editHandleType === 'elevated'\n          ? ElevatedEditHandleLayer\n          : this.state.editHandleType,\n      editHandleIconAtlas: iconSheet,\n      editHandleIconMapping: {\n        intermediate: {\n          x: 0,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        },\n        existing: {\n          x: 58,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        }\n      },\n      getEditHandleIcon: d => d.type,\n      getEditHandleIconSize: 40,\n      getEditHandleIconColor: getEditHandleColor,\n\n      // Specify the same GeoJsonLayer props\n      lineWidthMinPixels: 2,\n      pointRadiusMinPixels: 5,\n      getLineDashArray: () => [0, 0],\n\n      // Accessors receive an isSelected argument\n      getFillColor: (feature, isSelected) => {\n        return isSelected ? [0x20, 0x40, 0x90, 0x80] : [0x20, 0x20, 0x20, 0x30];\n      },\n      getLineColor: (feature, isSelected) => {\n        return isSelected ? [0x00, 0x20, 0x90, 0xff] : [0x20, 0x20, 0x20, 0xff];\n      },\n\n      // Can customize editing points props\n      getEditHandlePointColor: getEditHandleColor,\n      editHandlePointRadiusScale: 2,\n\n      // customize tentative feature style\n      getTentativeLineDashArray: () => [7, 4],\n      getTentativeLineColor: () => [0x8f, 0x8f, 0x8f, 0xff],\n\n      parameters: {\n        depthTest: true,\n        depthMask: false,\n\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA]\n      }\n    });\n\n    const layers = [editableGeoJsonLayer];\n\n    if (this.state.selectionTool) {\n      layers.push(\n        new SelectionLayer({\n          id: 'selection',\n          selectionType: this.state.selectionTool,\n          onSelect: ({ pickingInfos }) => {\n            this.setState({ selectedFeatureIndexes: pickingInfos.map(pi => pi.index) });\n          },\n          layerIds: ['geojson'],\n\n          getTentativeFillColor: () => [255, 0, 255, 100],\n          getTentativeLineColor: () => [0, 0, 255, 255],\n          getTentativeLineDashArray: () => [0, 0],\n          lineWidthMinPixels: 3\n        })\n      );\n    }\n\n    this.customizeLayers(layers);\n\n    return (\n      <div style={styles.mapContainer}>\n        <link href=\"https://api.mapbox.com/mapbox-gl-js/v0.44.0/mapbox-gl.css\" rel=\"stylesheet\" />\n        <DeckGL\n          viewState={viewport}\n          getCursor={editableGeoJsonLayer.getCursor.bind(editableGeoJsonLayer)}\n          layers={layers}\n          views={\n            new MapView({\n              id: 'basemap',\n              controller: {\n                type: MapController,\n                doubleClickZoom: this.state.mode === 'view' && !this.state.selectionTool\n              }\n            })\n          }\n          onClick={this._onLayerClick}\n          onViewStateChange={({ viewState }) => this.setState({ viewport: viewState })}\n        >\n          {this.renderStaticMap(viewport)}\n        </DeckGL>\n        {this._renderToolBox()}\n      </div>\n    );\n  }\n}\n","import React, { Component } from 'react';\nimport styled from 'styled-components';\n\nimport Example from '../../../examples/deck/example';\nimport '../styles/editor.css';\n\nconst Container = styled.div`\n  width: 100%;\n  height: calc(100vh - 4rem);\n  margin-top: 4rem;\n`;\n\nexport default class GeoJsonEditor extends Component {\n  render() {\n    return (\n      <Container id=\"geoJsonEditorContainer\">\n        <Example />\n      </Container>\n    );\n  }\n}\n","module.exports = \"data:image/png;base64,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\""],"sourceRoot":""}