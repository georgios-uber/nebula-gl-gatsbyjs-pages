{"componentChunkName":"component---node-modules-gatsby-theme-ocular-src-templates-search-jsx","path":"/search","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"data":[{"excerpt":"Overview nebula.gl provides editable and interactive map overlay layers, built using the power of deck.gl. Design Goals nebula.gl aspires to…","rawMarkdownBody":"# Overview\n\n[nebula.gl](https://nebula.gl) provides editable and interactive map overlay layers, built using the power of [deck.gl](https://uber.github.io/deck.gl).\n\n## Design Goals\n\nnebula.gl aspires to be an ultra-performant, fully 3D-enabled GeoJSON editing system primarily focused on geospatial editing use cases.\n\n* Maximal rendering and editing performance, without need for complex application logic (such as splitting data into subgroups etc).\n* Target performance: Editing at 60fps (e.g. dragging sub objects) in GeoJSON payloads with 100K features (points, lines or polygons).\n* Handles GeoJSON corner cases, e.g. automatically changing object types from `Polygon` to `MultiPolygon` when addition polygons are added.\n* Fully 3D enabled (Can e.g. use WebGL z-buffer so that lines being rendered are properly occluded by other geometry).\n* Seamless integration with deck.gl and all geospatial deck.gl layers, allowing for GeoJSON editing to be interleaved with rich 3D visualizations.\n* Handle all aspects of event handling, including touch screen support.\n\n## Why nebula.gl?\n\nYou should strongly consider nebula.gl:\n\n* You want a full-featured, ultra-high-performance editing solution for GeoJson.\n* You are already using e.g. `deck.gl` or `react-map-gl`.\n\nYou may want to look at alternatives if:\n\n* If you have very simple editing requirements (just a simple polygon etc)\n* If you don't want to use `deck.gl` in your project.\n\nIf nebula.gl is more than what you need (e.g. in terms of bundle size), and you may want to look at other solutions, e.g. the simple polygon editor overlay being developed in react-map-gl.\n\nThat said, if you are already using `deck.gl` the additional overhead of nebula.gl is small, and the seamless integration with deck.gl should be valuable.\n\n## Quick Overview of the nebula.gl API\n\n### EditableGeoJsonLayer\n\n[EditableGeoJsonLayer](/docs/api-reference/layers/editable-geojson-layer) is implemented as a [deck.gl](https://deck.gl) layer. It provides the ability to view and edit multiple types of geometry formatted as [GeoJSON](https://tools.ietf.org/html/rfc7946) (an open standard format for geometry) including polygons, lines, and points.\n\n#### Callbacks\n\nWhen there is the ability to edit, callbacks are provided to inform you of edits.\n\n### Overlays\n\nThe overlay layers are based on HTML and rendered by the browser. You can use them\nfor complicated objects that follow map points. They are less performant\nbut more flexible. For more details see [Using Html Overlays](/docs/api-reference/overlays/html-overlay)\n","slug":"docs","title":"Overview"},{"excerpt":"FAQ Will this replace deck.gl? No. Should I use layers or overlays? Use layers if you have thousands of data points and rendering is simple…","rawMarkdownBody":"# FAQ\n\n\n#### Will this replace `deck.gl`?\n\nNo.\n\n\n#### Should I use `layers` or `overlays`?\n\nUse `layers` if you have thousands of data points and rendering is simple.\nUse `overlays` if you have a few items but want to use HTML to render them.\n\n\n","slug":"docs/faq","title":"FAQ"},{"excerpt":"Roadmap v1.0 Maximize performance in all use cases: target is 100k objects being edited at 60fps 2D editing capabilities Basic elevation…","rawMarkdownBody":"# Roadmap\n\n\n## v1.0\n\n- Maximize performance in all use cases: target is 100k objects being edited at 60fps\n- 2D editing capabilities\n- Basic elevation support\n- Documentation\n- Examples\n- Unit test coverage and build status on homepage\n\n\n## v2.0\n\n- 3D Editing Capabilities with elevation editing\n- Curved lines and polygons ([Cubic Hermite Spline](https://en.wikipedia.org/wiki/Cubic_Hermite_spline))\n- Full mobile support with touch and multi touch\n- Automated performance evaluation as part of unit tests\n","slug":"docs/roadmap","title":"Roadmap"},{"excerpt":"Basic usage Imports Inside your React component Initialize Render See Also EditableGeoJsonLayer Using deck.gl with React Using deck.gl with…","rawMarkdownBody":"# Basic usage\n\n## Imports\n```jsx\nimport React from 'react';\nimport DeckGL from '@deck.gl/react';\nimport { EditableGeoJsonLayer } from '@nebula.gl/layers';\nimport { StaticMap } from 'react-map-gl';\n```\n\n## Inside your React component\n\n### Initialize\n\n```jsx\nconstructor(props) {\n  super(props);\n  this.state = {\n    geojson: {\n      type: 'FeatureCollection',\n      features: []\n    }\n  };\n}\n```\n\n### Render\n```jsx\nrender() {\n  const editableLayer = new EditableGeoJsonLayer({\n    id: 'geojson',\n    data: this.state.geojson,\n    mode: 'drawPoint',\n    onEdit: ({ updatedData }) => {\n      this.setState({ geojson: updatedData });\n    }\n  });\n  return (\n    <DeckGL\n      initialViewState={initialViewState}\n      controller={true}\n      layers={[editableLayer]}\n    >\n      <StaticMap mapboxApiAccessToken={MAPBOX_ACCESS_TOKEN} />\n    </DeckGL>\n  );\n}\n```\n\n## See Also\n- [EditableGeoJsonLayer](/docs/api-reference/layers/editable-geojson-layer)\n- [Using deck.gl with React](https://deck.gl/#/documentation/getting-started/using-with-react)\n- [Using deck.gl with a Base Map](https://deck.gl/#/documentation/getting-started/using-with-base-map)\n","slug":"docs/get-started/basic-usage","title":"Basic usage"},{"excerpt":"Using Html Overlays HTML overlays are very easy to use and take advantage of react's architecture. Example Checkout the Unesco World…","rawMarkdownBody":"# Using Html Overlays\n\nHTML overlays are very easy to use and take advantage of [react's architecture](https://reactjs.org/docs/).\n\n\n```jsx\n<HtmlOverlay>\n  <HtmlOverlayItem coordinates={coordinates}>{title}</HtmlOverlayItem>\n</HtmlOverlay>\n```\n\n\n## Example\nCheckout the [Unesco World Heritage](/docs/interactive-examples/world-heritage) example.\n\n## See Also\n- [Html Overlay](/docs/api-reference/overlays/html-overlay)\n- [Html Overlay Item](/docs/api-reference/overlays/html-overlay-item)\n","slug":"docs/get-started/html-overlays","title":"Using Html Overlays"},{"excerpt":"Installation nebula.gl will automatically install a compatible version of deck.gl.","rawMarkdownBody":"# Installation\n\n\n```bash\nyarn add \"@nebula.gl/layers\"\nyarn add \"@nebula.gl/overlays\"\n```\n\nnebula.gl will automatically install a compatible version of deck.gl.\n","slug":"docs/get-started/installing","title":"Installation"},{"excerpt":"Unesco World Heritage Wait for list to load. You can observe the automatic clustering.\nThere is a more advanced example inside examples…","rawMarkdownBody":"# Unesco World Heritage\n\nWait for list to load. You can observe the automatic clustering.\nThere is a more advanced example inside `examples/overlays`.\n\n\n[codesandbox](embedded-codesandbox://world-heritage)\n\n\n### Source\nhttps://github.com/uber/nebula.gl/blob/master/docs/examples/examples.js\n","slug":"docs/interactive-examples/world-heritage","title":"Unesco World Heritage"},{"excerpt":"EditableGeoJsonLayer The Editable GeoJSON layer accepts a GeoJSON FeatureCollection and renders the features as editable polygons, lines…","rawMarkdownBody":"# EditableGeoJsonLayer\n\nThe Editable GeoJSON layer accepts a [GeoJSON](http://geojson.org) `FeatureCollection` and renders the features as editable polygons, lines, and points.\n\n```js\nimport DeckGL from 'deck.gl';\nimport { EditableGeoJsonLayer, DrawPolygonMode } from 'nebula.gl';\n\nconst myFeatureCollection = {\n  type: 'FeatureCollection',\n  features: [\n    /* insert features here */\n  ]\n};\n\nconst selectedFeatureIndexes = [];\n\nclass App extends React.Component {\n  state = {\n    data: myFeatureCollection\n  };\n\n  render() {\n    const layer = new EditableGeoJsonLayer({\n      id: 'geojson-layer',\n      data: this.state.data,\n      mode: DrawPolygonMode,\n      selectedFeatureIndexes,\n\n      onEdit: ({ updatedData }) => {\n        this.setState({\n          data: updatedData,\n        });\n      }\n    });\n\n    return <DeckGL {...this.props.viewport} layers={[layer]} />;\n  }\n}\n```\n\n## Properties\n\nInherits all [deck.gl's Base Layer](https://uber.github.io/deck.gl/#/documentation/deckgl-api-reference/layers/layer) properties.\n\n#### `data` (Object, optional)\n\n* Default: `null`\n\nA [GeoJSON](http://geojson.org) `FeatureCollection` object. The following types of geometry are supported:\n\n* `Point`\n* `LineString`\n* `Polygon`\n* `MultiPoint`\n* `MultiLineString`\n* `MultiPolygon`\n* `GeometryCollection` is not supported.\n\n_Note: passing a single `Feature` is not supported. However, you can pass a `FeatureCollection` containing a single `Feature` and pass `selectedFeatureIndexes: [0]` to achieve the same result._\n\n#### `mode` (Function|Object, optional)\n\n* Default: `DrawPolygonMode`\n\nThe `mode` property defines the mode used to handle user interaction events (e.g. pointer events) in order to accomplish edits. This can either be a constructor for an `EditMode` or an instance of `EditMode`.\n\nThere are a extensive number of modes that come out-of-the-box with nebula.gl. See [modes overview](/docs/api-reference/modes/overview.md).\n\n#### `modeConfig` (Object, optional)\n\n* Default: `null`\n\nAn arbitrary object used to further configure the current mode.\n\nSnapping-related `modeConfig` properties:\n\n* `enableSnapping` (Boolean, optional) - Enables snapping for modes that support snapping such as translate mode.\n* `additionalSnapTargets` (Object[], optional) - An array of GeoJSON Features that can be snapped to. This property only needs to be specified if you want to snap to features in other deck.gl layers. All features in this `EditableGeoJsonLayer` will be snap targets.\n\n#### `selectedFeatureIndexes` (Array, optional)\n\n* Default: `[]`\n\nThe `selectedFeatureIndexes` property distinguishes which features to treat as selected.\n\n* Features are identified by their index in the collection.\n\n* Selection of a feature causes style accessors to render a different style, defined in function such as `getLineColor` and `getFillColor`.\n\n* Selected features in mode `modify` will render edit handles. Only one feature may be selected while in mode `drawLineString` or `drawPolygon` to draw a feature.\n\n_Note: make sure to pass in the same array instance on each render if you are not changing selection. Otherwise, nebula.gl may clear state on every render (e.g. may clear a drawing in progress if the viewport changes)._\n\n#### `onEdit` (Function, optional)\n\nThe `onEdit` event is the core event provided by this layer and must be handled in order to accept and render edits. The `event` argument includes the following properties:\n\n* `updatedData` (Object): A new `FeatureCollection` with the edit applied.\n\n  * To accept the edit as is, supply this object into the `data` prop on the next render cycle (e.g. by calling React's `setState` function)\n\n  * To reject the edit, do nothing\n\n  * You may also supply a modified version of this object into the `data` prop on the next render cycle (e.g. if you have your own snapping logic).\n\n* `editType` (String): The type of edit requested. One of:\n\n  * `movePosition`: A position was moved.\n\n  * `addPosition`: A position was added (either at the beginning, middle, or end of a feature's coordinates).\n\n  * `removePosition`: A position was removed. Note: it may result in multiple positions being removed in order to maintain valid GeoJSON (e.g. removing a point from a triangular hole will remove the hole entirely).\n\n  * `addFeature`: A new feature was added. Its index is reflected in `featureIndexes`\n\n  * `finishMovePosition`: A position finished moving (e.g. user finished dragging).\n\n  * `scaling`: A feature is being scaled.\n\n  * `scaled`: A feature finished scaling (increase/decrease) (e.g. user finished dragging).\n\n  * `rotating`: A feature is being rotated.\n\n  * `rotated`: A feature finished rotating (e.g. user finished dragging).\n\n  * `translating`: A feature is being translated.\n\n  * `translated`: A feature finished translating (e.g. user finished dragging).\n\n  * `startExtruding`: An edge started extruding (e.g. user started dragging).\n\n  * `extruding`: An edge is extruding.\n\n  * `extruded`: An edge finished extruding (e.g. user finished dragging).\n\n  * `split`: A feature finished splitting.\n\n* `featureIndexes` (Array&lt;number&gt;): The indexes of the edited/added features.\n\n* `editContext` (Object): `null` or an object containing additional context about the edit. This is populated by the active mode, see [modes overview](../modes/overview.md).\n\n##### Example\n\nConsider the user removed the third position from a `Polygon`'s first ring, and that `Polygon` was the fourth feature in the `FeatureCollection`. The `event` argument would look like:\n\n```js\n{\n  updatedData: {...},\n  editType: 'removePosition',\n  featureIndexes: [3],\n  editContext: {\n    positionIndexes: [1, 2],\n    position: null\n  }\n}\n```\n\n#### `pickable` (Boolean, optional)\n\n* Default: `true`\n\nDefaulted to `true` for interactivity.\n\n#### `pickingRadius` (Number, optional)\n\n* Default: `10`\n\nNumber of pixels around the mouse cursor used for picking. This value determines, for example, what feature is considered to be clicked and what is close enough to be snapped to.\n\n#### `pickingDepth` (Number, optional)\n\n* Default: `5`\n\nNumber of layers of overlapping features that will be picked. Useful in cases where features overlap.\n\n### GeoJsonLayer Options\n\nThe following properties from [GeoJsonLayer](https://uber.github.io/deck.gl/#/documentation/deckgl-api-reference/layers/geojson-layer) are supported and function the same:\n\n* `filled`\n* `stroked`\n* `lineWidthScale`\n* `lineWidthMinPixels`\n* `lineWidthMaxPixels`\n* `lineWidthUnits`\n* `lineJointRounded`\n* `lineMiterLimit`\n* `pointRadiusScale`\n* `pointRadiusMinPixels`\n* `pointRadiusMaxPixels`\n* `lineDashJustified`\n* `fp64`\n\nThe following accessors function the same, but can accept additional arguments:\n\n* `getLineColor`\n* `getFillColor`\n* `getRadius`\n* `getLineWidth`\n* `getLineDashArray`\n\nThe additional arguments (in order) are:\n\n* `feature`: the given feature\n* `isSelected`: indicates if the given feature is a selected feature\n* `mode`: the current value of the `mode` prop\n\n### Tentative Features\n\nWhile creating a new feature in any of the `draw` modes, portion of a feature which has not been \"committed\" yet can hold its own props. For example, in `drawLineString` mode, the tentative feature is the last line segment moving under the mouse. For polygons and ellipses, this would be the whole feature during drawing. Define the properties with the following accessors:\n\n* `getTentativeLineColor`\n* `getTentativeFillColor`\n* `getTentativeLineWidth`\n* `getTentativeLineDashArray`\n\nThe following accessors default to the same values as the existing feature accessors above. The arguments in order:\n\n* `feature`: the segment/polygon that represents the tentative feature\n* `mode`: the current value of the `mode` prop\n\n### Edit Handles\n\nEdit handles are the points rendered on a feature to indicate interactive capabilities (e.g. vertices that can be moved).\n\n* `type` (String): either `existing` for existing positions or `intermediate` for positions half way between two other positions.\n\n#### `editHandleType` (String, optional)\n\n* Default: `point`\n\n* `point`: Edit handles endered as points\n\n* `icons`: Edit handles rendered as provided icons\n\nEdit handle objects can be represented by either points or icons. `editHandlePoint...` are proxies for the [`ScatterplotLayer`](https://github.com/uber/deck.gl/blob/master/docs/layers/scatterplot-layer.md#properties) props, and `editHandleIcon...` are proxies for the [`IconLayer`](https://github.com/uber/deck.gl/blob/master/docs/layers/icon-layer.md#properties) props.\n\n#### `editHandleParameters` (Object, optional)\n\n* Default: `{}`\n\n* Set luma.gl parameters for handles (eg. depthTest, blend)\n\n#### `editHandlePointRadiusScale` (Number, optional)\n\n* Default: `1`\n\n#### `editHandlePointOutline` (Boolean, optional)\n\n* Default: `true`\n\n#### `editHandlePointStrokeWidth` (Number, optional)\n\n* Default: `2`\n\n#### `editHandlePointRadiusMinPixels` (Number, optional)\n\n* Default: `4`\n\n#### `editHandlePointRadiusMaxPixels` (Number, optional)\n\n* Default: `Number.MAX_SAFE_INTEGER`\n\n#### `getEditHandlePointColor` (Function | Array, optional)\n\n* Default: `handle => handle.type === 'existing' ? [0xc0, 0x0, 0x0, 0xff] : [0x0, 0x0, 0x0, 0x80]`\n\n#### `getEditHandlePointRadius` (Function | Number, optional)\n\n* Default: `handle => (handle.type === 'existing' ? 5 : 3)`\n\n#### `editHandleIconAtlas` (Texture2D | String, optional)\n\n* Default: `null`\n\nAtlas image url or texture.\n\n#### `editHandleIconMapping` (Object | String, optional)\n\n* Default: `null`\n\nIcon names mapped to icon definitions. See [`Icon Layer`](https://github.com/uber/deck.gl/blob/master/docs/layers/icon-layer.md#iconmapping-object--string-required).\n\n#### `editHandleIconSizeScale` (Number | optional)\n\n* Default: `null`\n\nEdit handle icon size multiplier.\n\n#### `getEditHandleIcon` (Function, optional)\n\n* Default: `handle => handle.type`\n\nMethod called to retrieve the icon name of each edit handle, returns string.\n\n#### `getEditHandleIconSize` (Function | Number, optional)\n\n* Default: `10`\n\nThe height of each edit handle, in pixels.\n\n#### `getEditHandleIconColor` (Function | Array, optional)\n\n* Default: `handle => handle.type === 'existing' ? [0xc0, 0x0, 0x0, 0xff] : [0x0, 0x0, 0x0, 0x80]`\n\n#### `getEditHandleIconAngle` (Function | Number, optional)\n\n* Default: `0`\n\nThe rotating angle of each object, in degrees.\n\n##### `billboard` (Boolean, optional)\n\n* Default: `true`\n\nPassed to `GeoJsonLayer`. If `true`, extrude the path in screen space.\nUseful for showing features with altitude.\n","slug":"docs/api-reference/layers/editable-geojson-layer","title":"EditableGeoJsonLayer"},{"excerpt":"MeshLayer The Mesh Layer renders a number of arbitrary geometries. For example, a fleet of 3d cars each with a position and an orientation…","rawMarkdownBody":"# MeshLayer\n\nThe Mesh Layer renders a number of arbitrary geometries. For example, a fleet of 3d cars each with a position and an orientation over the map.\n\n```js\nimport DeckGL from 'deck.gl';\nimport {MeshLayer} from '@deck.gl/experimental-layers';\nimport {CubeGeometry} from 'luma.gl'\n\nconst App = ({data, viewport}) => {\n\n  /**\n   * Data format:\n   * [\n   *   {\n   *     position: [-122.45, 37.7],\n   *     angle: 0,\n   *     color: [255, 0, 0]\n   *   },\n   *   {\n   *     position: [-122.46, 37.73],\n   *     angle: 90,\n   *     color: [0, 255, 0]\n   *   },\n   *   ...\n   * ]\n   */\n  const layer = new MeshLayer({\n    id: 'mesh-layer',\n    data,\n    sizeScale: 100,\n    texture: 'texture.png',\n    mesh: new CubeGeometry()\n  });\n\n  return (<DeckGL {...viewport} layers={[layer]} />);\n};\n```\n\n## Properties\n\n##### `mesh` (Geometry|Object)\n\nThe geometry to render for each data object.\nCan be a luma.gl [Geometry](http://uber.github.io/luma.gl/#/documentation/api-reference/geometry) instance, or an object of attributes.\n\nThe following attributes are expected:\n- `positions` (Float32Array) - 3d vertex offset from the object center, in meters\n- `normals` (Float32Array) - 3d nomals\n- `texCoords` (Float32Array) - 2d texture coordinates\n\n\n##### `texture` (Texture2D|Image|String, optional)\n\n- Default `null`.\n\nThe texture of the geometries.\nCan be either a luma.gl [Texture2D](http://uber.github.io/luma.gl/#/documentation/api-reference/texture-2) instance, an HTMLImageElement, or a url string to the texture image.\n\nIf `texture` is supplied, texture is used to render the geometries. Otherwise, object color obtained via the `getColor` accessor is used.\n\n\n##### `sizeScale` (Number, optional)\n\n- Default `1`.\n\nMultiplier to scale each geometry by.\n\n\n##### `getPosition` (Function, optional)\n\n- Default: `object => object.position`\n\nThis accessor returns the center position corresponding to an object in the `data` stream.\n\n\n##### `getYaw` (Function, optional)\n\n- Default: `object => object.yaw || object.angle || 0`\n\nThe yaw (heading) in degrees of each object.\n\n\n##### `getPitch` (Function, optional)\n\n- Default: `object => object.pitch || 0`\n\nThe pitch (elevation) in degrees of each object.\n\n\n##### `getRoll` (Function, optional)\n\n- Default: `object => object.roll || 0`\n\nThe roll (bank) in degrees of each object.\n\nSee [Euler angles](https://en.wikipedia.org/wiki/Euler_angles).\n\n##### `getScale` (Function, optional)\n\n- Default: `object => object.scale || [1, 1, 1]`\n\nScaling factor on the mesh along each axis.\n\n##### `getTranslation` (Function, optional)\n\n- Default: `object => object.translation || [0, 0, 0]`\n\nTranslation of the mesh along each axis. Offset from the center position given by `getPosition`\n\n##### `getMatrix` (Function, optional)\n\n- Default: `object => null`\n\nExplicitly define a 4x4 column-major model matrix for the mesh. If provided, will override\n`getYaw`, `getPitch`, `getRoll`, `getScale`, `getTranslation`.\n\n\n##### `getColor` (Function|Array, optional)\n\n- Default: `[0, 0, 0, 255]`\n\nThe color of each object. Only used if `texture` is empty.\n\n\n##### `fp64` (Boolean, optional)\n\n- Default: `false`\n\nWhether the layer should be rendered in high-precision 64-bit mode\n\n##### `lightSettings` (Object, optional)\n\n**TO BE REPLACED**\n\nWith `@deck.gl/mesh-layers`\n\n","slug":"docs/api-reference/layers/mesh-layer","title":"MeshLayer"},{"excerpt":"Outline (Shader Module) The outline module is useful when you are rendering 2D elements in the same plane (on top of each other), but want…","rawMarkdownBody":"# Outline (Shader Module)\n\nThe `outline` module is useful when you are rendering 2D elements in the same plane (on top of each other), but want to show some kind of outline or shadow to indicate which element is logically on top.\n\nImplementation note: This module works by rendering your graphics into a sample \"outline\" shadow map, and then darkens the color on pixels in your graphics when they are drawn close to another object with a higher \"logical z order\", giving a shadow outline effect.\n\n\n## Usage\n\nYour vertex shader might look like:\n```\nattribute vec3 position;\nattribute vec4 lineColor;\nattribute float zLevel;\n\nvarying vec4 vColor;\n\nvoid main() {\n  ...\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n  vColor = lineColor;\n\n  ...\n\n  // Store info needed to render outline shadows\n  outline_setZLevel(zLevel);\n  outline_setUV(gl_Position);\n}\n```\n\nAnd in the fragment shader:\n```\nvarying vec4 vColor;\n\nvoid main() {\n  gl_FragColor = vColor;\n\n  ...\n\n  // Render outline shadows\n  gl_FragColor = outline_filterColor(gl_FragColor);\n\n  ...\n}\n```\n\n## getUniforms\n\n`getUniforms({outlineRender, outlineShadowMap})`\n\n* `outlineRender` (Boolean, `false`) - set to `true` during the \"outline map\" rendering pass (i.e. specifies whether to render into or from the shadowmap).\n* `outlineShadowmap` (`Texture`, required) -\n","slug":"docs/api-reference/layers/outline","title":"Outline (Shader Module)"},{"excerpt":"PathMarkerLayer Create small markers along a path (defaults to arrows showing \"direction\").","rawMarkdownBody":"# PathMarkerLayer\n\nCreate small markers along a path (defaults to arrows showing \"direction\").\n","slug":"docs/api-reference/layers/path-marker-layer","title":"PathMarkerLayer"},{"excerpt":"SelectionLayer This layer can be used to select deck.gl objects using mouse drawing. Properties Inherits all deck.gl's Base Layer properties…","rawMarkdownBody":"# SelectionLayer\n\nThis layer can be used to select deck.gl objects using mouse drawing.\n\n```js\nlayers.push(\n  new SelectionLayer({\n    id: 'selection',\n    selectionType: this.state.selectionTool,\n    onSelect: ({ pickingInfos }) => {\n      this.setState({ selectedFeatureIndexes: pickingInfos.map(pi => pi.index) });\n    },\n    layerIds: ['geojson'],\n\n    getTentativeFillColor: () => [255, 0, 255, 100],\n    getTentativeLineColor: () => [0, 0, 255, 255],\n    getTentativeLineDashArray: () => [0, 0],\n    lineWidthMinPixels: 3\n  })\n);\n```\n\n\n## Properties\n\nInherits all [deck.gl's Base Layer](https://uber.github.io/deck.gl/#/documentation/deckgl-api-reference/layers/layer) properties.\n\nAlso inherites **some** EditableGeoJsonLayer properties.\n\n> Note: do not pass a data property.\n\n#### `selectionType` (String, required)\n\n* Default: `null`\n\nSELECTION_TYPE.RECTANGLE or SELECTION_TYPE.POLYGON\n\n#### `onSelect` (Function, required)\n\nCalled when selection is completed.\n\n#### `layerIds` (String[], required)\n\nArray of layer ids where we will search.\n\n","slug":"docs/api-reference/layers/selection-layer","title":"SelectionLayer"},{"excerpt":"Editing Modes EditModes provide a way of handling user interactions in order to manipulate GeoJSON features and geometries. The following…","rawMarkdownBody":"# Editing Modes\n\n`EditMode`s provide a way of handling user interactions in order to manipulate GeoJSON features and geometries.\n\nThe following are the built-in `EditMode`s provided by nebula.gl:\n\n## [ViewMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/view-mode.js)\n\nNo edits are possible, but selection is still possible.\n\n## [ModifyMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/modify-mode.js)\n\nUser can move existing points, add intermediate points along lines, and remove points.\n\n### Edit Context\n\n`editContext` argument to the `onEdit` callback contains the following properties:\n\n* `positionIndexes` (Array): An array of numbers representing the indexes of the edited position within the feature's `coordinates` array\n\n* `position` (Array): An array containing the ground coordinates (i.e. [lng, lat]) of the edited position\n\n## [ExtrudeMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/extrude-mode.js)\n\nUser can move edge. Click and drag from anywhere between 2 points in edge.\n\n## [ScaleMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/scale-mode.js)\n\nUser can scale a feature about its centroid by clicking and dragging (inward or outward) the selected geometry. This mode supports multiple selections.\n\n## [RotateMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/rotate-mode.js)\n\nUser can rotate a feature about its centroid by clicking and dragging the selected geometry. This mode supports multiple selections.\n\n## [TranslateMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/translate-mode.js)\n\nThe user can move a feature by selecting one or more features and dragging anywhere within the screen.\n_Additionally, the user can initiate snapping by clicking and dragging the selected feature's vertex handles. If the vertex handle is close enough to another feature's vertex, the two features will snap together._\n\n## [DuplicateMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/duplicate-mode.js)\n\nUser can duplicate and translate a feature by clicking selected feature and dragging anywhere on the screen.\nThis mode is extends TranslateMode. This mode supports multiple selections.\n\n## [DrawPointMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-point-mode.js)\n\nUser can draw a new `Point` feature by clicking where the point is to be.\n\n## [DrawLineStringMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-line-string-mode.js)\n\nUser can draw a new `LineString` feature by clicking positions to add.\n\n* If a `LineString` feature is selected, clicking will add a position to it.\n\n* If no feature is selected, a new `LineString` feature will be added. *Note*: you must select the new feature (via the `onEdit` callback) in order to start extending it.\n\n* If multiple features are selected, or a non-`LineString` is selected, the user will be prevented from drawing.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `drawAtFront` (optional):  `<boolean>`\n  * If `true`, will render the tentative feature at the \"beginning\" of the line, i.e. relative to the start of the coordinates array.\n\n### Edit Context\n\n`editContext` argument to the `onEdit` callback contains the following properties:\n\n* `positionIndexes` (Array): An array of numbers representing the indexes of the added position within the feature's `coordinates` array\n\n* `position` (Array): An array containing the ground coordinates (i.e. [lng, lat]) of the added position\n\n## [DrawPolygonMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-polygon-mode.js)\n\nUser can draw a new `Polygon` feature by clicking positions to add then closing the polygon (or double-clicking).\n\n### Edit Context\n\n`editContext` argument to the `onEdit` callback contains the following properties:\n\n* `positionIndexes` (Array): An array of numbers representing the indexes of the added position within the feature's `coordinates` array\n\n* `position` (Array): An array containing the ground coordinates (i.e. [lng, lat]) of the added position\n\n## [Draw90DegreePolygonMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-90degree-polygon-mode.js)\n\nUser can draw a new `Polygon` feature with 90 degree corners (right angle) by clicking positions to add then closing the polygon (or double-clicking). After clicking the 2 points, the draw mode guides/allows to have right angle polygon.\n\n## [DrawRectangleMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-rectangle-mode.js)\n\nUser can draw a new rectangular `Polygon` feature by clicking two opposing corners of the rectangle.\n\n## [DrawRectangleUsingThreePointsMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-rectangle-using-three-points-mode.js)\n\nUser can draw a new rectangular `Polygon` feature by clicking three corners of the rectangle.\n\n## [DrawCircleFromCenterMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-circle-from-center-mode.js)\n\nUser can draw a new circular `Polygon` feature by clicking the center then along the ring.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `steps` (optional):  `x <number>`\n  * If steps: `x` means the circle will be drawn using `x` number of points.\n\n## [DrawCircleByBoundingBoxMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-circle-by-bounding-box-mode.js)\n\nUser can draw a new circular `Polygon` feature by clicking the two corners of bounding box.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `steps` (optional):  `x <number>`\n  * If steps: `x` means the circle will be drawn using `x` number of points.\n\n## [DrawEllipseByBoundingBoxMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-ellipse-by-bounding-box-mode.js)\n\nUser can draw a new ellipse shape `Polygon` feature by clicking two corners of bounding box.\n\n## [DrawEllipseUsingThreePointsMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/draw-ellipse-using-three-points-mode.js)\n\nUser can draw a new ellipse shape `Polygon` feature by clicking center and two corners of the ellipse.\n\n## [SplitPolygonMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/split-polygon-mode.js)\n\nUser can split a polygon by drawing a new `LineString` feature on top of the polygon.\n\n* If the first and the last click is outside the polygon, it will split the polygon\n\n* If the clicked position is inside the polygon, it will not split the polygon\n\n## [MeasureDistanceMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/measure-distance-mode.js)\n\nUser can measure a distance between two points.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `turfOptions` (Object, optional)\n  * `options` object passed to turf's [distance](https://turfjs.org/docs/#distance) function\n  * Default: `undefined`\n\n* `formatTooltip` (Function, optional)\n  * Function to format tooltip text (argument is the numeric distance)\n  * Default: `(distance) => parseFloat(distance).toFixed(2) + units`\n\n* `measurementCallback` (Function, optional)\n  * Function to call as measurements are calculated\n  * Default: `undefined`\n\n## [ElevationMode](https://github.com/uber/nebula.gl/blob/master/modules/edit-modes/src/lib/elevation-mode.js)\n\nUser can move a point up and down.\n\n### ModeConfig\n\nThe following options can be provided in the `modeConfig` object:\n\n* `minElevation` (Number, optional)\n  * The minimum elevation to allow\n  * Default: `0`\n\n* `maxElevation` (Number, optional)\n  * The maximum elevation to allow\n  * Default: `20000`\n\n* `calculateElevationChange` (Function, optional)\n  * A function to use to calculate the elevation change in response to mouse movement\n  * Default: `10 * <vertical movement in pixels>`\n  * Configure to use movement based on viewport:\n\n```javascript\nif (mode === 'elevation') {\n  modeConfig.calculateElevationChange = (opts) =>\n    ElevationMode.calculateElevationChangeWithViewport(viewport, opts);\n}\n```\n\n## Boolean Operations\n\nFor all polygon drawing modes, the following options can be provided in the `modeConfig` object:\n\n* `booleanOperation` (optional):  `null|'union'|'difference'|'intersection'`\n  * If non-null, requires a single `Polygon` or `MultiPolygon` selection\n  * If `null`, the drawn `Polygon` is added as a new feature regardless of selection\n  * If `union`, the drawn `Polygon` is unioned with the selected geometry\n  * If `difference`, the drawn `Polygon` is subtracted from the selected geometry\n  * If `intersection`, the drawn `Polygon` is intersected with the selected geometry\n\n## Composite Mode\n\nUse `CompositeMode` to combine multiple modes.\n_Not all combinations are guaranteed to work._\n\n### Constructor\n\n`new CompositeMode(modes, options = {})`\n\n* `modes`: `Array<EditMode>` Modes you want to combine. **Order is very important.**\n* `options` (optional): Options to be added later.\n\n### Example\n\n```\nnew CompositeMode([new DrawLineStringMode(), new ModifyMode()])\n```\n","slug":"docs/api-reference/modes/overview","title":"Editing Modes"},{"excerpt":"HtmlClusterOverlay Use this class if you have HTML items that need to be displayed at specific geo coordinates on the map\nand cluster based…","rawMarkdownBody":"# HtmlClusterOverlay\n\nUse this class if you have HTML items that need to be displayed at specific geo coordinates on the map\nand cluster based on the zoom level.\n**You need to subclass this class**. Then use it as a `react component` inside `DeckGL`.\n\n\n## Example \nFor example code see [Unesco World Heritage](/docs/interactive-examples/world-heritage).\n\n\n## Methods to override\n### getAllObjects()\nOverride to provide an array of `Objects` that need clustering.\nIf the items have not changed please provide the same array to avoid\nregeneration of the cluster which causes performance issues.\n\n### getObjectCoordinates(object)\nOverride to provide coordinates for each object of getAllObjects().\nReturn array of two numbers.\n\n### renderObject(coordinates, object)\nOverride to return an `HtmlOverlayItem` for the single `object` at `coordinates`.\n\n### renderCluster(coordinates, clusterId, pointCount)\nOverride to return an HtmlOverlayItem for the `cluster` at `coordinates`.\n`pointCount` is the number of objects that are represented by that cluster.\nUse `getClusterObjects(clusterId)` to get cluster contents.\n\n\n\n## Methods (provided)\n\n### getClusterObjects(clusterId)\nReturns an array of objects.\n\n### getClusterOptions()\nOverride to return options used when instantiating the overlay and thus the \nunderlying [supercluster](https://www.npmjs.com/package/supercluster#options) object.\n","slug":"docs/api-reference/overlays/html-cluster-overlay","title":"HtmlClusterOverlay"},{"excerpt":"HtmlOverlayItem This is an HTML item that will be rendered inside\nHtmlOverlay or\nHtmlClusterOverlay. Props coordinates Array of two (or…","rawMarkdownBody":"# HtmlOverlayItem\n\nThis is an HTML item that will be rendered inside\n[HtmlOverlay](/docs/api-reference/overlays/html-overlay) or\n[HtmlClusterOverlay](/docs/api-reference/overlays/html-cluster-overlay).\n\n\n```jsx\nreturn (\n  <HtmlOverlayItem\n    style={{\n      transform: 'translate(-50%,-50%)',\n      pointerEvents: 'all'\n    }}\n    coordinates={coordinates}\n    key={key}\n  >\n    YOUR CONTENT HERE.\n  </HtmlOverlayItem>\n);\n```\n\n## Props\n### coordinates\nArray of two (or three if you want to specify elevation) numbers where this will be displayed.\n\n## Best practices\n\n### Anchor point\nBy default the top-left corner will align with the provided `coordinates`.\nYou can use CSS to change the **anchor point**.\nFor example use `transform: 'translate(-50%,-50%)'` to center.\n\n\n### Mouse events\nBy default this will not receive any mouse events.\nUse `pointerEvents: 'all'` to receive events.\n\n\n### Key property\nBecause this is used inside an array of `react components` you\nneed to provide a unique `key`. See the [React docs](https://reactjs.org/docs/lists-and-keys.html)\n\n","slug":"docs/api-reference/overlays/html-overlay-item","title":"HtmlOverlayItem"},{"excerpt":"HtmlOverlay Use this class if you have HTML items that need to be displayed at specific geo coordinates on the map.\nIf you need clustering…","rawMarkdownBody":"# HtmlOverlay\n\nUse this class if you have HTML items that need to be displayed at specific geo coordinates on the map.\nIf you need clustering see [HtmlClusterOverlay](/docs/api-reference/overlays/html-cluster-overlay).\nYou can subclass this class or provide [HtmlOverlayItem](/docs/api-reference/overlays/html-overlay-item) as children.\nThen use it as a `react component` inside `DeckGL`.\n\n\n```jsx\n<DeckGL initialViewState={initialViewState} controller={true}>\n  <StaticMap mapboxApiAccessToken={MAPBOX_ACCESS_TOKEN} />\n  <HtmlOverlay>\n    <HtmlOverlayItem coordinates={coordinates}>{title}</HtmlOverlayItem>\n  </HtmlOverlay>\n</DeckGL>\n```\n\nOr if you prefer to subclass:\n```jsx\nclass YourClassName extends HtmlOverlay {\n  getItems() {\n    return [\n      <HtmlOverlayItem\n        style={{ ...your style here... }}\n        key={ ... unique key... }\n        coordinates={[-122.41914, 37.77919]}\n      >\n        You can have text and children like <div>...</div>\n      </HtmlOverlayItem>\n    ];\n  }\n}\n```\n\n## Properties\n### zIndex\n\nDefault is `1`. Set to `0` to move items _under_ deck.gl layer.\n\n## Methods to override\n### getItems()\nProvide an array of [HtmlOverlayItem](/docs/api-reference/overlays/html-overlay-item)\nif not providing them as JSX children.\n\n","slug":"docs/api-reference/overlays/html-overlay","title":"HtmlOverlay"},{"excerpt":"React Map GL Draw react-map-gl-draw is a react based drawing library tailored for react-map-gl. Options mode (String, Optional) EditorModes…","rawMarkdownBody":"# React Map GL Draw\n\n`react-map-gl-draw` is a react based drawing library tailored for [`react-map-gl`](https://github.com/uber/react-map-gl).\n\n## Options \n- `mode` (String, Optional)\n  - `EditorModes.READ_ONLY` - Not interactive. This is the default mode.\n  - `EditorModes.SELECT` - Lets you select, delete, and drag features.\n  - `EditorModes.EDITTING` - Lets you select, delete, and drag vertices; and drag features.\n  - `EditorModes.DRAW_PATH` - Lets you draw a GeoJson `LineString` feature.\n  - `EditorModes.DRAW_POLYGON` - Lets you draw a GeoJson `Polygon` feature.\n  - `EditorModes.DRAW_POINT` - Lets you draw a GeoJson `Point` feature.\n  - `EditorModes.DRAW_RECTANGLE` - Lets you draw a `Rectangle` (represented as GeoJson `Polygon` feature).\n\n- `features` (Feature[], Optional) - List of features in GeoJson format. `react-map-gl-draw` respect the user' input `features`. If not provided, will manage `features` internally, and user can access and manipulate the `features` by calling `getFeatures`, `addFeatures`, and `deleteFeatures`.\n- `selectedFeatureIndex` (String, Optional) - Index of the selected feature. If not provided, will manage it internally.\n- `clickRadius` (Number, Optional) - Radius to detect features around a hovered or clicked point. Default value is `0`\n\n- `onSelect` (Function, Optional) - callback when clicking a position under `SELECT` and `EDITTING` mode. Receives an object containing the following parameters\n  - `selectedFeature`: selected feature. `null` if clicked an empty space.\n  - `selectedFeatureIndex`: selected feature index.`null` if clicked an empty space.\n  - `editHandleIndex`: selected editHandle index. `null` if clicked an empty space.\n  - `screenCoords`: screen coordinates of the clicked position.\n  - `mapCoords`: map coordinates of the clicked position.\n  \n- `onUpdate` (Function, Optional) - callback when anything is updated. Receives an object containing the following parameters\n  - `features` (Feature[]) - the updated list of GeoJSON features.\n  - `editType` (String) -  `addFeature`, `addPosition`, `finishMovePosition`\n  - `editContext` (Array) - list of edit objects, depend on `editType`, each object may contain `featureIndexes`, `editHandleIndexes`, `screenCoords`, `mapCoords`.\n \n**Feature object structure:**\n```js\n{\n  id, // an unique identified generated inside react-map-gl-draw library \n  geometry: {\n    coordinates, // latitude longitude pairs of the geometry points\n    type // geojson type, one of `Point`, `LineString`, or `Polygon`\n  },\n  properties: {\n    renderType, // Mainly used for styling, one of `Point`, `LineString`, `Polygon`, or `Rectangle`. Different from `geometry.type`. i.e. a rectangle's renderType is `Rectangle`, and `geometry.type` is `Polygon`. An incomplete (not closed) Polygon's renderType is `Polygon`, `geometry.type` is `LineString`\n    ...otherProps // other properties user passed in\n  }\n}\n```\n\n### Styling related options\n- `featureStyle` (Object|Function, Optional) : Object - Either a [style objects](https://reactjs.org/docs/dom-elements.html#style) or a function to style a feature, function parameters are \n  - `feature`: feature to style.\n  - `index`: index of the feature.\n  - `state`: one of `SELECTED`, `HOVERED`, `INACTIVE`, `UNCOMMITTED`, `CLOSING`.\n  \nReturns is a map of [style objects](https://reactjs.org/docs/dom-elements.html#style) passed to SVG `path` elements.\n\n- `featureShape` (String|Function, Optional): if is a string, should be one of `rect` or `circle`. If is a function, will receive the following parameters\n  - `feature`: feature to style.\n  - `index`: index of the feature.\n  - `state`: one of `SELECTED`, `HOVERED`, `INACTIVE`, `UNCOMMITTED`, `CLOSING`.\n\n- `editHandleStyle` (Object|Function, Optional) : Object - Either a [style objects](https://reactjs.org/docs/dom-elements.html#style) or a function to style an `editHandle, function parameters are \n  - `feature`: feature to style.\n  - `index`: index of the editHandle vertex in the feature.\n  - `state`: one of `SELECTED`, `HOVERED`, `INACTIVE`, `UNCOMMITTED`, `CLOSING`.\n  - `shape`: shape resolved from `editHandleShape`.\n  \nReturns is a map of [style objects](https://reactjs.org/docs/dom-elements.html#style) passed to SVG `circle` or `rect` elements.\n\n- `editHandleShape` (String|Function, Optional): if is a string, should be one of `rect` or `circle`. If is a function, will receive the following parameters\n  - `feature`: feature to style.\n  - `index`: index of the editHandle vertex in the feature.\n  - `state`: one of `SELECTED`, `HOVERED`, `INACTIVE`, `UNCOMMITTED`, `CLOSING`.\n\n## Explanations\n- `Feature`: any drawn shape, one of point, line, polygon or rectangle.\n- `EditHandle`: vertex of the feature being edited.\n\n### State related concepts:\n- `INACTIVE`: neither selected nor hovered, default state of a complete `feature` or `editHandle`.\n- `SELECTED`: being clicked or dragged. \n- `HOVERED`: hovered over by the mouse pointer.\n- `UNCOMMITTED`: in the middle of drawing, not yet added to the feature being edited.\n- `CLOSING`: closing a polygon. \n\n### Styling based on `state`:\n\n![img](https://raw.githubusercontent.com/uber-common/deck.gl-data/master/nebula.gl/react-map-gl-draw.png)\n\nAs shown in the above image, for the feature currently being edited, \n- `featureStyle({feature, state: SELECTED})` will be applied to the committed parts of the feature. (Green strokes)\n- `editHandleStyle({state: SELECTED})` will be applied to the committed editHandle vertices.  (Vertices with black stroke)\n- `featureStyle({feature, state: UNCOMMITTED})` will be applied to the uncommitted parts of the feature. (Gray stroke) \n- `editHandleStyle({state: UNCOMMITTED})` will be applied to the uncommitted editHandle vertex. (Gray vertex)\n\n## Methods\n\n##### `getFeatures` \n\n- Return a list of finished GeoJson features.\n\n##### `addFeatures` (Feature | Feature[])\n\n- Add a single or multiple GeoJson features to editor.\n\n##### `deleteDeatures` (Feature | Feature[])\n\n- Delete a single or multiple GeoJson features to editor.\n\n## Code Example\n```js\nimport React, { Component } from 'react';\nimport MapGL from 'react-map-gl';\nimport { Editor, EditorModes } from 'react-map-gl-draw';\n\nconst MODES = [\n  { id: EditorModes.EDITING, text: 'Select and Edit Feature'},\n  { id: EditorModes.DRAW_POINT, text: 'Draw Point'},\n  { id: EditorModes.DRAW_PATH, text: 'Draw Polyline'},\n  { id: EditorModes.DRAW_POLYGON, text: 'Draw Polygon'},\n  { id: EditorModes.DRAW_RECTANGLE, text: 'Draw Rectangle'}\n];\n\nconst DEFAULT_VIEWPORT = {\n  width: 800,\n  height: 600,\n  longitude: -122.45,\n  latitude: 37.78,\n  zoom: 14\n};\n\nclass App extends Component {\n  state = {\n    // map\n    viewport: DEFAULT_VIEWPORT,\n    // editor\n    selectedMode: EditorModes.READ_ONLY\n  };\n\n  _switchMode = evt => {\n    const selectedMode = evt.target.id;\n    this.setState({\n     selectedMode: selectedMode === this.state.selectedMode ? null : selectedMode\n    });\n  };\n\n  _renderToolbar = () => {\n    return (\n      <div style={{position: absolute, top: 0, right: 0, maxWidth: '320px'}}>\n        <select onChange={this._switchMode}>\n          <option value=\"\">--Please choose a mode--</option>\n          {MODES.map(mode => <option value={mode.id}>{mode.text}</option>)}\n        </select>\n      </div>\n    );\n  };\n\n  render() {\n    const { viewport, selectedMode } = this.state;\n    return (\n      <MapGL\n        {...viewport}\n        width=\"100%\"\n        height=\"100%\"\n        mapStyle={'mapbox://styles/mapbox/light-v9'}\n        onViewportChange={this.setState({ viewport })}\n      >\n        <Editor\n          clickRadius={12}\n          mode={selectedMode}\n        />\n        {this._renderToolbar()}\n      </MapGL>\n    );\n  }\n}\n```\n","slug":"docs/api-reference/react-map-gl-draw/react-map-gl-draw","title":"React Map GL Draw"}]}}}