{"version":3,"sources":["webpack:///../modules/core/src/lib/style.js","webpack:///../modules/core/src/lib/deck-renderer/deck-drawer.js","webpack:///../modules/core/src/lib/nebula-layer.js","webpack:///../modules/layers/src/immutable-feature-collection.js","webpack:///../modules/layers/src/mode-handlers/mode-handler.js","webpack:///../modules/layers/src/mode-handlers/view-handler.js","webpack:///../modules/layers/src/utils.js","webpack:///../modules/layers/src/mode-handlers/modify-handler.js","webpack:///../modules/layers/src/mode-handlers/elevation-handler.js","webpack:///../modules/layers/src/mode-handlers/snappable-handler.js","webpack:///../modules/layers/src/mode-handlers/translate-handler.js","webpack:///../modules/layers/src/mode-handlers/duplicate-handler.js","webpack:///../modules/layers/src/mode-handlers/rotate-handler.js","webpack:///../modules/layers/src/mode-handlers/scale-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-point-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-line-string-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-90degree-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/two-click-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-rectangle-handler.js","webpack:///../modules/layers/src/mode-handlers/split-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/three-click-polygon-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-rectangle-using-three-points-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-circle-from-center-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-circle-by-bounding-box-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-ellipse-by-bounding-box-handler.js","webpack:///../modules/layers/src/mode-handlers/draw-ellipse-using-three-points-handler.js","webpack:///../modules/layers/src/mode-handlers/extrude-handler.js","webpack:///../modules/layers/src/layers/editable-layer.js","webpack:///../modules/layers/src/layers/editable-geojson-layer.js","webpack:///../modules/layers/src/layers/selection-layer.js","webpack:///../modules/layers/src/layers/elevated-edit-handle-layer.js","webpack:///../modules/layers/src/shaderlib/outline/outline.js","webpack:///../modules/layers/src/layers/path-outline-layer/path-outline-layer.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer-vertex.glsl.js","webpack:///../modules/layers/src/layers/mesh-layer/mesh-layer-fragment.glsl.js","webpack:///../modules/layers/src/layers/path-marker-layer/arrow-2d-geometry.js","webpack:///../modules/layers/src/layers/path-marker-layer/create-path-markers.js","webpack:///../modules/layers/src/layers/path-marker-layer/polyline.js","webpack:///../modules/layers/src/layers/path-marker-layer/path-marker-layer.js","webpack:///../modules/layers/src/layers/junction-scatterplot-layer.js","webpack:///../modules/layers/src/mode-handlers/composite-mode-handler.js","webpack:///../modules/core/src/lib/layers/segments-layer.js","webpack:///../examples/deck/toolbox.js","webpack:///../examples/deck/example.js","webpack:///../examples/data/edit-handles.png"],"names":["ArrowStyles","SELECTION_TYPE","EventEmitter","ImmutableFeatureCollection","featureCollection","this","_proto","prototype","getObject","replacePosition","geometry","features","featureIndex","isPolygonal","updatedGeometry","Object","assign","coordinates","immutablyReplacePosition","positionIndexes","updatedPosition","replaceGeometry","removePosition","Error","immutablyRemovePosition","type","polygon","holeIndex","length","removeHoleIfNecessary","prunePolygonIfNecessary","lineStringIndex","lineString","pruneMultiLineStringIfNecessary","polygonIndex","outerRing","pruneMultiPolygonIfNecessary","pruneGeometryIfNecessary","addPosition","immutablyAddPosition","positionToAdd","updatedFeature","concat","slice","addFeature","feature","getUpdatedPosition","previousPosition","elevation","updated","hole","ModeHandler","_modeConfig","_selectedFeatureIndexes","_clickSequence","setFeatureCollection","getFeatureCollection","getImmutableFeatureCollection","getSelectedFeature","getSelectedGeometry","getSelectedFeaturesAsFeatureCollection","getSelectedFeatureIndexes","map","selectedIndex","getModeConfig","setModeConfig","modeConfig","_setTentativeFeature","setSelectedFeatureIndexes","indexes","setDeckGlContext","_context","context","setLayerId","_layerId","layerId","getClickSequence","resetClickSequence","getTentativeFeature","_tentativeFeature","tentativeFeature","getEditHandles","getCursor","_ref","isDragging","isSelectionPicked","picks","pickedIndexes","_ref2","index","some","getAddFeatureAction","geometryAsAny","updatedData","properties","editType","featureIndexes","editContext","getAddManyFeaturesAction","initialIndex","updatedIndexes","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref3","next","done","value","getAddFeatureOrBooleanPolygonAction","selectedFeature","booleanOperation","console","turfUnion","turfDifference","turfIntersect","handleClick","push","event","groundCoords","handlePointerMove","editAction","cancelMapPan","handleStartDragging","handleStopDragging","getPickedEditHandle","info","find","pick","isEditingHandle","object","getIntermediatePosition","position1","position2","getEditHandlesForGeometry","editHandleType","handles","position","getEditHandlesForCoordinates","a","b","_a","positionIndexPrefix","editHandles","i","ViewHandler","_ModeHandler","apply","arguments","inheritsLoose_default","mode_handler_ModeHandler","generatePointsParallelToLinePoints","p1","p2","pt","point","ddistance","pointToLineDistance","lineBearing","bearing","orthogonalBearing","isPointToLeftOfLine","p3","destination","p4","ModifyHandler","_this","_handles","_index","featureAsPick","includes","intermediatePoint","referencePoint","recursivelyTraverseNestedArrays","array","prefix","fn","lineStringFeature","toLineString","candidateIntermediatePoint","nearestPointOnLine","dist","_intermediatePoint","line","inPoint","clickedEditHandle","ignored","_updatedData","_lastPointerMovePicks","editHandle","pointerDownPicks","Boolean","selectedFeatureIndexes","ElevationHandler","_ModifyHandler","makeElevatedEvent","_ref$min","min","_ref$max","max","yBot","viewport","project","yTop","screenCoords","Math","call","cursor","params","modify_handler_ModifyHandler","SnappableHandler","handler","_handler","_getSnappedMouseEvent","snapPoint","pointerDownGroundCoords","_startDragSnapHandlePosition","_getEditHandleLayerId","layer","layerManager","layers","l","id","_getEditHandlePicks","_ref$snapPixels","snapPixels","potentialSnapHandle","deck","pickMultipleObjects","x","y","layerIds","radius","depth","pickedHandle","_updatePickedHandlePosition","_editHandlePicks","reduce","_getFeaturesFromRelevantLayers","_this2","layerIdsToSnapTo","featuresFromAdditionalLayers","filter","otherLayer","data","_getNonPickedIntermediateHandles","enableSnapping","_ref6","_performSnapIfRequired","_isSnapped","_ref7","_performUnsnapIfRequired","_getSnapAwareEvent","modeActionSummary","TranslateHandler","_isTranslatable","_geometryBeforeTranslate","getTranslateAction","startDragPoint","currentPoint","distanceMoved","turfDistance","direction","turfBearing","movedFeatures","turfTransformTranslate","selectedIndexes","movedFeature","DuplicateHandler","_TranslateHandler","translate_handler_TranslateHandler","RotateHandler","_isRotatable","_geometryBeingRotated","getRotateAction","startPosition","angle","centroid","bearing1","getRotationAngle","turfCentroid","rotatedFeatures","turfTransformRotate","ScaleHandler","_isScalable","_geometryBeingScaled","getScaleAction","factor","startDistance","getScaleFactor","scaledFeatures","turfTransformScale","origin","DrawPointHandler","DrawLineStringHandler","selectedGeometry","clickSequence","drawAtFront","result","DrawPolygonHandler","polygonToAdd","fakePointerMoveEvent","pointerDownScreenCoords","sourceEvent","Draw90DegreePolygonHandler","finalizedCoordinates","coords","getIntermediatePoint","tc","angle1","angle2","angles","first","second","forEach","newAngle1","newAngle2","distance","indexFirst","line1","indexSecond","line2","fc","lineIntersect","TwoClickPolygonHandler","DrawRectangleHandler","_TwoClickPolygonHandl","corner1","corner2","bboxPolygon","two_click_polygon_handler_TwoClickPolygonHandler","SplitPolygonHandler","calculateGroundCoords","lock90Degree","firstPoint","turfPolygonToLine","lines","minDistance","Number","MAX_SAFE_INTEGER","closestPoint","distanceFromOrigin","lastBearing","currentDistance","units","destination_default","lastPoint","approximatePoint","isPointInPolygon","booleanPointInPolygon","isLineInterectingWithPolygon","splitPolygon","_modeConfig$gap","gap","_modeConfig$units","buffer","turfBuffer","_updatedGeometry$geom","updatedCoordinates","c","agg","prev","p","ThreeClickPolygonHandler","DrawRectangleUsingThreePointsHandler","_ThreeClickPolygonHan","_generatePointsParall","three_click_polygon_handler_ThreeClickPolygonHandler","DrawCircleFromCenterHandler","_modeConfig$steps","steps","options","centerCoordinates","circle","DrawCircleByBoundingBoxHandler","firstClickedPoint","DrawEllipseByBoundingBoxHandler","minX","minY","maxX","maxY","polygonPoints","xSemiAxis","ySemiAxis","ellipse","DrawEllipseUsingThreePointsHandler","ExtrudeHandler","_len","args","_key","isPointAdded","size","coordinatesSize","nextPositionIndexes","getPointForPositionIndexes","prevPositionIndexes","isOrthogonal","_generatePointsParall2","getBearing","prevPoint","nextPoint","prevAngle","nextAngle","EditableLayer","onLayerClick","onDoubleClick","onStartDragging","onStopDragging","onPointerMove","initializeState","setState","_editableLayerState","pointerHandlers","finalizeState","_removePointerHandlers","updateState","props","changeFlags","_addPointerHandlers","state","gl","canvas","removeEventListener","onPointerDown","onPointerUp","_onPointerMove","bind","_onPointerDown","_onPointerUp","_onDoubleClick","addEventListener","getScreenCoords","getGroundCoords","_this$state$_editable","movedEnoughForDrag","_this$state$_editable2","pointerEvent","getBoundingClientRect","unproject","screenCoords1","screenCoords2","CompositeLayer","DEFAULT_LINE_COLOR","DEFAULT_FILL_COLOR","DEFAULT_SELECTED_LINE_COLOR","DEFAULT_SELECTED_FILL_COLOR","DEFAULT_EDITING_EXISTING_POINT_COLOR","DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","DEFAULT_EDITING_SNAP_POINT_COLOR","DEFAULT_EDITING_EXISTING_POINT_RADIUS","DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","DEFAULT_EDITING_SNAP_POINT_RADIUS","getEditHandleColor","handle","defaultProps","mode","onEdit","pickable","fp64","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","lineWidthUnits","lineJointRounded","lineMiterLimit","pointRadiusScale","pointRadiusMinPixels","pointRadiusMaxPixels","lineDashJustified","getLineColor","isSelected","getFillColor","getRadius","f","getLineWidth","lineWidth","getLineDashArray","getTentativeLineDashArray","getTentativeLineColor","getTentativeFillColor","getTentativeLineWidth","editHandleParameters","editHandleLayerProps","editHandlePointRadiusScale","editHandlePointOutline","editHandlePointStrokeWidth","editHandlePointRadiusMinPixels","editHandlePointRadiusMaxPixels","getEditHandlePointColor","getEditHandlePointRadius","editHandleIconAtlas","editHandleIconMapping","editHandleIconSizeScale","getEditHandleIcon","getEditHandleIconSize","getEditHandleIconColor","getEditHandleIconAngle","modeHandlers","view","view_handler_ViewHandler","modify","elevation_handler_ElevationHandler","extrude","extrude_handler_ExtrudeHandler","rotate","rotate_handler_RotateHandler","translate","snappable_handler_SnappableHandler","duplicate","duplicate_handler_DuplicateHandler","scale","scale_handler_ScaleHandler","drawPoint","draw_point_handler_DrawPointHandler","drawLineString","draw_line_string_handler_DrawLineStringHandler","drawPolygon","draw_polygon_handler_DrawPolygonHandler","draw90DegreePolygon","draw_90degree_polygon_handler_Draw90DegreePolygonHandler","split","split_polygon_handler_SplitPolygonHandler","drawRectangle","draw_rectangle_handler_DrawRectangleHandler","drawRectangleUsing3Points","draw_rectangle_using_three_points_handler_DrawRectangleUsingThreePointsHandler","drawCircleFromCenter","draw_circle_from_center_handler_DrawCircleFromCenterHandler","drawCircleByBoundingBox","draw_circle_by_bounding_box_handler_DrawCircleByBoundingBoxHandler","drawEllipseByBoundingBox","draw_ellipse_by_bounding_box_handler_DrawEllipseByBoundingBoxHandler","drawEllipseUsing3Points","draw_ellipse_using_three_points_handler_DrawEllipseUsingThreePointsHandler","EditableGeoJsonLayer","renderLayers","subLayerProps","getSubLayerProps","selectionAwareAccessor","updateTriggers","geojson_layer","_EditableLayer","selectedFeatures","shouldUpdateState","oldProps","oldContext","stateChanged","modeHandler","propsOrDataChanged","dataChanged","updateTentativeFeature","updateEditHandles","elem","accessor","isFeatureSelected","indexOf","getPickingInfo","sourceLayer","createEditHandleLayers","sharedProps","layerName","parameters","icon_layer","iconAtlas","iconMapping","sizeScale","getIcon","getSize","getColor","getAngle","getPosition","d","scatterplot_layer","radiusScale","outline","strokeWidth","radiusMinPixels","radiusMaxPixels","EditHandleType","createTentativeLayers","autoHighlight","setLayerNeedsUpdate","_this$state$modeHandl","_ref4","selectionType","onSelect","EMPTY_DATA","PASS_THROUGH_PROPS","SelectionLayer","_selectRectangleObjects","_this$props","_this$context$viewpor","x1","y1","_this$context$viewpor2","x2","y2","pickingInfos","pickObjects","width","height","_selectPolygonObjects","bigPolygon","_this$props2","mousePoints","allX","mousePoint","allY","landPointsPoly","bigBuffer","e","pendingPolygonSelection","blockerId","setTimeout","item","_SELECTION_TYPE$RECTA","inheritedProps","undefined","editable_geojson_layer_EditableGeoJsonLayer","polygon_layer","opacity","obj","getPolygon","o","_ref2$changeFlags","ElevatedEditHandleLayer","line_layer","getSourcePosition","getTargetPosition","getStrokeWidth","INITIAL_STATE","outlineEnabled","outlineRenderShadowmap","outlineShadowmap","name","vs","fs","getUniforms","_temp","uniforms","injectShaderCode","source","_ref$code","code","PathOutlineLayer","getShaders","shaders","_PathLayer","modules","outlineFramebuffer","core_dist_esm","dummyTexture","attributeManager","addInstanced","instanceZLevel","GL","UNSIGNED_BYTE","update","calculateZLevels","draw","moduleParameters","rounded","miterLimit","widthScale","widthMinPixels","widthMaxPixels","dashJustified","jointType","alignMode","_this$state","color","model","updateModuleSettings","depthTest","blendEquation","MAX","framebuffer","getZLevel","pathTesselator","attribute","_updateAttribute","target","getValue","PathLayer","fp64LowPart","RADIAN_PER_DEGREE","getTexture","src","opts","urls","then","textures","catch","error","Promise","resolve","getTextureFromData","validateGeometryAttributes","attributes","condition","message","assert","getGeometry","positions","mesh","texture","depthFunc","LEQUAL","lightSettings","getYaw","getPitch","getRoll","MeshLayer","use64bitProjection","getAttributeManager","instancePositions","instancePositions64xy","calculateInstancePositions64xyLow","instanceRotations","calculateInstanceRotations","instanceColors","defaultValue","emptyTexture","Uint8Array","_updateFP64","setTexture","delete","getModel","render","isInstanced","shaderCache","sampler","hasTexture","setUniforms","isFP64","use64bitPositions","Float32Array","_iterator2","_isArray2","_i2","Layer","Arrow2DGeometry","_Geometry","getArrowAttributes","Geometry","_ref$length","_ref$headSize","headSize","_ref$tailWidth","tailWidth","_ref$tailStart","tailStart","texCoords","i3","normals","getLineLength","vPoints","lineLength","DEFAULT_COLOR","DEFAULT_DIRECTION","forward","backward","createMarkerAlongPath","path","percentage","projectFlat","distanceAlong","previousDistance","along","vCenter","normalize","vDirection","vector2","subtract","verticalAngle","PI","getClosestPointOnLine","_ref$clampToLine","clampToLine","lineVector","vector3","pointVector","dotProduct","clamp","DEFAULT_MARKER_LAYER","mesh_layer_MeshLayer","DEFAULT_MARKER_LAYER_PROPS","arrow_2d_geometry_Arrow2DGeometry","MarkerLayer","markerLayerProps","hightlightIndex","highlightPoint","getPath","getMarkerColor","getDirection","getMarkerPercentages","PathMarkerLayer","markers","coordinateSystem","COORDINATE_SYSTEM","METER_OFFSETS","_viewport$metersToLng","xyz","dx","dy","coordinateOrigin","LNGLAT_OFFSETS","_dx","_y","updateTriggersChanged","_ref$getPath","_ref$getDirection","_ref$getColor","create_path_markers_DEFAULT_COLOR","_ref$getMarkerPercent","vPointsReverse","reverse","marker","createPathMarkers","_recalculateClosestPoint","propsChanged","highlightIndex","points","pClosest","distanceSquared","Infinity","pClosestOnLine","distanceToLineSquared","getClosestPointOnPolyline","closestPoints","path_outline_layer_PathOutlineLayer","blend","JunctionScatterplotLayer","getStrokeColor","getInnerRadius","ScatterplotLayer","CompositeModeHandler","handlers","_coalesce","resultEval","callback","_NEBULA_TO_DECK_DIREC","styles","toolbox","top","left","background","padding","borderRadius","border","fontFamily","fontSize","toolboxRow","display","flexWrap","toolboxRowWrapping","marginBottom","toolboxDivider","borderBottom","toolboxItem","flexBasis","toolboxLabel","textTransform","ToolboxRow","react_default","createElement","style","children","ToolboxRowWrapping","ToolboxLabel","ToolboxControl","ToolboxDivider","mapContainer","alignItems","checkbox","margin","initialViewport","latitude","longitude","pitch","zoom","ALL_MODES","category","modes","POLYGON_DRAWING_MODES","drawLineString+modify","composite_mode_handler_CompositeModeHandler","example_getEditHandleColor","Example","_Component","_onChangeViewport","_onLayerClick","selectionTool","_resize","forceUpdate","_loadSample","testFeatures","sample_geojson","pointsRemovable","componentDidMount","window","componentWillUnmount","_renderSelectFeatureCheckbox","toolbox_ToolboxLabel","key","checked","onChange","featureType","_renderSelectFeatureCheckboxes","checkboxes","_renderBooleanOperationControls","_this3","toolbox_ToolboxRow","toolbox_ToolboxControl","operation","backgroundColor","onClick","_renderDrawLineStringModeControls","_this4","_renderModifyModeControls","_this5","_renderSplitModeControls","_this6","_renderSnappingControls","_this7","step","parseFloat","_renderModeConfigControls","controls","_renderToolBox","_this8","ToolboxStyles","toolbox_ToolboxRowWrapping","paddingRight","toolbox_ToolboxDivider","rows","JSON","renderStaticMap","dist_esm","customizeLayers","_this9","innerHeight","innerWidth","editableGeoJsonLayer","updatedSelectedFeatureIndexes","elevated_edit_handle_layer_ElevatedEditHandleLayer","edit_handles_default","intermediate","mask","existing","depthMask","FUNC_ADD","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","selection_layer_SelectionLayer","pi","href","rel","esm_deckgl","viewState","views","esm","controller","doubleClickZoom","onViewStateChange","Component","module","exports"],"mappings":"uOAEaA,EAAc,EAAdA,EAAc,EAAdA,EAAc,EAAdA,EAIL,mFCYKC,EAAiB,KAAjBA,EAAiB,YAAjBA,EAGF,4ECf8BC,2GCO5BC,EAAb,WAGE,SAAAA,EAAAC,GACEC,KAAAD,oBAJJ,IAAAE,EAAAH,EAAAI,UAAA,OAAAD,EAAAE,UAOEA,WACE,OAAOH,KAAPD,mBARJE,EAAAG,gBAqBEA,gBAKE,IAAMC,EAAWL,KAAAD,kBAAAO,SAAAC,GAAjBF,SAEMG,EAAcH,oBAApB,iBAAmDA,OAC7CI,EAAoBC,OAAAC,OAAA,GAAAN,EAAA,CAExBO,YAAaC,EACXR,EADmCO,YAAAE,EAAAC,EAAAP,KAQvC,OAAOR,KAAAgB,gBAAAT,EAAPE,IAvCJR,EAAAgB,eAmDEA,cACE,IAAMZ,EAAWL,KAAAD,kBAAAO,SAAAC,GAAjBF,SAEA,aAAIA,OACF,MAAMa,MAAN,mEAEF,GACEb,uBAEAA,qBAHF,EAKE,MAAMa,MAAN,0EAEF,GACEb,uBAEAA,qBAHF,EAKE,MAAMa,MAAN,sEAEF,GACEb,oBAEAA,wBAFAA,GADF,IAKES,KAEA,MAAMI,MAAN,iFAEF,GACEb,gCAEAA,sBAEAA,wBALF,EAOE,MAAMa,MAAN,2EAEF,GACEb,6BAEAA,sBAEAA,2BAJAA,OAMAS,MAPF,IASEA,KAEA,MAAMI,MAAN,sFAKF,IAAMV,EAAcH,oBAApB,iBAAmDA,OAC7CI,EAAoBC,OAAAC,OAAA,GAAAN,EAAA,CAExBO,YAAaO,EAAwBd,EAADO,YAAAE,EAAAN,KAMtC,OAyMJ,SAAAH,GACE,OAAQA,EAARe,MACE,eAeJ,SAAAf,GAIE,IAHA,IAAMgB,EAAUhB,EADkCO,YAIzCU,EAAT,EAAwBA,EAAYD,EAApCE,OAAoDD,IAC9CE,EAAqBH,EAAzBC,IAEEA,IArBAG,IACA,MACF,uBAwBJ,SAAApB,GACE,IAAK,IAAIqB,EAAT,EAA8BA,EAAkBrB,cAAhDkB,OAA6EG,IAAmB,CAC9F,IAAMC,EAAatB,cAAnBqB,GACA,IAAIC,WAEFtB,uBAF2B,GAI3BqB,MA9BAE,IACA,MACF,oBAiCJ,SAAAvB,GACE,IAAK,IAAIwB,EAAT,EAA2BA,EAAexB,cAA1CkB,OAAuEM,IAAgB,CACrF,IAAMR,EAAUhB,cAAhBwB,GACMC,EAAYT,EAFmE,GAKjFS,UAAJ,IACEzB,uBADyB,GAGzBwB,KAGF,IAAK,IAAIP,EAAT,EAAwBA,EAAYD,EAApCE,OAAoDD,IAC9CE,EAAqBH,EAAzBC,IAEEA,KA/CFS,KApNFC,IAEOhC,KAAAgB,gBAAAT,EAAPE,IAlHJR,EAAAgC,YA+HEA,gBAKE,IAAM5B,EAAWL,KAAAD,kBAAAO,SAAAC,GAAjBF,SAEA,aAAIA,OACF,MAAM,IAAAa,MAAN,+CAGF,IAAMV,EAAcH,oBAApB,iBAAmDA,OAC7CI,EAAoBC,OAAAC,OAAA,GAAAN,EAAA,CAExBO,YAAasB,EACX7B,EAD+BO,YAAAE,EAAAqB,EAAA3B,KAQnC,OAAOR,KAAAgB,gBAAAT,EAAPE,IArJJR,EAAAe,gBAwJEA,cACE,IAAMoB,EAAmB1B,OAAAC,OAAA,GACpBX,KAAAD,kBAAAO,SADoBC,GAAA,CAEvBF,aAYF,OAAO,IAAAP,EATuBY,OAAAC,OAAA,GACzBX,KADyBD,kBAAA,CAE5BO,SAAQ,GAAA+B,OACHrC,KAAAD,kBAAAO,SAAAgC,MAAA,EADG/B,GAAA,CAAA6B,GAGHpC,KAAAD,kBAAAO,SAAAgC,MAAsC/B,EAHnC,QAhKdN,EAAAsC,WA0KEA,YAME,OAAO,IAAAzC,EALuBY,OAAAC,OAAA,GACzBX,KADyBD,kBAAA,CAE5BO,SAAQ,GAAA+B,OAAMrC,KAAAD,kBAANO,SAAA,CAAAkC,QA7Kd1C,EAAA,GAoLA,SAAA2C,EAAA1B,EAAA2B,GAGE,GAAI3B,cAAJ,IAAoC2B,SAA+B,CACjE,IAAMC,EAAaD,EAAnB,GACA,MAAO,CAAC3B,EAAD,GAAqBA,EAArB,GAAP4B,GAGF,OAAA5B,EAGF,SAAAF,EAAAD,EAAAE,EAAAC,EAAAP,GAME,IAAAM,EACE,OAAAF,EAEF,OAAIE,SACF,OAAO2B,EAAkB1B,EAAzBH,GAEF,OAAIE,SAA8B,CAChC,IAAM8B,EAAO,GAAAP,OACRzB,UAAqBE,EADb,KAEX2B,EAAkB1B,EAAkBH,EAAYE,EAFrC,MAGRF,QAAkBE,KAHvB,IAeA,OAREN,GACCM,UAA4BA,OAAuBF,SAFtD,IAMEgC,KAAaH,EAAkB1B,EAAkBH,EAAjDgC,IACAA,EAAQhC,SAARgC,GAAkCH,EAAkB1B,EAAkBH,EAAtEgC,KAEFA,EAIF,SAAAP,OACKzB,UAAqBE,EAD1B,KAEED,EACED,EAAYE,EADU,IAEtBA,UAAyBA,EAFHS,QAAAR,EAF1BP,IAQKI,QAAkBE,KARvB,IAYF,SAAAK,EAAAP,EAAAE,EAAAN,GAKE,IAAAM,EACE,OAAAF,EAEF,OAAIE,SACF,MAAMI,MAAN,oDAEF,OAAIJ,SAA8B,CAChC,IAAM8B,EAAO,GAAAP,OACRzB,UAAqBE,EADb,IAERF,QAAkBE,KAFvB,IAmBA,OAbEN,GACCM,UAA4BA,OAAuBF,SAFtD,IAME,IAAIE,KAEF8B,EAAQA,SAARA,GAA8BA,EAA9BA,GACS9B,OAAuBF,SAA3B,IAELgC,KAAaA,EAAQA,SAArBA,KAGJA,EAIF,SAAAP,OACKzB,UAAqBE,EAD1B,KAEEK,EACEP,EAAYE,EADS,IAErBA,UAAyBA,EAFJS,QAFzBf,IAOKI,QAAkBE,KAPvB,IAWF,SAAAoB,EAAAtB,EAAAE,EAAAqB,EAAA3B,GAME,IAAAM,EACE,OAAAF,EAEF,OAAIE,SACF,MAAMI,MAAN,oDAEF,WAAIJ,SACW,GAAAuB,OACRzB,UAAqBE,EADb,KAAAqB,GAGRvB,QAAkBE,EAHvB,KASF,GAAAuB,OACKzB,UAAqBE,EAD1B,KAEEoB,EACEtB,EAAYE,EADM,IAElBA,UAAyBA,EAFPS,QAAAY,EAFtB3B,IAQKI,QAAkBE,KARvB,IA0EF,SAAAU,EAAAH,EAAAC,GAEE,OADaD,EAAbC,GACIuB,QAAJ,IACExB,eACA,GC1WJ,IAAayB,EAAb,WAUE,SAAAA,EAAA/C,GAAmDC,KANnD+C,YAAmB,KAMgC/C,KALnDgD,wBAAoC,GAKehD,KAJnDiD,eAA6B,GAK3BlD,GACEC,KAAAkD,qBAAAnD,GAZN,IAAAE,EAAA6C,EAAA5C,UAAA,OAAAD,EAAAkD,qBAgBEA,WACE,OAAOnD,KAAAD,kBAAPI,aAjBJF,EAAAmD,8BAoBEA,WACE,OAAOpD,KAAPD,mBArBJE,EAAAoD,mBAwBEA,WACE,WAAIrD,KAAAgD,wBAAAzB,OACKvB,KAAAD,kBAAAI,YAAAG,SAA4CN,KAAAgD,wBAAnD,IAEF,MA5BJ/C,EAAAqD,oBA+BEA,WACE,IAAMd,EAAUxC,KAAhBqD,qBACA,OAAAb,EACSA,EAAPnC,SAEF,MApCJJ,EAAAsD,uCAuCEA,WAA4D,IAClDjD,EAAaN,KAAAD,kBADqCI,YAAAG,SAK1D,MAAO,CACLc,KADK,oBAELd,SALuBN,KAAAwD,4BAAAC,IACvB,SAAAC,GAAa,OAAIpD,EAAJoD,OA1CnBzD,EAAAiD,qBAkDEA,YACElD,KAAAD,kBAAyB,IAAAD,EAAzBC,IAnDJE,EAAA0D,cAsDEA,WACE,OAAO3D,KAAP+C,aAvDJ9C,EAAA2D,cA0DEA,YACM5D,KAAA+C,cAAJc,IAIA7D,KAAA+C,YAAAc,EACA7D,KAAA8D,qBAAA,QAhEJ7D,EAAAuD,0BAmEEA,WACE,OAAOxD,KAAPgD,yBApEJ/C,EAAA8D,0BAuEEA,YACM/D,KAAAgD,0BAAJgB,IAIAhE,KAAAgD,wBAAAgB,EACAhE,KAAA8D,qBAAA,QA7EJ7D,EAAAgE,iBAgFEA,YACEjE,KAAAkE,SAAAC,GAjFJlE,EAAAmE,WAoFEA,YACEpE,KAAAqE,SAAAC,GArFJrE,EAAAsE,iBAwFEA,WACE,OAAOvE,KAAPiD,gBAzFJhD,EAAAuE,mBA4FEA,WACExE,KAAAiD,eAAA,IA7FJhD,EAAAwE,oBAgGEA,WACE,OAAOzE,KAAP0E,mBAjGJzE,EAAA6D,qBAqGEA,YACE9D,KAAA0E,kBAAAC,EACAA,IAEE3E,KAAAiD,eAAA,KAzGNhD,EAAA2E,eAkHEA,cACE,UAnHJ3E,EAAA4E,UAsHEA,YAA2DC,EAA/CC,WACV,cAvHJ9E,EAAA+E,kBA0HEA,YACE,IAAKC,EAAL1D,OAAmB,SACnB,IAAM2D,EAAgBD,EAAAxB,IAAU,SAAA0B,GAAA,OAAAA,EAAAC,QAEhC,OAD+BpF,KAA/BwD,4BACO6B,KAA4B,SAAAD,GAAK,OAAIF,WAAJE,MA9H5CnF,EAAAqF,oBAiIEA,YAEE,IAAMC,EAANlF,EAEMmF,EAAcxF,KAAAoD,gCAAAb,WACN,CACVnB,KADU,UAEVqE,WAFU,GAGVpF,SAAUkF,IAJdpF,YAQA,MAAO,CACLqF,YADKA,EAELE,SAFK,aAGLC,eAAgB,CAACH,kBAHZ,GAILI,YAAa,OAjJnB3F,EAAA4F,yBAqJEA,YACE,IAAMvF,EAAWP,EAAjBO,SACIkF,EAAcxF,KAAlBoD,gCACM0C,EAAeN,uBAArBjE,OACMwE,EAAN,GACAC,EAAA1F,EAAA2F,EAAAC,MAAAC,QAAAH,GAAAI,EAAA,MAAAJ,EAAAC,EAAAD,IAAAK,OAAAC,cAAgC,KAAAC,EAAA,GAAAN,EAAA,IAAAG,GAAAJ,EAAAzE,OAAA,MAAAgF,EAAAP,EAAAI,SAAA,KAAAA,EAAAJ,EAAAQ,QAAAC,KAAA,MAAAF,EAAAH,EAAAM,MAAA,IAArBlE,EAAqB+D,EACtBd,EAAyBjD,EADHiD,WAExBF,EAD2B/C,EADHnC,SAG9BmF,EAAcA,EAAAjD,WAAuB,CACnCnB,KADmC,UAEnCqE,WAFmCA,EAGnCpF,SAAUkF,IAEZQ,OAAoBD,EAAeC,EAAnCA,QAGF,MAAO,CACLP,YAAaA,EADRrF,YAELuF,SAFK,aAGLC,eAHKI,EAILH,YAAa,OAzKnB3F,EAAA0G,oCA6KEA,YACE,IAAMC,EAAkB5G,KAAxBqD,qBACMQ,EAAa7D,KAAnB2D,gBACA,GAAIE,GAAcA,EAAlBgD,iBAA+C,CAC7C,IACED,GACCA,6BAFH,iBAGIA,gBAMF,OAHAE,6FAGA,KAGF,IAKArG,EALM+B,EAAU,CACdpB,KADc,UAEdf,YAIF,aAAIwD,mBACFpD,EAAkBsG,IAASH,EAA3BnG,QACK,kBAAIoD,mBACTpD,EAAkBuG,YAAcJ,EAAhCnG,OACK,qBAAIoD,mBAKT,OADAiD,yCAAyCjD,EAAzCiD,kBACA,KAJArG,EAAkBwG,IAAaL,EAA/BnG,GAOF,IAAAA,EAGE,OADAqG,yEACA,KAGF,IAAMvG,EAAeP,KAAAwD,4BAArB,GAaA,MAP+B,CAC7BgC,YALkBxF,KAAAoD,gCAAApC,gBAAAT,EACaE,EADbJ,UAApBF,YAMEuF,SAF6B,gBAG7BC,eAAgB,CAHapF,GAI7BqF,YAAa,MAKjB,OAAO5F,KAAAsF,oBAAPjF,IApOJJ,EAAAiH,YAuOEA,YAGE,OAFAlH,KAAAiD,eAAAkE,KAAyBC,EAAzBC,cAEA,MA1OJpH,EAAAqH,kBA6OEA,YACE,MAAO,CAAEC,WAAF,KAAoBC,cAAc,IA9O7CvH,EAAAwH,oBAiPEA,YACE,aAlPJxH,EAAAyH,mBAqPEA,YACE,aAtPJ5E,EAAA,GA0PO,SAAA6E,EAAA1C,GACL,IAAM2C,EAAO3C,GAASA,EAAA4C,KAAW,SAAAC,GAAI,OAAIA,EAAJC,kBACrC,OAAAH,EACSA,EAAPI,OAEF,KAGK,SAAAC,EAAAC,EAAAC,GAKL,MAJ6B,EAC1BD,KAAeC,EAAhB,IAD2B,GAE1BD,KAAeC,EAAhB,IAFF,GAOK,SAAAC,EAAA/H,EAAAE,EAAA8H,QAIL,IADAA,MAAiC,YAEjC,IAAIC,EAAJ,GAEA,OAAQjI,EAARe,MACE,YAEEkH,EAAU,CACR,CACEC,SAAUlI,EADZO,YAEEE,gBAFF,GAGEP,aAHFA,EAIEa,KAAMiH,IAGV,MACF,iBACA,iBAEEC,EAAUA,SACRE,EAA6BnI,EAADO,YAAA,GAAAL,EAD9B+H,IAGA,MACF,cACA,sBAEE,IAAK,IAAIG,EAAT,EAAgBA,EAAIpI,cAApBkB,OAAiDkH,IAC/CH,EAAUA,SACRE,EAA6BnI,cAADoI,GAA0B,CAA1BA,GAAAlI,EAD9B+H,IAGA,YAAIjI,SAEFiI,EAAUA,WAAVA,IAGJ,MACF,mBAEE,IAAK,IAAIG,EAAT,EAAgBA,EAAIpI,cAApBkB,OAAiDkH,IAC/C,IAAK,IAAIC,EAAT,EAAgBA,EAAIrI,iBAApBkB,OAAoDmH,IAUlDJ,GATAA,EAAUA,SACRE,EACEnI,iBAD0BqI,GAE1B,CAAAC,EAF0BD,GAAAnI,EAFyB8H,KAU7CC,SAAVA,GAGJ,MACF,QACE,MAAMpH,MAAK,4BAA6Bb,EAAxCe,MAGJ,OAAAkH,EAGF,SAAAE,EAAA5H,EAAAgI,EAAArI,EAAA8H,QAKgB,IADdA,MAAiC,YAGjC,IADA,IAAMQ,EAAN,GACSC,EAAT,EAAgBA,EAAIlI,EAApBW,OAAwCuH,IAAK,CAC3C,IAAMP,EAAW3H,EAAjBkI,GACAD,OAAiB,CACfN,SADeA,EAEfzH,gBAAe,GAAAuB,OAAAuG,EAAA,CAFAE,IAGfvI,aAHeA,EAIfa,KAAMiH,IAGV,OAAAQ,ECnXF,IAAaE,EAAb,SAAAC,GAAA,SAAAD,IAAA,OAAAC,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAJ,EAAAC,GAAA,IAAA/I,EAAA8I,EAAA7I,UAAA,OAAAD,EAAA4E,UACEA,YACE,OADyDC,EAA/CC,WACO,WAAjB,QAFJ9E,EAAA2E,eAKEA,cACE,UANJmE,EAAA,CAAAK,uFCsDO,SAAAC,GAAAC,EAAAC,EAAAlC,GAKL,IAAM1F,EAAyB,CAC7BP,KAD6B,aAE7BR,YAAa,CAAA0I,EAAAC,IAETC,EAAKC,gBAAXpC,GACMqC,EAAYC,KAAmBH,EAArC7H,GACMiI,EAAcC,KAAOP,EAPfC,GAgBNO,GAHHzC,KAAkBiC,EAAnB,KAA6BC,KAAQD,EAArC,KAA+CjC,KAAkBiC,EAAnB,KAA6BC,KAAQD,EAbzE,IAgBcS,EAA0BH,EAA1BG,GAA6CH,EAhB3D,IAoBNI,EAAKC,KAAWV,EAAAG,EAAtBI,GACMI,EAAKD,KAAWX,EAAAI,EAAtBI,GAEA,MAAO,CAACE,WAADpJ,YAA0BsJ,WAAjCtJ,aCxEF,IAAauJ,GAAb,SAAAnB,GAAA,SAAAmB,IAAA,OAAAnB,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAgB,EAAAnB,GAAA,IAAA/I,EAAAkK,EAAAjK,UAAA,OAAAD,EAAA2E,eAGEA,cAA6E,IAAAwF,EAAApK,KACvEsI,EAAJ,GACQhI,EAAaN,KAAAD,kBAFsDI,YAAAG,SAI3E0F,EAAoBhG,KAApBwD,4BAAAyC,EAAAC,MAAAC,QAAAH,GAAAI,EAAA,MAAAJ,EAAAC,EAAAD,IAAAK,OAAAC,cAAsD,KAAAxB,EAAA,GAAAmB,EAAA,IAAAG,GAAAJ,EAAAzE,OAAA,MAAAuD,EAAAkB,EAAAI,SAAA,KAAAA,EAAAJ,EAAAQ,QAAAC,KAAA,MAAA3B,EAAAsB,EAAAM,MAAA,IAA3CtB,EAA2CN,EACpD,GAAIM,EAAQ9E,EAAZiB,OAA6B,KAAA8I,EACnBhK,EAAaC,EADMgK,GAAAjK,UAE3BgK,EAAA/B,GAAAnB,KAAA8B,MAAAoB,EAAgBjC,EAAyB/H,EAAzCiK,SAEAxD,oDADKwD,GAMT,GAAIrF,GAASA,EAATA,QAAJoC,EAA2C,CACzC,IAIMkD,GAJqBtF,EAAA4C,KACzB,SAAAC,GAAI,OAAIA,mBAAwBA,EAAxBA,QAAJ,aAA2CA,iBAGJ7C,EAAA4C,KAAW,SAAAC,GAAI,OAAKA,EAALC,kBAG5D,GACEwC,IACCA,gCADDA,UAEAvK,KAAAwD,4BAAAgH,SAA0CD,EAH5CnF,OAIE,CACA,IAAIqF,EAAJ,KACI7B,EAAJ,GACM8B,EAAiBjB,gBAHvBpC,GAwBA,GDzBD,SAAAsD,EAAAC,EAAAC,EAAAC,GAKL,IAAK5E,cAAc0E,EAAnB,IACE,SAEF,IAAK,IAAI9B,EAAT,EAAgBA,EAAI8B,EAApBrJ,OAAkCuH,IAChC,GAAI6B,EAAgCC,EAAD9B,GAAA,GAAAzG,OAAAwI,EAAA,CAAA/B,IAAnCgC,GAAmE,CACjEA,EAAEF,EAAFE,GACA,MAGJ,SCRMH,CACEJ,kBAD6B3J,YAAA,GAG7B,SAAAe,EAAAkJ,GACE,IAAME,EAAoBC,qBAA1BrJ,GACMsJ,EAA6Bb,EAAAc,mBAAAH,EAAnCL,KAKED,GACAQ,kBAA6CR,aAF/CU,QAIEV,IACA7B,OAKN6B,EAAuB,KAAAW,EAAAX,EAEMlC,EAFN6C,EAAA/K,SAAAO,YAGLwE,EAHKgG,EAAA3F,WAAAL,MAKrBkD,EAAO,GAAAjG,OAAAiG,EAAA,CAEL,CACEC,SADFA,EAEEzH,gBAAe,GAAAuB,OAAAuG,EAAA,CAA2BxD,EAF5C,IAGE7E,aAAcgK,EAHhBnF,MAIEhE,KAAM,oBAOhB,OAAAkH,GAvEJrI,EAAAiL,mBA2EEA,cAEE,OAAOA,KAAkBG,EAAzBC,IA7EJrL,EAAAiH,YAgFEA,YACE,IAAIK,EAAJ,KAEMgE,EAAoB5D,EAAoBP,EAA9CnC,OAEA,GAAIsG,GAAqBA,gBAAzB,EACE,gBAAIA,OAAuC,CACzC,IAAA/F,EACA,IACEA,EAAcxF,KAAAoD,gCAAAnC,eACIsK,EADJhL,aACoCgL,EADpCzK,iBAAd0E,YAGA,MAAAgG,IAIFhG,IACE+B,EAAa,CACX/B,YADWA,EAEXE,SAFW,iBAGXC,eAAgB,CAAC4F,EAHNhL,cAIXqF,YAAa,CACX9E,gBAAiByK,EADNzK,gBAEXyH,SAAUgD,EAAkBhD,iBAI7B,oBAAIgD,OAA2C,CACpD,IAAM/F,EAAcxF,KAAAoD,gCAAAnB,YAEhBsJ,EAFgBhL,aAGhBgL,EAHgBzK,gBAIhByK,EAJgBhD,UAApBpI,YAQAsL,IACElE,EAAa,CACX/B,YADWiG,EAEX/F,SAFW,cAGXC,eAAgB,CAAC4F,EAHNhL,cAIXqF,YAAa,CACX9E,gBAAiByK,EADNzK,gBAEXyH,SAAUgD,EAAkBhD,YAMtC,OAAAhB,GAjIJtH,EAAAqH,kBAoIEA,YACEtH,KAAA0L,sBAA6BtE,EAA7BnC,MAEA,IAAIsC,EAAJ,KAEMoE,EAAahE,EAAoBP,EAAvCwE,kBAEIxE,cAAJuE,IAKEpE,EAAa,CACX/B,YALkBxF,KAAAoD,gCAAAhD,gBACDuL,EADCpL,aACwBoL,EADxB7K,gBACoDsG,EADpDC,cAApBlH,YAMEuF,SAFW,eAGXC,eAAgB,CAACgG,EAHNpL,cAIXqF,YAAa,CACX9E,gBAAiB6K,EADN7K,gBAEXyH,SAAUnB,EAAMC,gBAQtB,MAAO,CAAEE,WAAFA,EAAcC,aAFAqE,QAArBF,KA5JJ1L,EAAAwH,oBAiKEA,YACE,IAAIF,EAAJ,KAEMuE,EAAyB9L,KAA/BwD,4BAEMmI,EAAahE,EAAoBP,EAAvCnC,OACI6G,aAAJ,iBAAmDH,SAKjDpE,EAAa,CACX/B,YALkBxF,KAAAoD,gCAAAnB,YACL0J,EADKpL,aACoBoL,EADpB7K,gBACgDsG,EADhDC,cAApBlH,YAMEuF,SAFW,cAGXC,eAAgB,CAACgG,EAHNpL,cAIXqF,YAAa,CACX9E,gBAAiB6K,EADN7K,gBAEXyH,SAAUnB,EAAMC,gBAKtB,OAAAE,GAvLJtH,EAAAyH,mBA0LEA,YACE,IAAIH,EAAJ,KAEMuE,EAAyB9L,KAA/BwD,4BACMmI,EAAahE,EAAoBP,EAAvCnC,OACI6G,UAAJH,IAKEpE,EAAa,CACX/B,YALkBxF,KAAAoD,gCAAAhD,gBACDuL,EADCpL,aACwBoL,EADxB7K,gBACoDsG,EADpDC,cAApBlH,YAMEuF,SAFW,qBAGXC,eAAgB,CAACgG,EAHNpL,cAIXqF,YAAa,CACX9E,gBAAiB6K,EADN7K,gBAEXyH,SAAUnB,EAAMC,gBAKtB,OAAAE,GA/MJtH,EAAA4E,UAkNEA,YAA2D,IAA/CE,EAA+CI,EAA/CJ,WACJE,EAAQjF,KAAd0L,sBAEA,GAAIzG,GAASA,SAAb,GACuBA,EAAAI,KAAW,SAAAyC,GAAI,OAAIA,EAAJC,kBAElC,aAIJ,OAAOhD,EAAU,WAAjB,QA5NJoF,EAAA,CAAAf,GCRa2C,GAAb,SAAAC,GAAA,SAAAD,IAAA,OAAAC,EAAA/C,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAA4C,EAAAC,GAAA,IAAA/L,EAAA8L,EAAA7L,UAAA,OAAAD,EAAAgM,kBACEA,cAA2F,IAAAnH,EACxD9E,KAAA+C,aADwD,GAAAmJ,EAAApH,EAAAqH,IACjFA,OADiF,IAAAD,EAAA,EAAAA,EAAAE,EAAAtH,EAAAuH,IACxEA,OADwE,IAAAD,EAAA,IAAAA,EAGhFE,EAAQtM,KAAAkE,SAAAqI,SAAAC,QAA+B,CAACjE,EAAD,GAAcA,EAAd,GAHyC,OAIhFkE,EAAQzM,KAAAkE,SAAAqI,SAAAC,QAA+B,CAACjE,EAAD,GAAcA,EAAd,GAJyC,SAOrF5F,EAAY,KAAE2J,EAFJlF,EAL2EsF,aAAA,KAOhDJ,EAAzCG,GAIA,OAHA9J,EAAYgK,WAAZhK,GACAA,EAAYgK,WAAZhK,GAEOjC,OAAAC,OAAA,GAAAyG,EAAyB,CAC9BC,aAAc,CAACkB,EAAD,GAAcA,EAAd,GAAA5F,MAbpB1C,EAAAqH,kBAiBEA,YACE,IAAMqE,EAAahE,EAAoBP,EAAvCwE,kBACMrD,EAAWoD,EAAaA,EAAHpD,SAAyBnB,EAApDC,aACA,OAAA2E,EAAA9L,UAAAoH,kBAAAsF,KAAA5M,KAA+BA,KAAAiM,kBAAA7E,EAA/BmB,KApBJtI,EAAAyH,mBAuBEA,YACE,IAAMiE,EAAahE,EAAoBP,EAAvCnC,OACMsD,EAAWoD,EAAaA,EAAHpD,SAAyBnB,EAApDC,aACA,OAAA2E,EAAA9L,UAAAwH,mBAAAkF,KAAA5M,KAAgCA,KAAAiM,kBAAA7E,EAAhCmB,KA1BJtI,EAAA4E,UA6BEA,YACE,IAAIgI,EAAMb,EAAA9L,UAAA2E,UAAA+H,KAAA5M,KAAV8M,GAIA,MAHA,SAAID,IACFA,eAEFA,GAlCJd,EAAA,CAAAgB,ICIaC,GAAb,SAAAhE,GAME,SAAAgE,EAAAC,GAAkC,IAAA7C,EAAA,OAChCA,EAAApB,EAAA4D,KAAA5M,aACAkN,SAAAD,EAFgC7C,EANpCjB,IAAA6D,EAAAhE,GAAA,IAAA/I,EAAA+M,EAAA9M,UAAA,OAAAD,EAAAiD,qBAWEA,YACElD,KAAAkN,SAAAhK,qBAAAnD,IAZJE,EAAA2D,cAeEA,YACE5D,KAAA+C,YAAAc,EACA7D,KAAAkN,SAAAtJ,cAAAC,IAjBJ5D,EAAA8D,0BAoBEA,YACE/D,KAAAkN,SAAAnJ,0BAAAC,IArBJ/D,EAAAgE,iBAwBEA,YACE+E,EAAA9I,UAAA+D,iBAAA2I,KAAA5M,KAAAmE,GACAnE,KAAAkN,SAAAjJ,iBAAAE,IA1BJlE,EAAAkN,sBA6BEA,cACE,OAAOzM,OAAAC,OAAA,GAAAyG,EAAyB,CAC9BC,aAD8B+F,EAE9BV,aAAc1M,KAAAkE,SAAAqI,SAAAC,QAFgBY,GAG9BC,wBAAyBrN,KAAKsN,gCAjCpCrN,EAAAsN,sBAqCEA,WAAwB,IAGhBC,EADaxN,KAAAkE,SAFGuJ,aAAAC,OAGR7F,KAAY,SAAA8F,GAAC,OAAIA,cAAJ,mBAC3B,OAAOH,EAAQA,EAAHI,GAAZ,IAzCJ3N,EAAA4N,oBA4CEA,YAA0D,IAChDnB,EAAiBtF,EAD+BsF,aAAAoB,GAEX9N,KAAA+C,aAFW,IAAAgL,WAEhDA,OAFgD,IAAAD,EAhD5D,EAgD4DA,EAUlDE,EAPQhO,KAAAkE,SAAAuJ,aAAAtJ,QAAA8J,KAAAC,oBAA4D,CACxEC,EAAGzB,EADqE,GAExE0B,EAAG1B,EAFqE,GAGxE2B,SAAU,CAACrO,KAH6DuN,yBAIxEe,OAJwEP,EAKxEQ,MAAO,IAEmB1G,KAC1B,SAAAC,GAAI,OAAIA,UAAJ,iBAAmBA,gBAEnBQ,EAAU,CAAE0F,oBAAqBA,GAAuBA,EAAoBhG,QAE5EwG,EAAe7G,EAAoBP,EAAzCwE,kBACA,OAAA4C,EACE9N,OAAAC,OAAA,GAAA2H,EAAA,CAAqBkG,iBAGvBlG,GAhEJrI,EAAAwO,4BAmEEA,YAAoD,IAC1CD,GAAiBxO,KAAA0O,kBADyB,IAAAF,aAGlD,GAAIA,GAAJjH,EAGE,IAH8B,IACtB5B,EAAgC4B,EADV5B,eACNH,EAAgB+B,EADV/B,YAGrBsD,EAAT,EAAgBA,EAAInD,EAApBpE,OAA2CuH,IAAK,CAC9C,IAAMpF,EAAgBiC,EAAtBmD,GACM1G,EAAiBoD,WAAvB9B,GAEQ5C,EAAkC0N,EAJI1N,gBAIrBP,EAAiBiO,EAJIjO,aAK9C,GAAImD,MAAsBnD,IAA1BmD,EAA0D,KAChD9C,EAAgBwB,EADgC/B,SAAAO,YAGxD4N,WAAwB1N,EAAA6N,OACtB,SAAAlG,EAAAC,GAAA,OAAyBD,EAAzBC,IADF8F,MAjFVvO,EAAA2O,+BA8FEA,WAA2C,IAAAC,EAAA7O,KACnCM,EAAQ,GAAA+B,OAAOrC,KAAAkN,SAAAnN,kBAAAI,YAArBG,UACQwO,GAAqB9O,KAAA+C,aAFY,IAAA+L,iBAIzC,GAAIA,GAAoBA,EAAxBvN,OAAiD,CAC/C,IAQMwN,EARsB/O,KAAAkE,SAAAuJ,aAAAC,OAAAsB,OAAyC,SAAAxB,GAKnE,OAJ4BsB,GAAoBA,WAA0BtB,EADEI,KAK9CJ,OAAaqB,EAA3CxK,WAGmCZ,IAC9B,SAAAwL,GAAU,OAAIA,QAAJC,OADoBP,OAE3B,SAAAlG,EAAAC,GAAA,SAAArG,OAAAoG,EAAAC,IAFV,IAIApI,kBAEF,OAAAA,GAjHJL,EAAAkP,iCAoHEA,WAIE,IAHA,IAAM7G,EAAN,GACMhI,EAAWN,KAAjB4O,iCAES9F,EAAT,EAAgBA,EAAIxI,EAApBiB,OAAqCuH,IAAK,CAKxC,GAFEA,EAAIxI,EAAJwI,SAAwB9I,KAAAkN,SAAA1J,4BAAAgH,SAD1B1B,GAGsC,KAC5BzI,EAAaC,EADewI,GAAAzI,SAEpCiI,eAAgBF,EAAyB/H,EAAAyI,EAAzCR,kBAGJ,OAAAA,GAlIJrI,EAAA2E,eAwIEA,cAAsE,IAC5DwK,GAAmBpP,KAAA+C,aADyC,IAAAqM,eAE9D9G,EAAUtI,KAAAkN,SAAAtI,eAAAK,EAAhBoC,GAEA,IAAA+H,EAAqB,OAAA9G,EAJ+C,IAK5DkG,GAAiBxO,KAAA0O,kBAL2C,IAAAF,aAOpE,GAAAA,EAEE,OADAlG,eAAgBtI,KAATmP,mCAAA9M,OAAA,CAAPiG,KACAA,EATkE,IAY5DhI,EAAaN,KAAAkN,SAAAnN,kBAZ+CI,YAAAG,SAapE0F,EAAoBhG,KAAAkN,SAApB1J,4BAAAyC,EAAAC,MAAAC,QAAAH,GAAAI,EAAA,MAAAJ,EAAAC,EAAAD,IAAAK,OAAAC,cAA+D,KAAA+I,EAAA,GAAApJ,EAAA,IAAAG,GAAAJ,EAAAzE,OAAA,MAAA8N,EAAArJ,EAAAI,SAAA,KAAAA,EAAAJ,EAAAQ,QAAAC,KAAA,MAAA4I,EAAAjJ,EAAAM,MAAA,IAApDtB,EAAoDiK,EAC7D,GAAIjK,EAAQ9E,EAAZiB,OAA6B,KACnBlB,EAAaC,EADM8E,GAAA/E,SAE3BiI,eAAgBF,EAAyB/H,EAAA+E,EAAzCkD,UAIJ,OAAOA,SAAPuD,UA5JJ5L,EAAAqP,uBA+JEA,WACE,IAAItP,KAAJuP,WAAA,CADuB,IAAAC,EAEuBxP,KAAA0O,kBAFvB,GAEfF,EAFegB,EAAAhB,aAEDR,EAFCwB,EAAAxB,oBAGnBQ,GAAJR,IACEhO,KAAAuP,YAAA,KAnKNtP,EAAAwP,yBAyKEA,WACOzP,KAALuP,cAEgCvP,KAAA0O,kBAHP,IAAAV,sBAKvBhO,KAAAuP,YAAA,KA9KNtP,EAAAyP,mBAkLEA,YAA0C,IAChC1B,GAAwBhO,KAAA0O,kBADQ,IAAAV,oBAGxC,OAAOA,GAAuBA,EAAvBA,SACHhO,KAAAmN,sBAAA/F,EAAkC4G,EAD/BA,UAAP5G,GArLJnH,EAAAwH,oBA0LEA,YAEE,OADAzH,KAAAsN,8BAAqC3F,EAAoBP,EAApBO,QAAD,IAApCY,SACOvI,KAAAkN,SAAAzF,oBAAPL,IA5LJnH,EAAAyH,mBA+LEA,YACE,IAAMiI,EAAoB3P,KAAAkN,SAAAxF,mBAAiC1H,KAAA0P,mBAA3DtI,IAIA,OAFApH,KAAA0O,iBAAA,KACA1O,KAAAuP,YAAA,EACAI,GApMJ1P,EAAA4E,UAuMEA,YACE,OAAO7E,KAAAkN,SAAArI,UAAPuC,IAxMJnH,EAAAqH,kBA2MEA,aAC6BtH,KAAAkN,SAAAvJ,iBADkE,IAAAyL,iBAI3FpP,KAAA0O,iBAAwB1O,KAAA6N,oBAAxBzG,GACIpH,KAAJ0O,mBACE1O,KAAAsP,yBACAtP,KAAAyP,6BAIJ,IAAME,EAAoB3P,KAAAkN,SAAA5F,kBAAgCtH,KAAA0P,mBAA1DtI,IACQG,EAAeoI,EAZsEpI,WAiB7F,OAJAA,GACEvH,KAAAyO,4BAAAlH,GAGFoI,GA5NJ3C,EAAA,CAAA5D,aCAawG,GAAb,SAAA5G,GAAA,SAAA4G,IAAA,OAAA5G,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAyG,EAAA5G,GAAA,IAAA/I,EAAA2P,EAAA1P,UAAA,OAAAD,EAAAqH,kBAIEA,YACE,IAAIC,EAAJ,KAKA,OAHAvH,KAAA6P,gBACEhE,QAAQ7L,KAAR6L,2BAA0C7L,KAAAgF,kBAAuBoC,EADnEnC,OAGKjF,KAAD6P,iBAA0BzI,EAA9BiG,yBAKIjG,cAAoBpH,KAAxB8P,2BAEEvI,EAAavH,KAAA+P,mBACX3I,EADWiG,wBAEXjG,EAFWC,aAAbE,gBAOK,CAAEA,WAAFA,EAAcC,cAAc,IAZ1B,CAAED,WAAF,KAAoBC,cAAc,IAZ/CvH,EAAAwH,oBA2BEA,YACE,OAAKzH,KAAL6P,iBAIA7P,KAAA8P,yBAAgC9P,KAAhCuD,yCACA,MAJE,MA7BNtD,EAAAyH,mBAoCEA,YACE,IAAIH,EAAJ,KAYA,OAVIvH,KAAJ8P,2BAEEvI,EAAavH,KAAA+P,mBACX3I,EADWiG,wBAEXjG,EAFWC,aAAbE,cAKAvH,KAAA8P,yBAAA,MAGFvI,GAjDJtH,EAAA4E,UAoDEA,YAA2D,IAA/CE,EAA+CD,EAA/CC,WACV,OAAI/E,KAAJ6P,gBACE,OAEK9K,EAAU,WAAjB,QAxDJ9E,EAAA8P,mBA2DEA,gBAKE,IAAK/P,KAAL8P,yBACE,YAiBF,IAfA,IAAMxG,EAAKG,gBAAXuG,GACMzG,EAAKE,gBAAXwG,GAEMC,EAAgBC,IAAY7G,EAAlCC,GACM6G,EAAYC,KAAW/G,EAA7BC,GAEM+G,EAAgBC,aACpBvQ,KAD0C8P,yBAAAI,EAA5CE,GAMI5K,EAAcxF,KAAlBoD,gCAEMoN,EAAkBxQ,KAAxBwD,4BACSsF,EAAT,EAAgBA,EAAI0H,EAApBjP,OAA4CuH,IAAK,CAC/C,IAAMpF,EAAgB8M,EAAtB1H,GACM2H,EAAeH,WAArBxH,GACAtD,EAAcA,oBAA2CiL,EAAzDjL,UAGF,MAAO,CACLA,YAAaA,EADRrF,YAELuF,SAFKA,EAGLC,eAHK6K,EAIL5K,YAAa,OA5FnBgK,EAAA,CAAAxG,GCLasH,GAAb,SAAAC,GAAA,SAAAD,IAAA,OAAAC,EAAA1H,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAuH,EAAAC,GAAA,IAAA1Q,EAAAyQ,EAAAxQ,UAAA,OAAAD,EAAAwH,oBACEA,YACE,OAAKzH,KAAL6P,iBAIA7P,KAAA8P,yBAAgC9P,KAAhCuD,yCAEOvD,KAAA8P,yBACH9P,KAAA6F,yBAA8B7F,KAD3B8P,0BAAP,MALE,MAHN7P,EAAA4E,UAaEA,YAA2D,IAA/CE,EAA+CD,EAA/CC,WACV,OAAI/E,KAAJ6P,gBACE,OAEK9K,EAAU,WAAjB,QAjBJ2L,EAAA,CAAAE,mCCIaC,GAAb,SAAA7H,GAAA,SAAA6H,IAAA,OAAA7H,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAA0H,EAAA7H,GAAA,IAAA/I,EAAA4Q,EAAA3Q,UAAA,OAAAD,EAAAqH,kBAIEA,YACE,IAAIC,EAAJ,KAIA,OAFAvH,KAAA8Q,aAAoBjF,QAAQ7L,KAAR6L,wBAAuC7L,KAAAgF,kBAAuBoC,EAAlFnC,OAEKjF,KAAD8Q,cAAuB1J,EAA3BiG,yBAKIjG,cAAoBpH,KAAxB+Q,wBAEExJ,EAAavH,KAAAgR,gBACX5J,EADWiG,wBAEXjG,EAFWC,aAAbE,aAOK,CAAEA,WAAFA,EAAcC,cAAc,IAZ1B,CAAED,WAAF,KAAoBC,cAAc,IAX/CvH,EAAAwH,oBA0BEA,YACE,OAAKzH,KAAL8Q,cAIA9Q,KAAA+Q,sBAA6B/Q,KAA7BuD,yCACA,MAJE,MA5BNtD,EAAAyH,mBAmCEA,YACE,IAAIH,EAAJ,KAYA,OAVIvH,KAAJ+Q,wBAEExJ,EAAavH,KAAAgR,gBACX5J,EADWiG,wBAEXjG,EAFWC,aAAbE,WAKAvH,KAAA+Q,sBAAA,MAGFxJ,GAhDJtH,EAAA4E,UAmDEA,YAA2D,IAA/CE,EAA+CD,EAA/CC,WACV,OAAI/E,KAAJ8Q,aAEE,OAEK/L,EAAU,WAAjB,QAxDJ9E,EAAA+Q,gBA2DEA,gBAUE,IATA,IAAMC,EAANjB,EAEMkB,EAsBV,SAAAC,EAAAnB,EAAAC,GACE,IAAMmB,EAAWf,KAAWc,EAA5BnB,GAEA,OADiBK,KAAWc,EAA5BlB,GACAmB,EAzBgBC,CADGC,KAAatR,KAA9B+Q,uBAC8BE,EAA9BhB,GAEMsB,EAAkBC,aAAoBxR,KAAD+Q,sBAA3CG,GAEI1L,EAAcxF,KAAlBoD,gCAEMoN,EAAkBxQ,KAAxBwD,4BACSsF,EAAT,EAAgBA,EAAI0H,EAApBjP,OAA4CuH,IAAK,CAC/C,IAAMpF,EAAgB8M,EAAtB1H,GACM2H,EAAec,WAArBzI,GACAtD,EAAcA,oBAA2CiL,EAAzDjL,UAGF,MAAO,CACLA,YAAaA,EADRrF,YAELuF,SAFKA,EAGLC,eAHK6K,EAIL5K,YAAa,OA/EnBiL,EAAA,CAAAzH,iBCAaqI,GAAb,SAAAzI,GAAA,SAAAyI,IAAA,OAAAzI,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAsI,EAAAzI,GAAA,IAAA/I,EAAAwR,EAAAvR,UAAA,OAAAD,EAAAqH,kBAIEA,YACE,IAAIC,EAAJ,KAIA,OAFAvH,KAAA0R,YAAmB7F,QAAQ7L,KAAR6L,uBAAsC7L,KAAAgF,kBAAuBoC,EAAhFnC,OAEKjF,KAAD0R,aAAsBtK,EAA1BiG,yBAKIjG,cAAoBpH,KAAxB2R,uBAEEpK,EAAavH,KAAA4R,eACXxK,EADWiG,wBAEXjG,EAFWC,aAAbE,YAOK,CAAEA,WAAFA,EAAcC,cAAc,IAZ1B,CAAED,WAAF,KAAoBC,cAAc,IAX/CvH,EAAAwH,oBA0BEA,YACE,OAAKzH,KAAL0R,aAIA1R,KAAA2R,qBAA4B3R,KAA5BuD,yCACA,MAJE,MA5BNtD,EAAAyH,mBAmCEA,YACE,IAAIH,EAAJ,KAQA,OANIvH,KAAJ2R,uBAEEpK,EAAavH,KAAA4R,eAAoBxK,EAApBiG,wBAAmDjG,EAAnDC,aAAbE,UACAvH,KAAA2R,qBAAA,MAGFpK,GA5CJtH,EAAA4E,UA+CEA,YAA2D,IAA/CE,EAA+CD,EAA/CC,WACV,OAAI/E,KAAJ0R,YAEE,OAEK3M,EAAU,WAAjB,QApDJ9E,EAAA2R,eAuDEA,gBAWE,IAVA,IAAMX,EAANjB,EACMmB,EAAWG,KAAatR,KAA9B2R,sBACME,EAuBV,SAAAV,EAAAnB,EAAAC,GACE,IAAM6B,EAAgB3B,IAAYgB,EAAlCnB,GAEA,OADoBG,IAAYgB,EAAhClB,GACA6B,EA1BiBC,CAAcZ,EAAAF,EAA7BhB,GACM+B,EAAiBC,aAAmBjS,KAAD2R,qBAAAE,EAAoC,CAC3EK,OAAQf,IAGN3L,EAAcxF,KAAlBoD,gCAEMoN,EAAkBxQ,KAAxBwD,4BACSsF,EAAT,EAAgBA,EAAI0H,EAApBjP,OAA4CuH,IAAK,CAC/C,IAAMpF,EAAgB8M,EAAtB1H,GACM2H,EAAeuB,WAArBlJ,GACAtD,EAAcA,oBAA2CiL,EAAzDjL,UAGF,MAAO,CACLA,YAAaA,EADRrF,YAELuF,SAFKA,EAGLC,eAHK6K,EAIL5K,YAAa,OA5EnB6L,EAAA,CAAArI,GCJA,IAAa+I,GAAb,SAAAnJ,GAAA,SAAAmJ,IAAA,OAAAnJ,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAAgJ,EAAAnJ,GAAAmJ,EAAAjS,UAAAgH,YACEA,YAAuD,IAC/C7G,EAAW,CACfe,KADe,QAEfR,YAHmDkE,EAAzCuC,cAMZ,OAAOrH,KAAAsF,oBAAPjF,IAPJ8R,EAAA,CAAA/I,GCCagJ,GAAb,SAAApJ,GAAA,SAAAoJ,IAAA,OAAApJ,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAiJ,EAAApJ,GAAA,IAAA/I,EAAAmS,EAAAlS,UAAA,OAAAD,EAAAiH,YACEA,YACE8B,EAAA9I,UAAAgH,YAAA0F,KAAA5M,KAAAoH,GAEA,IAAIG,EAAJ,KACMuE,EAAyB9L,KAA/BwD,4BACM6O,EAAmBrS,KAAzBsD,sBACMqB,EAAmB3E,KAAzByE,sBACM6N,EAAgBtS,KAAtBuE,mBAEA,GACEuH,YACCuG,GAFH,eAEuBA,OAIrB,OAFAvL,aADA,sEAEA9G,KAAAwE,qBACA,KAGF,GAAI6N,GAAJ,eAAwBA,OAAwC,CAE9D,IAEIvR,EAAkB,CAFtBuR,EAEuB1Q,YAAvBJ,QAEMsC,EAAa7D,KAAnB2D,gBACIE,GAAcA,EAAlB0O,cACEzR,EAAkB,CAAlBA,IAEF,IAAMP,EAAeuL,EAArB,GAKAvE,EAAa,CACX/B,YALkBxF,KAAAoD,gCAAAnB,YAAA1B,EAAAO,EAC0BsG,EAD1BC,cAApBlH,YAMEuF,SAFW,cAGXC,eAAgB,CAHLpF,GAIXqF,YAAa,CACX9E,gBADWA,EAEXyH,SAAUnB,EAAMC,eAIpBrH,KAAAwE,0BACK,GAAI8N,cAAJ3N,EAAoD,CAEzD,IAAMtE,EAAgBsE,EAAtBtE,SACAkH,EAAavH,KAAAsF,oBAAbiC,GAEAvH,KAAAwE,qBAGF,OAAA+C,GArDJtH,EAAAqH,kBAwDEA,YACE,IAAMkL,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAE3C8K,EAAgBtS,KAAtBuE,mBACM8C,EAAeD,EAArBC,aAEI4J,EAAJ,KACMnF,EAAyB9L,KAA/BwD,4BACM6O,EAAmBrS,KAAzBsD,sBAEA,GACEwI,YACCuG,GAFH,eAEuBA,OAGrB,OAAAG,EAGF,GAAIH,GAAJ,eAAwBA,OAAwC,CAE9DpB,EAAgBoB,cAA6BA,qBAA7CpB,GAEA,IAAMpN,EAAa7D,KAAnB2D,gBACIE,GAAcA,EAAlB0O,cACEtB,EAAgBoB,cAAhBpB,SAEG,IAAIqB,WACTrB,EAAgBqB,EAAhBrB,IAcF,OAXAA,GACEjR,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBqE,WAFwB,GAGxBpF,SAAU,CACRe,KADQ,aAERR,YAAa,CAAAqQ,EAAA5J,MAKnBmL,GAjGJJ,EAAA,CAAAhJ,GCAaqJ,GAAb,SAAAzJ,GAAA,SAAAyJ,IAAA,OAAAzJ,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAsJ,EAAAzJ,GAAA,IAAA/I,EAAAwS,EAAAvS,UAAA,OAAAD,EAAA2E,eACEA,cACE,IAAI0D,EAAOU,EAAA9I,UAAA0E,eAAAgI,KAAA5M,KAAAiF,EAAXoC,GAcA,OAZIrH,KAAJ0E,oBACE4D,EAAUA,SAAeF,EAA0BpI,KAAA0E,kBAADrE,UADxB,IAGtBL,KAAA0E,mBAAJ,eAA8B1E,KAAA0E,kBAAArE,SAAAe,KAE5BkH,EAAUA,WAAVA,GACStI,KAAA0E,mBAAJ,YAA8B1E,KAAA0E,kBAAArE,SAAAe,OAEnCkH,EAAUA,WAAVA,KAIJA,GAhBJrI,EAAAiH,YAmBEA,YACE8B,EAAA9I,UAAAgH,YAAA0F,KAAA5M,KAAAoH,GAD0C,IAGlCnC,EAAUmC,EAHwBnC,MAIpCN,EAAmB3E,KAAzByE,sBAEI8C,EAAJ,KACMgE,EAAoB5D,EAA1B1C,GAEA,GAAAsG,EAAuB,CAGrB,IAAM+G,EAAgBtS,KAAtBuE,mBACA+N,SAAqBA,SAArBA,KAGF,GAAI3N,GAAJ,YAAwBA,gBAA8C,CACpE,IAAMtD,EAAmBsD,EAAzBtE,SAEA,GACEkL,QACAA,iBACCA,0BACCA,uBAAyClK,wBAJ7C,GAKE,CAIA,IAAMqR,EAAwB,CAC5BtR,KAD4B,UAE5BR,YAAa,IAAAyB,OAAKhB,0BAAL,IAA0CA,iBAA1C,OAGfrB,KAAAwE,qBACAxE,KAAA8D,qBAAA,MACAyD,EAAavH,KAAA2G,oCAAbY,IAKJ,IAAMoL,EAAuB,CAC3BjG,aAAc,KADa,GAE3BrF,aAAcD,EAFaC,aAG3BpC,MAH2B,GAI3BF,YAJ2B,EAK3B6G,iBAL2B,KAM3BgH,wBAN2B,KAO3BvF,wBAP2B,KAQ3BwF,YAAa,MAIf,OAFA7S,KAAAsH,kBAAAqL,GAEApL,GAvEJtH,EAAAqH,kBA0EEA,YAEyE,IADvED,EACuEvC,EADvEuC,aAEMiL,EAAgBtS,KAAtBuE,mBACMiO,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAEjD,WAAI8K,SAEFE,GAGEF,SAAJ,EAEEtS,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,aAERR,YAAW,GAAAyB,OAAAiQ,EAAA,CAAAjL,OAKfrH,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,UAERR,YAAa,IAAAyB,OAAAiQ,EAAA,CAAAjL,EAAkCiL,EAAlC,SAKnBE,IAzGJC,EAAA,CAAArJ,wBCMa0J,GAAb,SAAA9J,GAAA,SAAA8J,IAAA,OAAA9J,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAA2J,EAAA9J,GAAA,IAAA/I,EAAA6S,EAAA5S,UAAA,OAAAD,EAAA2E,eACEA,cACE,IAAI0D,EAAOU,EAAA9I,UAAA0E,eAAAgI,KAAA5M,KAAAiF,EAAXoC,GAEM1C,EAAmB3E,KAAzByE,sBAaA,OAZAE,IACE2D,EAAUA,SAAeF,EAA0BzD,EAADtE,UAD9B,IAGhBsE,GAAJ,eAAwBA,gBAEtB2D,EAAUA,WAAVA,GACS3D,GAAJ,YAAwBA,kBAE7B2D,EAAUA,WAAVA,KAIJA,GAjBJrI,EAAAqH,kBAoBEA,YAEyE,IADvED,EACuEvC,EADvEuC,aAEMiL,EAAgBtS,KAAtBuE,mBACMiO,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAEjD,OAAI8K,SAEF,OAAAE,EAGF,IASAxI,EATMrF,EAAmB3E,KAAzByE,uBACIE,GAAJ,YAAwBA,gBACtB2N,EAAcA,SAAdA,GACE3N,0BAAyC2N,SAD3CA,GAES3N,GAAJ,eAAwBA,kBAC7B2N,EAAcA,SAAdA,GACE3N,uBAAsC2N,SADxCA,IAKF,IAAIA,UACFtI,IAICA,EAAMX,GAFIiJ,EAAcA,SAAzB,GACWA,EAAcA,SAAzB,GAFKjL,GAAA,GA0BP,OApBIiL,SAAJ,EAEEtS,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,aAERR,YAAW,GAAAyB,OAAAiQ,EAAA,CAAAtI,OAKfhK,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,UAERR,YAAa,IAAAyB,OAAAiQ,EAAA,CAAAtI,EAAwBsI,EAAxB,SAKnBE,GArEJvS,EAAAiH,YAwEEA,YACE8B,EAAA9I,UAAAgH,YAAA0F,KAAA5M,KAAAoH,GAD0C,IAGlCnC,EAAUmC,EAHwBnC,MAIpCN,EAAmB3E,KAAzByE,sBAEI8C,EAAJ,KACMgE,EAAoB5D,EAA1B1C,GAEA,GAAIN,GAAJ,YAAwBA,gBAA8C,CACpE,IAAMtD,EAAmBsD,EAAzBtE,SAEA,GACEkL,QACAA,iBACCA,0BACCA,uBAAyClK,wBAJ7C,GAKE,CAEA,IAAMqR,EAAwB,CAC5BtR,KAD4B,UAE5BR,YAAaZ,KAAA+S,qBAAA,GAAA1Q,OAA8BhB,cAA9B,MAGfrB,KAAAwE,qBACAxE,KAAA8D,qBAAA,MACAyD,EAAavH,KAAA2G,oCAAbY,IAKJ,IAAMoL,EAAuB,CAC3BjG,aAAc,KADa,GAE3BrF,aAAcD,EAFaC,aAG3BpC,MAH2B,GAI3BF,YAJ2B,EAK3B6G,iBAL2B,KAM3BgH,wBAN2B,KAO3BvF,wBAP2B,KAQ3BwF,YAAa,MAIf,OAFA7S,KAAAsH,kBAAAqL,GAEApL,GAnHJtH,EAAA8S,qBAsHEA,YAEE,IAAInS,EAAc,IAAAyB,OAAK2Q,WAAL,IAA0BA,EAA5C,MACIxJ,EAAKxJ,KAAAiT,qBAAA,GAAA5Q,OAAT2Q,IACA,GAAAxJ,EAUE5I,EAAc,IAAAyB,OAAK2Q,WAAL,IAAAxJ,EAA8BwJ,EAA5CpS,UAVO,CAGP,IAAMsS,EAAE,GAAA7Q,OAAR2Q,GACAE,gBACA1J,EAAKxJ,KAAAiT,qBAAA,GAAA5Q,OAALmH,OAEE5I,EAAc,IAAAyB,OAAK2Q,WAAL,IAAAxJ,EAA8BwJ,EAA5CpS,OAKJ,OAAAA,GAtIJX,EAAAgT,qBAyIEA,YACE,IAAAzJ,EACA,GAAI5I,SAAJ,EAA4B,KAAAuE,EAAA,GAAA9C,OAAAzB,GACnB0I,EADmBnE,EAAA,GACfoE,EADepE,EAAA,GAEpBgO,EAAStJ,KAAOP,EAAtBC,GACMS,EAAKpJ,EAAYA,SAAvB,GACMsJ,EAAKtJ,EAAYA,SAAvB,GACMwS,EAASvJ,KAAOG,EAAtBE,GAEMmJ,EAAS,CAAEC,MAAF,GAAaC,OAAQ,IAEpC,QAAAC,QAAkB,SAAA3B,GAChB,IAAM4B,EAAYN,EADQ,GACCtB,EAE3BwB,aAAkBI,MAAkBA,EAAlBA,IAAlBJ,GACA,IAAMK,EAAYN,EAAlB,GAA2BvB,EAC3BwB,cAAmBK,MAAkBA,EAAlBA,IAAnBL,KAGF,IAAMM,EAAWxD,IAAa1G,gBAADH,GAAYG,gBAjBfO,IAoB1B,QAAAwJ,QAAkB,SAAAI,GAChB,IAAMC,EAAQlS,qBAAW,CAAA2H,EAEvBW,KAAWX,EAAAqK,EAAeN,QAA1BpJ,aAFFrJ,cAIA,QAAA4S,QAAkB,SAAAM,GAChB,IAAMC,EAAQpS,qBAAW,CAAAqI,EAEvBC,KAAWD,EAAA2J,EAAeN,SAA1BpJ,aAFFrJ,cAIMoT,EAAKC,KAAaJ,EAAxBE,GACIC,GAAMA,WAAVzS,SAEEiI,EAAKwK,uBAALxK,iBAKR,OAAAA,GAjLJsJ,EAAA,CAAA1J,GCPa8K,GAAb,SAAAlL,GAAA,SAAAkL,IAAA,OAAAlL,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAA+K,EAAAlL,GAAAkL,EAAAhU,UAAAgH,YACEA,YACE8B,EAAA9I,UAAAgH,YAAA0F,KAAA5M,KAAAoH,GAEA,IAAMzC,EAAmB3E,KAAzByE,sBAGA,GAFsBzE,KAAtBuE,mBAGE+N,aADF,YAGE3N,gBACA,CACA,IAAM4C,EAAavH,KAAA2G,oCAAyChC,EAA5DtE,UAGA,OAFAL,KAAAwE,qBACAxE,KAAA8D,qBAAA,MACAyD,EAGF,aAlBJ2M,EAAA,CAAA9K,GCCa+K,GAAb,SAAAC,GAAA,SAAAD,IAAA,OAAAC,EAAAnL,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAAgL,EAAAC,GAAAD,EAAAjU,UAAAoH,kBACEA,YACE,IAAMkL,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAC3C8K,EAAgBtS,KAAtBuE,mBAEA,OAAI+N,SAEF,OAAAE,EAGF,IAAM6B,EAAU/B,EAAhB,GACMgC,EAAUlN,EAAhBC,aAGA,OAFArH,KAAA8D,qBAA0ByQ,IAAY,CAACF,EAAD,GAAaA,EAAb,GAAyBC,EAAzB,GAAqCA,EAA3E,MAEA9B,GAdJ2B,EAAA,CAAAK,8CCUaC,GAAb,SAAAzL,GAAA,SAAAyL,IAAA,OAAAzL,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAAmJ,IAAAsL,EAAAzL,GAAA,IAAA/I,EAAAwU,EAAAvU,UAAA,OAAAD,EAAAyU,sBACEA,cACE,IAAM7Q,EAAa7D,KAAnB2D,gBACA,IAAIE,IAAgBA,EAAhB8Q,eAA4CrC,EAAhD/Q,OACE,OAAA8F,EAEF,OAAIiL,SAA4B,CAE9B,IAAMsC,EAAatC,EAAnB,GACMD,EAAmBrS,KAAzBsD,sBACMd,EAAUqS,KAAhBxC,GAEMyC,EAAQtS,6BAAuCA,EAAvCA,SAA0D,CAAxEA,GACIuS,EAAcC,OAAlBC,iBACIC,EAR0B,KAmB9B,GATAJ,UAAc,SAAAzJ,GACZ,IAAM+B,EAAYlC,KAAkBG,EAApCuJ,GACMO,EAAqBhF,IAAY/C,EAAvCwH,GACIG,EAAJI,IACEJ,IACAG,OAIJA,EAAkB,CAEhB,IAAME,EAAc/E,KAAWuE,EAA/BM,GACMG,EAAkBlF,IAAYyE,EAAAvN,EAA2B,CAAEiO,MAAO,WACxE,OAAOC,KAAeX,EAAAS,EAAAD,EAA2C,CAC/DE,MAAO,WADFjV,SAAPO,YAIF,OAAAyG,EAGF,IAAMmO,EAAYlD,EAAcA,SAAhC,GACOmD,EAAoBpM,GACzBiJ,EAAcA,SAD6C,GAAAkD,EApCFnO,GAAA,GA4C3D,OAFkB6D,KAAmBvJ,qBAAW,CAAA6T,EAAZC,IAAlBvK,YAAlBtK,aA3CJX,EAAAiH,YAgDEA,YACE8B,EAAA9I,UAAAgH,YAAA0F,KAAA5M,KAAAU,OAAAC,OAAA,GAAAyG,EAAA,CAEEC,aAAcrH,KAAA0U,sBAA2B1U,KAA3BuE,mBAAoD6C,EAApDC,iBAEhB,IACM1C,EAAmB3E,KAAzByE,sBACM4N,EAAmBrS,KAAzBsD,sBACMgP,EAAgBtS,KAAtBuE,mBAEA,IAAA8N,EAIE,OAFAvL,yDACA9G,KAAA8D,qBAAA,MARF,KAWA,IAAM0F,EAAK,CACTpI,KADS,QAETR,YAAa0R,EAAcA,SAAD,IAEtBoD,EAAmBC,KAAqBnM,EAA9C6I,GACA,OAAIC,gBAAJoD,GACE1V,KAAAwE,qBAEA,IADqCyP,KAAatP,EAAlD0N,GACIuD,iBACF5V,KAAA8D,qBAAA,MApBJ,MAuBS9D,KAAP6V,gBAvBF,MArDJ5V,EAAAqH,kBAkFEA,YAEyE,IADvED,EACuEvC,EADvEuC,aAEMiL,EAAgBtS,KAAtBuE,mBACMiO,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAEjD,WAAI8K,SAEFE,GAGFxS,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,aAERR,YAAW,GAAAyB,OAAAiQ,EAAA,CAAqBtS,KAAA0U,sBAAApC,EAArBjL,QAIfmL,IArGJvS,EAAA4V,aAwGEA,WACE,IAAMxD,EAAmBrS,KAAzBsD,sBACMqB,EAAmB3E,KAAzByE,sBACMlE,EAAeP,KAAAwD,4BAArB,GACMK,EAAa7D,KAAA2D,iBAJN,GAAAmS,EAO8BjS,EAP9BkS,IAOPA,OAPO,IAAAD,EAAA,GAAAA,EAAAE,EAO8BnS,EAP9ByR,MAOIA,OAPJ,IAAAU,EAAA,cAAAA,EAQb,IAAID,IACFA,KACAT,iBAGF,IAAMW,EAASC,YAAUvR,EAAAoR,EAAwB,CAAET,UAC7C7U,EAAkBuG,YAAcqL,EAAtC4D,GAEA,GADAjW,KAAA8D,qBAAA,OACArD,EAGE,OADAqG,qDACA,KAnBW,IAAAqP,EAsBiB1V,EAtBjBJ,SAsBLe,EAtBK+U,EAAA/U,KAsBCR,EAtBDuV,EAAAvV,YAuBTwV,EAAJ,GA2BA,OAxBEA,EAFF,YAAIhV,EAEmBR,EAAA6C,IAAgB,SAAA4S,GAAC,MAAI,CAAJA,KAGjBzV,EAAA+N,OAAmB,SAAA2H,EAAAC,GAItC,OAHAA,UAAa,SAAAC,GACXF,OAAS,CAATA,MAEFA,GAJFF,IAc6B,CAC7B5Q,YANkBxF,KAAAoD,gCAAApC,gBAAAT,EAAmE,CACrFa,KADqF,eAErFR,YAAawV,IAGgBjW,YAE7BuF,SAF6B,QAG7BC,eAAgB,CAHapF,GAI7BqF,YAAa,OAvJnB6O,EAAA,CAAArL,GCXaqN,GAAb,SAAAzN,GAAA,SAAAyN,IAAA,OAAAzN,EAAAC,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAAsN,EAAAzN,GAAAyN,EAAAvW,UAAAgH,YACEA,YACE8B,EAAA9I,UAAAgH,YAAA0F,KAAA5M,KAAAoH,GAEA,IAAMzC,EAAmB3E,KAAzByE,sBAGA,GAFsBzE,KAAtBuE,mBAGE+N,aADF,YAGE3N,gBACA,CACA,IAAM4C,EAAavH,KAAA2G,oCAAyChC,EAA5DtE,UAGA,OAFAL,KAAAwE,qBACAxE,KAAA8D,qBAAA,MACAyD,EAGF,aAlBJkP,EAAA,CAAArN,GCEasN,GAAb,SAAAC,GAAA,SAAAD,IAAA,OAAAC,EAAA1N,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAAuN,EAAAC,GAAAD,EAAAxW,UAAAoH,kBACEA,YACE,IAAMkL,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAC3C8K,EAAgBtS,KAAtBuE,mBAEA,OAAI+N,SAEF,OAAAE,EAGF,IAAMnL,EAAeD,EAArBC,aAEA,OAAIiL,SACFtS,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,aAERR,YAAa,CAAC0R,EAAD,GAAAjL,WAGZ,OAAIiL,SAA4B,CACrC,IAAM3Q,EAAyB,CAC7BP,KAD6B,aAE7BR,YAAa0R,GAERhJ,EAAUgJ,EALoB,GAAAsE,EAMpBvN,GAAkCC,EADlCgJ,EALoB,GAAAjL,GAM9B2C,EAN8B4M,EAAA,GAM1B1M,EAN0B0M,EAAA,GAQrC5W,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,UAERR,YAAa,IAAAyB,OAKNV,EALMf,YAAA,CAAAoJ,EAAAE,EAAAZ,QAenB,OAAAkJ,GA/CJkE,EAAA,CAAAG,ICAaC,GAAb,SAAA1C,GAAA,SAAA0C,IAAA,OAAA1C,EAAAnL,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAA2N,EAAA1C,GAAA0C,EAAA5W,UAAAoH,kBACEA,YACE,IAAMkL,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAC3C8K,EAAgBtS,KAAtBuE,mBAEA,OAAI+N,SAEF,OAAAE,EAGF,IAT6FuE,GAS1E/W,KAAA2D,iBAT0E,IAAAqT,MAWrFA,OAXqF,IAAAD,EAAA,GAAAA,EAYvFE,EAAU,CAAED,SAEdA,EAAJ,IACElQ,aADa,wCAEbmQ,WAGF,IAAMC,EAAoB5E,EAA1B,GACMhE,EAAS3B,SAASgH,IAAQuD,EAAoB9P,EAArCuF,cAAf,MAGA,OAFA3M,KAAA8D,qBAA0BqT,IAAMD,EAAA5I,EAAhC2I,IAEAzE,GAxBJsE,EAAA,CAAAtC,ICCa4C,GAAb,SAAAhD,GAAA,SAAAgD,IAAA,OAAAhD,EAAAnL,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAAiO,EAAAhD,GAAAgD,EAAAlX,UAAAoH,kBACEA,YACE,IAAMkL,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAC3C8K,EAAgBtS,KAAtBuE,mBAEA,OAAI+N,SAEF,OAAAE,EAGF,IAT6FuE,GAS1E/W,KAAA2D,iBAT0E,IAAAqT,MAWrFA,OAXqF,IAAAD,EAAA,GAAAA,EAYvFE,EAAU,CAAED,SAEdA,EAAJ,IACElQ,aADa,wCAEbmQ,WAGF,IAAMI,EAAoB/E,EAA1B,GACM4E,EAAoBjP,EAAuBoP,EAAoBjQ,EAArEC,cACMiH,EAAS3B,SAASgH,IAAQ0D,EAAjB1K,GAAf,MAGA,OAFA3M,KAAA8D,qBAA0BqT,IAAMD,EAAA5I,EAAhC2I,IAEAzE,GAzBJ4E,EAAA,CAAA5C,cCEa8C,GAAb,SAAAlD,GAAA,SAAAkD,IAAA,OAAAlD,EAAAnL,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAAmO,EAAAlD,GAAAkD,EAAApX,UAAAoH,kBACEA,YACE,IAAMkL,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAC3C8K,EAAgBtS,KAAtBuE,mBAEA,OAAI+N,SAEF,OAAAE,EAGF,IAAM6B,EAAU/B,EAAhB,GACMgC,EAAUlN,EAAhBC,aAEMkQ,EAAO5K,SAAS0H,EAAT1H,GAAqB2H,EAAlC,IACMkD,EAAO7K,SAAS0H,EAAT1H,GAAqB2H,EAAlC,IACMmD,EAAO9K,SAAS0H,EAAT1H,GAAqB2H,EAAlC,IACMoD,EAAO/K,SAAS0H,EAAT1H,GAAqB2H,EAAlC,IAEMqD,EAAgBpD,IAAY,CAAAgD,EAAAC,EAAAC,EAAZlD,yBAAtB,GACM2C,EAAoBjP,EAAuBoM,EAAjDC,GAEMsD,EAAYjL,SAASgH,IAASlK,gBAAMkO,EAAP,IAA0BlO,gBAAMkO,EAAjDhL,KAAlB,MACMkL,EAAYlL,SAASgH,IAASlK,gBAAMkO,EAAP,IAA0BlO,gBAAMkO,EAAjDhL,KAAlB,MAIA,OAFA3M,KAAA8D,qBAA0BgU,aAAOZ,EAAAU,EAAjCC,IAEArF,GA1BJ8E,EAAA,CAAA9C,ICAauD,GAAb,SAAApB,GAAA,SAAAoB,IAAA,OAAApB,EAAA1N,MAAAjJ,KAAAkJ,YAAAlJ,KAAA,OAAAmJ,IAAA4O,EAAApB,GAAAoB,EAAA7X,UAAAoH,kBACEA,YACE,IAAMkL,EAAS,CAAEjL,WAAF,KAAoBC,cAAc,GAC3C8K,EAAgBtS,KAAtBuE,mBAEA,OAAI+N,SAEF,OAAAE,EAGF,IAAMnL,EAAeD,EAArBC,aAEA,OAAIiL,SACFtS,KAAA8D,qBAA0B,CACxB1C,KADwB,UAExBf,SAAU,CACRe,KADQ,aAERR,YAAa,CAAC0R,EAAD,GAAAjL,WAGZ,OAAIiL,SAA4B,KAC9BhJ,EAAUgJ,EADoB,GAC1B/I,EAAM+I,EADoB,GAG/B4E,EAAoBjP,EAAuBqB,EAAjDC,GACMqO,EAAYjL,SAASgH,IAAQuD,EAAoBzN,gBAArCkD,IAAlB,MACMkL,EAAYlL,SAASgH,IAAQrK,EAAjBqD,SAAlB,EACMsK,EAAU,CAAE/F,MAAOrH,KAAOP,EAAAC,IAEhCvJ,KAAA8D,qBAA0BgU,aAAOZ,EAAAU,EAAAC,EAAjCZ,IAGF,OAAAzE,GA/BJuF,EAAA,CAAAlB,ICFamB,GAAb,SAAAhM,GAAA,SAAAgM,IAAA,QAAA5N,EAAA6N,EAAA/O,UAAA3H,OAAA2W,EAAA,IAAAhS,MAAA+R,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAAD,EAAAC,GAAAjP,UAAAiP,GAAA,OAAA/N,EAAA4B,EAAAY,KAAA3D,MAAA+C,EAAA,CAAAhM,MAAAqC,OAAA6V,KAAAlY,MAAAoY,cAAA,EAAAhO,EAAAjB,IAAA6O,EAAAhM,GAAA,IAAA/L,EAAA+X,EAAA9X,UAAA,OAAAD,EAAAqH,kBAEEA,YACEtH,KAAA0L,sBAA6BtE,EAA7BnC,MAEA,IAAIsC,EAAJ,KAEMoE,EAAahE,EAAoBP,EAAvCwE,kBAEA,GAAIxE,cAAJuE,EAAoC,CAClC,IAAM0M,EAAOrY,KAAAsY,gBAAqB3M,EAArB7K,gBAAiD6K,EAA9DpL,cACMO,EAAkBd,KAAAoY,aACpBpY,KAAAuY,oBAAyB5M,EAAzB7K,gBADoBuX,GAEpB1M,EAJ8B7K,gBAM5BwI,EAAKtJ,KAAAwY,2BACTxY,KAAAyY,oBAAA3X,EADSuX,GAET1M,EAFFpL,cAIMgJ,EAAKvJ,KAAAwY,2BAAA1X,EAAiD6K,EAA5DpL,cACA,GAAI+I,GAAJC,EAAc,KAAAqN,EAEKvN,GAAkCC,EAAAC,EAASnC,EAFhDC,cAEL2C,EAFK4M,EAAA,GAED1M,EAFC0M,EAAA,GAaZrP,EAAa,CACX/B,YAVkBxF,KAAAoD,gCAAAhD,gBAEhBuL,EAFgBpL,aAGhBP,KAAAyY,oBAAA3X,EAHgBuX,GAAAnO,GAAA9J,gBAMDuL,EANCpL,aAAAO,EAAAkJ,GAApB7J,YAWEuF,SAFW,YAGXC,eAAgB,CAACgG,EAHNpL,cAIXqF,YAAa,CACX9E,gBAAiBd,KAAAuY,oBAAyB5M,EAAzB7K,gBADNuX,GAEX9P,SAAUyB,KASlB,MAAO,CAAEzC,WAAFA,EAAcC,aAFAqE,QAArBF,KA9CJ1L,EAAAwH,oBAmDEA,YACE,IAAIF,EAAJ,KAEMuE,EAAyB9L,KAA/BwD,4BAEMmI,EAAahE,EAAoBP,EAAvCnC,OACA,GAAI6G,aAAJ,iBAAmDH,OAAoC,CACrF,IAAM0M,EAAOrY,KAAAsY,gBAAqB3M,EAArB7K,gBAAiD6K,EADuBpL,cAG/E+I,EAAKtJ,KAAAwY,2BACTxY,KAAAyY,oBAAyB9M,EAAzB7K,gBADSuX,GAET1M,EAFFpL,cAIMgJ,EAAKvJ,KAAAwY,2BACT7M,EADS7K,gBAET6K,EAFFpL,cAKA,GAAI+I,GAAJC,EAAc,CACZ,IAAI/D,EAAcxF,KAAlBoD,gCACKpD,KAAA0Y,aAAkB/M,EAAlB7K,gBAA8C6K,EAA9CpL,aAAL8X,KACE7S,EAAcA,cACZmG,EADYnG,aAEZmG,EAFYnG,gBAAdA,IAOCxF,KAAA0Y,aACC1Y,KAAAyY,oBAAyB9M,EAAzB7K,gBADDuX,GAEC1M,EAFDpL,aADH8X,KAOE7S,EAAcA,cACZmG,EADYnG,aAEZmG,EAFYnG,gBAAdA,GAKAxF,KAAAoY,cAAA,GAGF7Q,EAAa,CACX/B,YAAaA,EADFrF,YAEXuF,SAFW,iBAGXC,eAAgB,CAACgG,EAHNpL,cAIXqF,YAAa,CACX9E,gBAAiB6K,EADN7K,gBAEXyH,SAAUe,KAMlB,OAAA/B,GAzGJtH,EAAAyH,mBA4GEA,YACE,IAAIH,EAAJ,KAEMuE,EAAyB9L,KAA/BwD,4BACMmI,EAAahE,EAAoBP,EAAvCnC,OACA,GAAI6G,UAAJH,EAAiD,CAC/C,IAAM0M,EAAOrY,KAAAsY,gBAAqB3M,EAArB7K,gBAAiD6K,EAA9DpL,cACMO,EAAkBd,KAAAoY,aACpBpY,KAAAuY,oBAAyB5M,EAAzB7K,gBADoBuX,GAEpB1M,EAJ2C7K,gBAMzCwI,EAAKtJ,KAAAwY,2BACTxY,KAAAyY,oBAAA3X,EADSuX,GAET1M,EAFFpL,cAIMgJ,EAAKvJ,KAAAwY,2BAAA1X,EAAiD6K,EAA5DpL,cAEA,GAAI+I,GAAJC,EAAc,KAAAoP,EAEKtP,GAAkCC,EAAAC,EAASnC,EAFhDC,cAEL2C,EAFK2O,EAAA,GAEDzO,EAFCyO,EAAA,GAaZpR,EAAa,CACX/B,YAVkBxF,KAAAoD,gCAAAhD,gBAEhBuL,EAFgBpL,aAGhBP,KAAAyY,oBAAA3X,EAHgBuX,GAAAnO,GAAA9J,gBAMDuL,EANCpL,aAAAO,EAAAkJ,GAApB7J,YAWEuF,SAFW,WAGXC,eAAgB,CAACgG,EAHNpL,cAIXqF,YAAa,CACX9E,gBAAiB6K,EADN7K,gBAEXyH,SAAUyB,KAOlB,OAFAhK,KAAAoY,cAAA,EAEA7Q,GAvJJtH,EAAAqY,gBA0JEA,cACE,IAAID,EAAJ,EAEMzX,EADUZ,KAAAoD,gCAAAjD,YAAAG,SAAhBC,GACyBiC,SAHsC5B,YAK/D,OAAIE,SAA8B,KACzB2H,EAAQ3H,EADiB,GACtB4H,EAAK5H,EADiB,GAE5BF,UAAsBA,KAA1BW,SACE8W,EAAOzX,QAAPyX,YAEG,KACE3P,EAAK5H,EADP,GAEDF,UAAsBA,KAA1BW,SACE8W,EAAOzX,KAAPyX,QAGJ,OAAAA,GA1KJpY,EAAA2Y,WA6KEA,cACE,IAAM1H,EAAQrH,KAAOP,EAArBC,GACA,OAAI2H,EAAJ,EACSvE,WAAW,IAAlBuE,GAEKvE,WAAPuE,IAlLJjR,EAAAyY,aAqLEA,gBACM5X,EAAgBA,SAAhBA,KAAgDuX,EAApD,IACEvX,EAAgBA,SAAhBA,MAEF,IAAM+X,EAAY7Y,KAAAwY,2BAChBxY,KAAAyY,oBAAA3X,EADgBuX,GAAlB9X,GAIMuY,EAAY9Y,KAAAwY,2BAChBxY,KAAAuY,oBAAAzX,EADgBuX,GAAlB9X,GAIM0P,EAAejQ,KAAAwY,2BAAA1X,EAArBP,GACMwY,EAAY/Y,KAAA4Y,WAAA3I,EAAlB4I,GACMG,EAAYhZ,KAAA4Y,WAAA3I,EAAlB6I,GACA,MAAO,uBAAAtO,SAAqCmC,SAASoM,EAArDC,KApMJ/Y,EAAAsY,oBAuMEA,cACE,IAAM/R,EAAI,GAAAnE,OAAVvB,GAIA,OAHI0F,EAAJjF,SACEiF,EAAKA,SAALA,GAAwBA,EAAKA,SAALA,KAA0B6R,EAA1B7R,IAAyCA,EAAKA,SAALA,GAAjEA,GAEFA,GA5MJvG,EAAAwY,oBA+MEA,cACE,IAAMlC,EAAI,GAAAlU,OAAVvB,GAIA,OAHIyV,EAAJhV,SACEgV,EAAKA,SAALA,GAAwBA,MAAKA,SAALA,GAA8B8B,EAA9B9B,EAAyCA,EAAKA,SAALA,GAAjEA,GAEFA,GApNJtW,EAAAuY,2BAuNEA,cACE,IAAAlP,EAEM1I,EADUZ,KAAAoD,gCAAAjD,YAAAG,SAAhBC,GACyBiC,SAHiD5B,YAK1E,OAAIE,SAA8B,KACzB2H,EAAW3H,EADc,GACtB4H,EAAQ5H,EADc,GACnBuV,EAAKvV,EADc,GAE5BF,UAAsBA,KAA1BW,SACE+H,EAAK1I,QAAL0I,QAEG,KACEZ,EAAQ5H,EADV,GACKuV,EAAKvV,EADV,GAEDF,UAAsBA,KAA1BW,SACE+H,EAAK1I,KAAL0I,IAGJ,OAAAA,GAvOJ0O,EAAA,CAAAjL,ICMqBkM,qGAEnBC,6BAIAC,8BAIAC,gCAIAC,+BAIAC,8BAMAC,2BACEvZ,KAAAwZ,SAAc,CACZC,oBAAqB,CAEnBC,gBAFmB,KAInB9N,iBAJmB,KAMnBgH,wBANmB,KAQnBvF,wBARmB,KAUnBtI,YAAY,QAKlB4U,yBACE3Z,KAAA4Z,4BAGFC,wBAA4C/U,EAA9BgV,MAA8BhV,EAAvBiV,YAEnB/Z,KAAA4Z,yBACA5Z,KAAAga,yBAGFJ,kCACM5Z,KAAAia,MAAAR,oBAAJC,kBACE1Z,KAAAmE,QAAA+V,GAAAC,OAAAC,oBAAA,cAEEpa,KAAAia,MAAAR,oBAAAC,gBAFFJ,eAIAtZ,KAAAmE,QAAA+V,GAAAC,OAAAC,oBAAA,cAEEpa,KAAAia,MAAAR,oBAAAC,gBAFFW,eAIAra,KAAAmE,QAAA+V,GAAAC,OAAAC,oBAAA,YAEEpa,KAAAia,MAAAR,oBAAAC,gBAFFY,aAIAta,KAAAmE,QAAA+V,GAAAC,OAAAC,oBAAA,WAEEpa,KAAAia,MAAAR,oBAAAC,gBAFFP,gBAKFnZ,KAAAia,MAAAR,oBAAAC,gBAAA,QAGFM,+BACEha,KAAAia,MAAAR,oBAAAC,gBAAiD,CAC/CJ,cAAetZ,KAAAua,eAAAC,KADgCxa,MAE/Cqa,cAAera,KAAAya,eAAAD,KAFgCxa,MAG/Csa,YAAata,KAAA0a,aAAAF,KAHkCxa,MAI/CmZ,cAAenZ,KAAA2a,eAAAH,KAAAxa,OAGjBA,KAAAmE,QAAA+V,GAAAC,OAAAS,iBAAA,cAEE5a,KAAAia,MAAAR,oBAAAC,gBAFFJ,eAIAtZ,KAAAmE,QAAA+V,GAAAC,OAAAS,iBAAA,cAEE5a,KAAAia,MAAAR,oBAAAC,gBAFFW,eAIAra,KAAAmE,QAAA+V,GAAAC,OAAAS,iBAAA,YAEE5a,KAAAia,MAAAR,oBAAAC,gBAFFY,aAIAta,KAAAmE,QAAA+V,GAAAC,OAAAS,iBAAA,WAEE5a,KAAAia,MAAAR,oBAAAC,gBAFFP,kBAMFwB,2BACE,IAAMjO,EAAe1M,KAAA6a,gBAArBzT,GACMC,EAAerH,KAAA8a,gBAArBpO,GACA1M,KAAAmZ,cAAmB,CACjB9R,aADiBA,EAEjBwL,YAAazL,OAIjBqT,2BACE,IAAM/N,EAAe1M,KAAA6a,gBAArBzT,GACMC,EAAerH,KAAA8a,gBAArBpO,GAEMzH,EAAQjF,KAAAmE,QAAA8J,KAAAC,oBAAsC,CAClDC,EAAGzB,EAD+C,GAElD0B,EAAG1B,EAF+C,GAGlD2B,SAAU,CAACrO,KAAA8Z,MAHuClM,IAIlDU,OAJkD,GAKlDC,MAAO,IAGTvO,KAAAwZ,SAAc,CACZC,oBAAmB/Y,OAAAC,OAAA,GACdX,KAAAia,MADcR,oBAAA,CAEjB7G,wBAFiBlG,EAGjBW,wBAHiBhG,EAIjBuE,iBAJiB3G,EAKjBF,YAAY,SAKlBwV,2BACE,IAAM7N,EAAe1M,KAAA6a,gBAArBzT,GACMC,EAAerH,KAAA8a,gBAArBpO,GAF4BqO,EAQxB/a,KAAAia,MARwBR,oBAK1B7N,EAL0BmP,EAAAnP,iBAM1BgH,EAN0BmI,EAAAnI,wBAO1BvF,EAP0B0N,EAAA1N,wBAUtBtI,EAAe/E,KAAAia,MAVOR,oBAAA1U,WAY5B6N,IAIM7N,GAAe/E,KAAAgb,mBAAApI,EAAnBlG,KAIE1M,KAAAoZ,gBAAqB,CACnBnU,MADmB2G,EAEnBc,aAFmBA,EAGnBrF,aAHmBA,EAInBuL,wBAJmBA,EAKnBvF,wBALmBA,EAMnBwF,YAAazL,IAGfrC,KACA/E,KAAAwZ,SAAc,CACZC,oBAAmB/Y,OAAAC,OAAA,GACdX,KAAAia,MADcR,oBAAA,CAEjB1U,kBAMR,IAAME,EAAQjF,KAAAmE,QAAA8J,KAAAC,oBAAsC,CAClDC,EAAGzB,EAD+C,GAElD0B,EAAG1B,EAF+C,GAGlD2B,SAAU,CAACrO,KAAA8Z,MAHuClM,IAIlDU,OAJkD,GAKlDC,MAAO,IAGTvO,KAAAsZ,cAAmB,CACjB5M,aADiBA,EAEjBrF,aAFiBA,EAGjBpC,MAHiBA,EAIjBF,WAJiBA,EAKjB6G,iBALiBA,EAMjBgH,wBANiBA,EAOjBvF,wBAPiBA,EAQjBwF,YAAazL,OAIjBsT,yBACE,IAAMhO,EAAe1M,KAAA6a,gBAArBzT,GACMC,EAAerH,KAAA8a,gBAArBpO,GAF0BuO,EAStBjb,KAAAia,MATsBR,oBAKxB7N,EALwBqP,EAAArP,iBAMxBgH,EANwBqI,EAAArI,wBAOxBvF,EAPwB4N,EAAA5N,wBAQxBtI,EARwBkW,EAAAlW,WAW1B6N,IAKA7N,EACE/E,KAAAqZ,eAAoB,CAClBpU,MADkB2G,EAElBc,aAFkBA,EAGlBrF,aAHkBA,EAIlBuL,wBAJkBA,EAKlBvF,wBALkBA,EAMlBwF,YAAazL,IAELpH,KAAAgb,mBAAApI,EAALlG,IACL1M,KAAAkZ,aAAkB,CAChBjU,MADgB2G,EAEhBc,aAFgBA,EAGhBrF,aAHgBA,EAIhBwL,YAAazL,IAIjBpH,KAAAwZ,SAAc,CACZC,oBAAmB/Y,OAAAC,OAAA,GACdX,KAAAia,MADcR,oBAAA,CAEjB7G,wBAFiB,KAGjBvF,wBAHiB,KAIjBzB,iBAJiB,KAKjB7G,YAAY,UAKlB8V,4BACE,MAAO,CACLK,UAAuBlb,KAAAmE,QAAA+V,GAAAC,OAAAgB,wBADlBhN,EAEL+M,UAAuBlb,KAAAmE,QAAA+V,GAAAC,OAAAgB,wBAFzB/M,MAMF0M,4BACE,OAAO9a,KAAAmE,QAAAoI,SAAA6O,UAAgC,CAAC1O,EAAD,GAAkBA,EAAzD,QAGFsO,iCACE,OACErO,SAAS0O,KAAmBC,EAA5B3O,IA1PN,GA2PMA,SAAS0O,KAAmBC,EAA5B3O,IA3PN,MAE2C4O,KA8P3CtC,6BCzOA,IAAMuC,GAAqB,OAA3B,KACMC,GAAqB,OAA3B,KACMC,GAA8B,aAApC,KACMC,GAA8B,aAApC,KACMC,GAAuC,SAA7C,KACMC,GAA2C,OAAjD,KACMC,GAAmC,WAAzC,KACMC,GAAN,EACMC,GAAN,EACMC,GAAN,EAEA,SAAAC,GAAAC,GACE,OAAQA,EAAR/a,MACE,eACE,OAAAwa,GACF,WACE,OAAAE,GACF,mBACA,QACE,OAAAD,IAgBN,IAAMO,GAAe,CACnBC,KADmB,SAInBC,OAAQ,aAERC,UANmB,EAOnBC,MAPmB,EAQnBC,QARmB,EASnBC,SATmB,EAUnBC,eAVmB,EAWnBC,mBAXmB,EAYnBC,mBAAoB7H,OAZDC,iBAanB6H,eAbmB,SAcnBC,kBAdmB,EAenBC,eAfmB,EAgBnBC,iBAhBmB,EAiBnBC,qBAjBmB,EAkBnBC,qBAAsBnI,OAlBHC,iBAmBnBmI,mBAnBmB,EAoBnBC,aAAc,SAAA7a,EAAA8a,EAAAjB,GAAA,OACZiB,EAAU5B,GADEF,IAEd+B,aAAc,SAAA/a,EAAA8a,EAAAjB,GAAA,OACZiB,EAAU3B,GADEF,IAEd+B,UAAW,SAAAC,GAAC,OACTA,GAAKA,EAALA,YAAqBA,aAAtBnP,QAA+CmP,GAAKA,EAALA,YAAqBA,aAApEpF,MADU,GAEZqF,aAAc,SAAAD,GAAC,OAAKA,GAAKA,EAALA,YAAqBA,aAAtBE,WAAJ,GACfC,iBAAkB,SAAApb,EAAA8a,EAAAjB,GAAA,OAChBiB,YAAcjB,EAAkB,GAAhCiB,GAAyC,GADzB,IAIlBO,0BAA2B,SAAAJ,EAAApB,GAAA,MAAa,GAAb,IAC3ByB,sBAAuB,SAAAL,EAAApB,GAAA,OAAAX,IACvBqC,sBAAuB,SAAAN,EAAApB,GAAA,OAAAV,IACvBqC,sBAAuB,SAAAP,EAAApB,GAAA,OAAcoB,GAAKA,EAALA,YAAqBA,aAAtBE,WAAb,GAEvBtV,eApCmB,QAqCnB4V,qBArCmB,GAsCnBC,qBAtCmB,GAyCnBC,2BAzCmB,EA0CnBC,wBA1CmB,EA2CnBC,2BA3CmB,EA4CnBC,+BA5CmB,EA6CnBC,+BA7CmB,EA8CnBC,wBA9CmBtC,GA+CnBuC,yBA3DF,SAAAtC,GACE,OAAQA,EAAR/a,MACE,eACE,OAAA2a,GACF,WACE,OAAAE,GACF,mBACA,QACE,OAAAD,KAsDJ0C,oBAlDmB,KAmDnBC,sBAnDmB,KAoDnBC,wBApDmB,EAqDnBC,kBAAmB,SAAA1C,GAAM,OAAIA,EAAJ/a,MACzB0d,sBAtDmB,GAuDnBC,uBAvDmB7C,GAwDnB8C,uBAxDmB,EA2DnBC,aAAc,CACZC,KAAM,IADMC,EAEZC,OAAQ,IAFIrS,GAGZpK,UAAW,IAHC0c,GAIZC,QAAS,IAJGC,GAKZC,OAAQ,IALIC,GAMZC,UAAW,IAAAC,GAAqB,IANpB/O,IAOZgP,UAAW,IAPCC,GAQZC,MAAO,IARKC,GASZC,UAAW,IATCC,GAUZC,eAAgB,IAVJC,GAWZC,YAAa,IAXDC,GAYZC,oBAAqB,IAZTC,GAaZC,MAAO,IAbKC,GAcZC,cAAe,IAdHC,GAeZC,0BAA2B,IAffC,GAgBZC,qBAAsB,IAhBVC,GAiBZC,wBAAyB,IAjBbC,GAkBZC,yBAA0B,IAlBdC,GAmBZC,wBAAyB,IAAAC,KAmBRC,qGAKnBC,wBACE,IAAMC,EAAgBxhB,KAAAyhB,iBAAsB,CAC1C7T,GAD0C,UAI1CsB,KAAMlP,KAAA8Z,MAJoC5K,KAK1CsN,KAAMxc,KAAA8Z,MALoC0C,KAM1CC,OAAQzc,KAAA8Z,MANkC2C,OAO1CC,QAAS1c,KAAA8Z,MAPiC4C,QAQ1CC,eAAgB3c,KAAA8Z,MAR0B6C,eAS1CC,mBAAoB5c,KAAA8Z,MATsB8C,mBAU1CC,mBAAoB7c,KAAA8Z,MAVsB+C,mBAW1CC,eAAgB9c,KAAA8Z,MAX0BgD,eAY1CC,iBAAkB/c,KAAA8Z,MAZwBiD,iBAa1CC,eAAgBhd,KAAA8Z,MAb0BkD,eAc1CC,iBAAkBjd,KAAA8Z,MAdwBmD,iBAe1CC,qBAAsBld,KAAA8Z,MAfoBoD,qBAgB1CC,qBAAsBnd,KAAA8Z,MAhBoBqD,qBAiB1CC,kBAAmBpd,KAAA8Z,MAjBuBsD,kBAkB1CC,aAAcrd,KAAA0hB,uBAA4B1hB,KAAA8Z,MAlBAuD,cAmB1CE,aAAcvd,KAAA0hB,uBAA4B1hB,KAAA8Z,MAnBAyD,cAoB1CC,UAAWxd,KAAA0hB,uBAA4B1hB,KAAA8Z,MApBG0D,WAqB1CE,aAAc1d,KAAA0hB,uBAA4B1hB,KAAA8Z,MArBA4D,cAsB1CE,iBAAkB5d,KAAA0hB,uBAA4B1hB,KAAA8Z,MAtBJ8D,kBAwB1C+D,eAAgB,CACdtE,aAAc,CAACrd,KAAA8Z,MAADhO,uBAAoC9L,KAAA8Z,MADpCuC,MAEdkB,aAAc,CAACvd,KAAA8Z,MAADhO,uBAAoC9L,KAAA8Z,MAFpCuC,MAGdmB,UAAW,CAACxd,KAAA8Z,MAADhO,uBAAoC9L,KAAA8Z,MAHjCuC,MAIdqB,aAAc,CAAC1d,KAAA8Z,MAADhO,uBAAoC9L,KAAA8Z,MAJpCuC,MAKduB,iBAAkB,CAAC5d,KAAA8Z,MAADhO,uBAAoC9L,KAAA8Z,MAApCuC,SAIlB3O,EAAc,CAAC,IAAAkU,EAAA,EAAnBJ,IAKA,OAFA9T,GADAA,EAASA,SAAc1N,KAAvB0N,0BACSA,OAAc1N,KAAvB0N,6BAKF6L,2BACEsI,EAAA3hB,UAAAqZ,gBAAA3M,KAAA5M,MAEAA,KAAAwZ,SAAc,CACZsI,iBADY,GAEZjZ,YAAa,QAKjBkZ,8BAAiFjd,EAA7DgV,MAA6DhV,EAAtDkd,SAAsDld,EAA5CX,QAA4CW,EAAnCmd,WAC5C,OAD+End,EAAvBiV,YACxDmI,cACE,KAKJrI,wBAQG,IAPDC,EAOC3U,EAPD2U,MACAkI,EAMC7c,EAND6c,SACAjI,EAKC5U,EALD4U,YAMA8H,EAAA3hB,UAAA2Z,YAAAjN,KAAA5M,KAAkB,CAAE8Z,MAAFA,EAASC,gBAE3B,IAAIoI,EAA2BniB,KAAAia,MAA/BkI,YACIpI,EAAJqI,qBACMtI,iBAAuBkI,EAAvBlI,cAAgDA,SAAekI,EAAnE3F,OACE8F,EAAcrI,eAAmBA,EAAjCqI,SAGErb,+CAA+CgT,EAD/BuC,MAGhB8F,EAAc,IAAdA,GAGEA,IAAgBniB,KAAAia,MAApBkI,aACEniB,KAAAwZ,SAAc,CAAE2I,gBAGlBA,uBAAiCrI,EAAjCqI,OACSpI,EAAJsI,aACLF,uBAAiCrI,EAAjCqI,MAGFA,gBAA0BrI,EAA1BqI,YACAA,4BAAsCrI,EAAtCqI,wBACAA,mBAA6BniB,KAA7BmiB,SACAA,aAAuBrI,EAAvBqI,IACAniB,KAAAsiB,yBACAtiB,KAAAuiB,qBAGF,IAAIT,EAAJ,GACI5b,cAAc4T,EAAlBhO,0BAEEgW,EAAmBhI,EAAAhO,uBAAArI,IAAiC,SAAA+e,GAAI,OAAI1I,gBAAJ0I,MAG1DxiB,KAAAwZ,SAAc,CAAEsI,wBAGlBJ,mCAAsC,IAAAtX,EAAApK,KACpC,yBAAIyiB,EACFA,EAEK,SAAAjgB,GAAA,OAAqBigB,EAAQjgB,EAAU4H,EAAAsY,kBAAVlgB,GAA2C4H,EAAA0P,MAAxEuC,UAGTqG,8BACE,IAAK1iB,KAAA8Z,MAAD5K,OAAqBlP,KAAA8Z,MAAzBhO,uBACE,SAEF,IAAK9L,KAAA8Z,MAAAhO,uBAALvK,OACE,SAEF,IAAMhB,EAAeP,KAAA8Z,MAAA5K,KAAA5O,SAAAqiB,QAArBngB,GACA,OAAOxC,KAAA8Z,MAAAhO,uBAAAtB,SAAPjK,MAGFqiB,2BAA8C,IAA7Bhb,EAA6BrB,EAA7BqB,KAMf,OAN4CrB,EAAvBsc,YACjBA,YAAJ,mBAEEjb,sBAGFA,KAGFkb,kCACE,IAAK9iB,KAAAia,MAAApR,YAALtH,OACE,SAGF,IASAiM,EATMuV,EAAWriB,OAAAC,OAAA,CACfiN,IAAO5N,KAAA8Z,MAAAzR,eAAA2a,WAAuChjB,KAAA8Z,MAA5CzR,gBADa,gBAEf6G,KAAMlP,KAAAia,MAFSpR,YAGf2T,KAAMxc,KAAA8Z,MAHS0C,KAKfyG,WAAYjjB,KAAA8Z,MAAWmE,sBACpBje,KAAA8Z,MANLoE,sBAWA,OAAQle,KAAA8Z,MAARzR,gBACE,WACEmF,EAAQ,IAAA0V,EAAA,EACNljB,KAAAyhB,iBAAA/gB,OAAAC,OAAA,GAAAoiB,EAAA,CAEEI,UAAWnjB,KAAA8Z,MAFb4E,oBAGE0E,YAAapjB,KAAA8Z,MAHf6E,sBAIE0E,UAAWrjB,KAAA8Z,MAJb8E,wBAKE0E,QAAStjB,KAAA8Z,MALX+E,kBAME0E,QAASvjB,KAAA8Z,MANXgF,sBAOE0E,SAAUxjB,KAAA8Z,MAPZiF,uBAQE0E,SAAUzjB,KAAA8Z,MARZkF,uBAUE0E,YAAa,SAAAC,GAAC,OAAIA,EAAJpb,cAGlB,MAEF,YACEiF,EAAQ,IAAAoW,EAAA,EACN5jB,KAAAyhB,iBAAA/gB,OAAAC,OAAA,GAAAoiB,EAAA,CAIEc,YAAa7jB,KAAA8Z,MAJfqE,2BAKE2F,QAAS9jB,KAAA8Z,MALXsE,uBAME2F,YAAa/jB,KAAA8Z,MANfuE,2BAOE2F,gBAAiBhkB,KAAA8Z,MAPnBwE,+BAQE2F,gBAAiBjkB,KAAA8Z,MARnByE,+BASEf,UAAWxd,KAAA8Z,MATb2E,yBAUE+E,SAAUxjB,KAAA8Z,MAAW0E,4BAGzB,MAEF,QACE,sBAAWxe,KAAA8Z,MAAPzR,eAEFmF,EAAQ,IAAA0W,EADelkB,KAAA8Z,MAAvBzR,gBAEErI,KAAAyhB,iBAAA/gB,OAAAC,OAAA,GAAAoiB,EAAA,CAIEc,YAAa7jB,KAAA8Z,MAJfqE,2BAKE2F,QAAS9jB,KAAA8Z,MALXsE,uBAME2F,YAAa/jB,KAAA8Z,MANfuE,2BAOE2F,gBAAiBhkB,KAAA8Z,MAPnBwE,+BAQE2F,gBAAiBjkB,KAAA8Z,MARnByE,+BASEf,UAAWxd,KAAA8Z,MATb2E,yBAUE+E,SAAUxjB,KAAA8Z,MAAW0E,4BAO/B,MAAO,CAAPhR,MAGF2W,iCAAwB,IAAAtV,EAAA7O,KACtB,OAAKA,KAAAia,MAALtV,iBAoCO,CAhCO,IAAAid,EAAA,EACZ5hB,KAAAyhB,iBAAsB,CACpB7T,GADoB,YAEpBsB,KAAMlP,KAAAia,MAFctV,iBAGpB6X,KAAMxc,KAAA8Z,MAHc0C,KAIpBD,UAJoB,EAKpBG,SALoB,EAMpB0H,eANoB,EAOpBzH,eAAgB3c,KAAA8Z,MAPI6C,eAQpBC,mBAAoB5c,KAAA8Z,MARA8C,mBASpBC,mBAAoB7c,KAAA8Z,MATA+C,mBAUpBC,eAAgB9c,KAAA8Z,MAVIgD,eAWpBC,iBAAkB/c,KAAA8Z,MAXEiD,iBAYpBC,eAAgBhd,KAAA8Z,MAZIkD,eAapBC,iBAAkBjd,KAAA8Z,MAbEqE,2BAcpB2F,QAAS9jB,KAAA8Z,MAdWsE,uBAepB2F,YAAa/jB,KAAA8Z,MAfOuE,2BAgBpBnB,qBAAsBld,KAAA8Z,MAhBFwE,+BAiBpBnB,qBAAsBnd,KAAA8Z,MAjBFyE,+BAkBpBf,UAAWxd,KAAA8Z,MAlBS2E,yBAmBpBpB,aAAc,SAAA7a,GAAO,OAAIqM,EAAAiL,MAAAgE,sBAAAtb,EAA0CqM,EAAAiL,MAA9CuC,OACrBqB,aAAc,SAAAlb,GAAO,OAAIqM,EAAAiL,MAAAkE,sBAAAxb,EAA0CqM,EAAAiL,MAA9CuC,OACrBkB,aAAc,SAAA/a,GAAO,OAAIqM,EAAAiL,MAAAiE,sBAAAvb,EAA0CqM,EAAAiL,MAA9CuC,OACrBuB,iBAAkB,SAAApb,GAAO,OACvBqM,EAAAiL,MAAA+D,0BAAArb,EAEEqM,EAAAoL,MAAA6H,iBAFF,GAGEjT,EAAAiL,MAJqBuC,WA1B3B,MAsCJiG,kCACE,IAAM3d,EAAmB3E,KAAAia,MAAAkI,YAAzB1d,sBACIE,IAAqB3E,KAAAia,MAAzBtV,mBACE3E,KAAAwZ,SAAc,CAAE7U,qBAChB3E,KAAAqkB,0BAIJ9B,gCACE,IAAM1Z,EAAc7I,KAAAia,MAAAkI,YAAAvd,eAAAK,EAApBoC,GACIwB,IAAgB7I,KAAAia,MAApBpR,cACE7I,KAAAwZ,SAAc,CAAE3Q,gBAChB7I,KAAAqkB,0BAIJnL,yBACE,IAAM3R,EAAavH,KAAAia,MAAAkI,YAAAjb,YAAnBE,GACApH,KAAAsiB,yBACAtiB,KAAAuiB,oBAEAhb,GACEvH,KAAA8Z,MAAAwC,OAAA/U,MAIJ6R,4BACE,IAAM7R,EAAavH,KAAAia,MAAAkI,YAAA1a,oBAAnBL,GACApH,KAAAsiB,yBACAtiB,KAAAuiB,oBAEAhb,GACEvH,KAAA8Z,MAAAwC,OAAA/U,MAIJ8R,2BACE,IAAM9R,EAAavH,KAAAia,MAAAkI,YAAAza,mBAAnBN,GACApH,KAAAsiB,yBACAtiB,KAAAuiB,oBAEAhb,GACEvH,KAAA8Z,MAAAwC,OAAA/U,MAIJ+R,0BAAuC,IAC7BjS,EAAqCD,EADRC,aACfpC,EAAuBmC,EADRnC,MACR4N,EAAgBzL,EADRyL,YAAAyR,EAGAtkB,KAAAia,MAAAkI,YAAA7a,kBAHAF,GAG7BG,EAH6B+c,EAAA/c,WAGjBC,EAHiB8c,EAAA9c,aAIrCxH,KAAAsiB,yBACAtiB,KAAAuiB,kBAAAtd,EAAAoC,GAEAG,GAGEqL,oBAGFtL,GACEvH,KAAA8Z,MAAAwC,OAAA/U,MAIJ1C,sBAAmD,IAAvCE,EAAuCwf,EAAvCxf,WACV,OAAO/E,KAAAia,MAAAkI,YAAAtd,UAAiC,CAAEE,mBA/TIkU,IAmUlDqI,oCACAA,mBCleO,IAAM1hB,GAAiB,YAAjBA,GAGF,UAGLwc,GAAe,CACnBoI,cAAe5kB,GACfyO,SAFmB,GAGnBoW,SAAU,cAGNC,GAAa,CACjBtjB,KADiB,oBAEjBd,SAAU,IAONqkB,GAAqB,8VAA3B,yBAsBqBC,qGACnBC,oCAA0C,IAAAC,EACT9kB,KADS8Z,MAChCzL,EADgCyW,EAAAzW,SACtBoW,EADsBK,EAAAL,SAAAM,EAGvB/kB,KAAAmE,QAAAoI,SAAAC,QAA8B5L,KAHP,IAGjCokB,EAHiCD,EAAA,GAG7BE,EAH6BF,EAAA,GAAAG,EAIvBllB,KAAAmE,QAAAoI,SAAAC,QAA8B5L,KAJP,IAIjCukB,EAJiCD,EAAA,GAI7BE,EAJ6BF,EAAA,GAcxCT,EAAS,CAAEY,aARUrlB,KAAAmE,QAAA8J,KAAAqX,YAA8B,CACjDnX,EAAGxB,WAD8CwY,GAEjD/W,EAAGzB,WAF8CyY,GAGjDG,MAAO5Y,SAASwY,EAHiCH,GAIjDQ,OAAQ7Y,SAASyY,EAJgCH,GAKjD5W,kBAMJoX,kCAAwC,IAetCC,EAfsCtb,EAAApK,KAAA2lB,EACP3lB,KADO8Z,MAC9BzL,EAD8BsX,EAAAtX,SACpBoW,EADoBkB,EAAAlB,SAEhCmB,EAAchlB,EAAA,GAAA6C,IAAmB,SAAA4S,GAAC,OAAIjM,EAAAjG,QAAAoI,SAAAC,QAAJ6J,KAElCwP,EAAOD,EAAAniB,IAAgB,SAAAqiB,GAAU,OAAIA,EAAJ,KACjCC,EAAOH,EAAAniB,IAAgB,SAAAqiB,GAAU,OAAIA,EAAJ,KACjC3X,EAAIxB,oBAAVkZ,GACMzX,EAAIzB,oBAAVoZ,GACMtO,EAAO9K,oBAAbkZ,GACMnO,EAAO/K,oBATyBoZ,GAahCC,EAAiB3kB,kBAAvBT,GACMqlB,EAAY/P,YAAU8P,EA1DhC,IA4DI,IAGEN,EAAa1e,YAAcif,EAA3BP,GACA,MAAAQ,GAGA,YADApf,qCAFUof,GAMZlmB,KAAAwZ,SAAc,CACZ2M,wBAAyB,CACvBT,gBAIJ,IAAMU,EAAepmB,KAAA8Z,MAANlM,GAAA,qBAGfyY,WAAW,WACT,IAAMhB,EAAejb,EAAAjG,QAAA8J,KAAAqX,YAA8B,CACjDnX,EADiDA,EAEjDC,EAFiDA,EAGjDmX,MAAO9N,EAH0CtJ,EAIjDqX,OAAQ9N,EAJyCtJ,EAKjDC,SAAQ,CAAA+X,GAAA/jB,OAAAgM,KAGVoW,EAAS,CACPY,aAAcA,EAAArW,OAAoB,SAAAsX,GAAI,OAAIA,aAAkBlc,EAAA0P,MAAtBlM,QAV1CyY,QAeF9E,wBAAe,IAAAgF,EAAA1X,EAAA7O,KACLmmB,EAA4BnmB,KADvBia,MAAAkM,wBAGP9J,GACJkK,EAAA,GAAAA,EACG3mB,IADH,gBAAA2mB,EAEG3mB,IAFH,cAAA2mB,GAGEvmB,KAAA8Z,MAHF0K,gBADF,OAMMgC,EAAN,GACA7B,WAA2B,SAAAnO,QACzBiQ,IAAI5X,EAAAiL,MAAAtD,KAA6BgQ,KAAoB3X,EAAAiL,MAApB0M,MAGnC,IAAM9Y,EAAS,CACb,IAAAgZ,GACE1mB,KAAAyhB,iBAAA/gB,OAAAC,OAAA,CACEiN,GA9GV,oBA+GU2O,UAFF,EAGEF,KAHFA,EAIEvQ,uBAJF,GAKEoD,KALFwV,GAMEpI,OAAQ,SAAAxX,GAA+B,IAA5BU,EAA4BV,EAA5BU,YACT,kBADqCV,EAAfY,SACS,KACrB9E,EAAgB4E,cADKnF,SAAAO,YAGzBiO,EAAAiL,MAAA0K,gBAA6B5kB,GAC/BiP,EAAAgW,wBAAAjkB,GACSiO,EAAAiL,MAAA0K,gBAA6B5kB,IACtCiP,EAAA4W,sBAAA7kB,MAfZ4lB,MAwBA,GAAAL,EAA6B,KACnBT,EAAeS,EADIT,WAE3BhY,OACE,IAAAiZ,EAAA,EACE3mB,KAAAyhB,iBAAsB,CACpB7T,GAvIZ,oBAwIY2O,UAFoB,EAGpBG,SAHoB,EAIpBkK,QAJoB,EAKpB1X,KAAM,CALcwW,GAMpBrI,aAAc,SAAAwJ,GAAG,MAAI,OAAJ,IACjBtJ,aAAc,SAAAsJ,GAAG,MAAI,OAAJ,IACjBC,WAAY,SAAAC,GAAC,OAAIA,WAAJnmB,iBAMrB,OAAA8M,KAGFqU,8BAAiF,IAAAiF,EAAA7hB,EAA7D4U,YAAemI,EAA8C8E,EAA9C9E,aAAcE,EAAgC4E,EAAhC5E,mBAC/C,OAAOF,GAAPE,MAhIwC7G,KAoI5CqJ,8BACAA,iCClLqBqC,6FACnB1F,wBAoBE,MAAO,CAnBS,IAAAqC,EAAA,EACdljB,OAAAC,OAAA,GAAkBX,KAAlB8Z,MAA8B,CAC5BlM,GAAO5N,KAAA8Z,MAALlM,GAD0B,oBAE5BsB,KAAMlP,KAAA8Z,MAAW5K,QAIP,IAAAgY,GAAA,EACZxmB,OAAAC,OAAA,GAAkBX,KAAlB8Z,MAA8B,CAC5BlM,GAAO5N,KAAA8Z,MAALlM,GAD0B,aAE5BsB,KAAMlP,KAAA8Z,MAFsB5K,KAG5BqN,UAH4B,EAI5B4K,kBAAmB,SAAAriB,GAAA,IAAGyD,EAAHzD,EAAAyD,SAAA,MAAkB,CAACA,EAAD,GAAcA,EAAd,GAAlB,IACnB6e,kBAAmB,SAAAjiB,GAAA,IAAGoD,EAAHpD,EAAAoD,SAAA,MAAkB,CAACA,EAAD,GAAcA,EAAd,GAA2BA,MAA7C,IACnBib,SAAU,UANkB,KAO5B6D,eAAgB,UAjB6B9L,KAyBrD0L,uCACAA,gBA5BA,iCCLMK,GAAgB,CACpBC,gBADoB,EAEpBC,wBAFoB,EAGpBC,iBAAkB,MAmBpB,IAqEe3D,GAAA,CACb4D,KADa,UAEbC,GAvEF,iiBAwEEC,GAlDF,0wCAmDEC,YAzFF,SAAAC,GAAmG,IAAAhjB,OAAA,IAAAgjB,EAAfR,GAAeQ,EAA5EP,EAA4EziB,EAA5EyiB,eAAgBC,EAA4D1iB,EAA5D0iB,uBAAwBC,EAAoC3iB,EAApC2iB,iBACvDM,EAAN,GAYA,YAXAtB,IAAIc,IAEFQ,2BAEFtB,IAAIe,IAEFO,kCAEFtB,IAAIgB,IACFM,wBAEFA,ICdF,SAAAC,GAAAljB,GAAiD,IAArBmjB,EAAqBnjB,EAArBmjB,OAAqBC,EAAApjB,EAAbqjB,YAAa,IAAAD,EAAN,GAAMA,EAE/C,OAAOD,UADP,WACmCE,SAAnC,UAGF,IAaqBC,qGAEnBC,sBACE,IAAMC,EAAOC,EAAAroB,UAAAmoB,WAAAzb,KAAb5M,MACA,OAAOU,OAAAC,OAAA,GAAA2nB,EAA2B,CAChCE,QAASF,iBAAuB,CADAxE,KAEhC6D,GAAIK,GAAiB,CAAEC,OAAQK,EAAVX,GAAsBQ,KAnBjD,0EAoBMP,GAAII,GAAiB,CAAEC,OAAQK,EAAVV,GAAsBO,KAfjD,+DAmBE5O,4BACEgP,EAAAroB,UAAAqZ,gBAAA3M,KAAA5M,KADuBmE,GAKvBnE,KAAAwZ,SAAc,CACZiP,mBAAoB,IAAAC,GAAA,EAAgBvkB,EADxB+V,IAEZyO,aAAc,IAAAD,GAAA,EAAcvkB,EAAd+V,MAIhBla,KAAAia,MAAA2O,iBAAAC,aAAyC,CACvCC,eAAgB,CACdzQ,KADc,EAEdjX,KAAM2nB,IAFQC,cAGdC,OAAQjpB,KAHMkpB,iBAIdzG,SAAU,kBAMhB0G,iBAA+DhkB,EAAxDikB,iBAAwDjkB,EAAjC8d,WAAiC,IAArB8E,EAAqB5iB,EAArB4iB,SAAqBjD,GAAA3f,EAAXhB,QAS9CnE,KATyD8Z,OAG3DuP,EAH2DvE,EAAAuE,QAI3DC,EAJ2DxE,EAAAwE,WAK3DC,EAL2DzE,EAAAyE,WAM3DC,EAN2D1E,EAAA0E,eAO3DC,EAP2D3E,EAAA2E,eAQ3DC,EAR2D5E,EAAA4E,cAW7D3B,EAAWrnB,OAAAC,OAAA,GAAAonB,EAA4B,CACrC4B,UAAW3U,OAD0BqU,GAErCO,UAAW5U,OAF0B0U,GAGrCH,WAHqCA,EAIrCD,WAJqCA,EAKrCE,eALqCA,EAMrCC,mBAjB2D,IAAAI,EAqBhB7pB,KArBgBia,MAqBrDwO,EArBqDoB,EAAApB,mBAqBjCE,EArBiCkB,EAAAlB,aAsB7DF,WACAA,QAAyB,CAAEqB,OAAF,EAAevb,OAAO,IAE/CvO,KAAAia,MAAA8P,MAAAC,qBAAsC,CACpCzC,gBADoC,EAEpCC,wBAFoC,EAGpCC,iBAAkBkB,IAGpB3oB,KAAAia,MAAA8P,MAAAZ,KAAsB,CACpBpB,SAAUrnB,OAAAC,OAAA,GAAAonB,EAA4B,CACpC4B,UADoC,EAEpCJ,WAAoC,IAAxBvpB,KAAA8Z,MAAAyP,aAEdtG,WAAY,CACVgH,WADU,EAGVC,cAAenB,IAAGoB,KAEpBC,YAAa3B,IAIfzoB,KAAAia,MAAA8P,MAAAC,qBAAsC,CACpCzC,gBADoC,EAEpCC,wBAFoC,EAGpCC,iBAAkBgB,IAEpBzoB,KAAAia,MAAA8P,MAAAZ,KAAsB,CACpBpB,SAAUrnB,OAAAC,OAAA,GAAAonB,EAA4B,CACpC4B,UAAW3U,OADyBqU,GAEpCE,WAAYvpB,KAAA8Z,MAAWyP,aAEzBtG,WAAY,CACVgH,WAAW,QAKjBf,6BAA4B,IAClBmB,EAAcrqB,KADI8Z,MAAAuQ,UAElBC,EAAmBtqB,KAFDia,MAAAqQ,eAI1BC,QAAkBD,EAAAE,iBAAgC,CAChDC,OAAQF,EADwC7jB,MAEhD2R,KAFgD,EAGhDqS,SAAU,SAAA1iB,EAAA5C,GAAA,MAAmB,CAACilB,EAASriB,EAATqiB,IAApB,UArG8BM,MA0G9CvC,gCACAA,gBA/GqB,CACnBiC,UAAW,CAAEjpB,KAAF,WAAoBsF,MAAO,4BCMhCkkB,GAAgBpO,KAAhBoO,YAKFC,GAAoBle,QAA1B,IAgBA,SAAAme,GAAA5Q,EAAA6Q,EAAAC,GACE,uBAAID,EAEKrqB,OAAAgoB,GAAA,aAAAhoB,CAAYwZ,EAAKxZ,OAAAC,OAAc,CAAEsqB,KAAM,CAAAF,IAAvCC,IAAAE,KACC,SAAAC,GAAQ,OAAIA,EAAJ,KADTC,MAEE,SAAAC,GACL,MAAM,IAAAnqB,MAAA,+BAAA6pB,EAAA,KAANM,KAGC,IAAAC,QAAY,SAAAC,GAAO,OAAIA,EAOhC,SAAArR,EAAAhL,EAAA8b,GACE,GAAI9b,aAAJwZ,GAAA,EACE,OAAAxZ,EAEF,OAAO,IAAAwZ,GAAA,EAAAxO,EAAkBxZ,OAAAC,OAAc,CAAEuO,QAAzC8b,IAXsCQ,CAAkBtR,EAAA6Q,EAA9BC,MAc5B,SAAAS,GAAAC,IApCA,SAAAC,EAAAC,GACE,IAAAD,EACE,MAAM,IAAAzqB,MAAA,YAAN0qB,GAmCFC,CAAOH,aAAwBA,EAAxBA,SAA8CA,EAArDG,WAOF,SAAAC,GAAA5c,GACE,GAAIA,aAAJwZ,GAAA,EAEE,OADA+C,GAA2Bvc,EAA3Buc,YACAvc,EACK,GAAIA,EAAJ6c,UAEL,OADAN,MACO,IAAA/C,GAAA,EAAa,CAClBgD,WAAYxc,IAGhB,MAAMhO,MAAN,gBAGF,IACMkb,GAAe,CACnB4P,KADmB,KAEnBC,QAFmB,KAGnB5I,UAAW,CAAEjiB,KAAF,SAAkBsF,MAAlB,EAA4ByF,IAAK,GAG5C8W,WAAY,CACVgH,WADU,EAEViC,UAAWnD,IAAGoD,QAEhB3P,MAVmB,EAYnB4P,cAZmB,GAcnB1I,YAAa,CAAEtiB,KAAF,WAAoBsF,MAAO,SAAAyH,GAAC,OAAIA,EAAJ5F,WACzCib,SAAU,CAAEpiB,KAAF,WAAoBsF,MAhBV,OAAtB,MAoBE2lB,OAAQ,CAAEjrB,KAAF,WAAoBsF,MAAO,SAAAyH,GAAC,OAAIA,OAASA,EAATA,OAAJ,IACpCme,SAAU,CAAElrB,KAAF,WAAoBsF,MAAO,SAAAyH,GAAC,OAAIA,SAAJ,IACtCoe,QAAS,CAAEnrB,KAAF,WAAoBsF,MAAO,SAAAyH,GAAC,OAAIA,QAAJ,KAGlBqe,qGACnBnE,sBAEE,MAAO,CAAEV,GCxHb,2pDDwHiBC,GExHjB,oiBFwHqBY,QAAS,CADJxoB,KAAAysB,qBAAA,YAAtB,YAC0B,0BAG5BlT,2BAC2BvZ,KAAzB0sB,sBACA9D,aAA8B,CAC5B+D,kBAAmB,CACjBtU,KADiB,EAEjBoK,SAAU,eAEZmK,sBAAuB,CACrBvU,KADqB,EAErBoK,SAFqB,cAGrBwG,OAAQjpB,KAAK6sB,mCAEfC,kBAAmB,CACjBzU,KADiB,EAEjBoK,SAAU,qBAFO,WAGjBwG,OAAQjpB,KAAK+sB,4BAEfC,eAAgB,CACd3U,KADc,EAEdoK,SAFc,WAGdwK,aAAc,eAIlBjtB,KAAAwZ,SAAc,CAGZ0T,aAAc,IAAAxE,GAAA,EAAc1oB,KAAAmE,QAAd+V,GAA+B,CAC3ChL,KAAM,IAAAie,WADqC,GAE3C5H,MAF2C,EAG3CC,OAAQ,SAKd3L,wBAA8C,IAAhCC,EAAgChV,EAAhCgV,MAAOkI,EAAyBld,EAAzBkd,SAAUjI,EAAejV,EAAfiV,YACvB6O,EAAmB5oB,KADmB0sB,sBAIxC3S,EAAJsI,aACEuG,kBAGF5oB,KAAAotB,YAAAtT,EAAAkI,GAEIlI,YAAkBkI,EAAtBiK,SACEjsB,KAAAqtB,WAAgBvT,EAAhBmS,YAIJmB,0BACMtT,SAAekI,EAAnBxF,OACMxc,KAAAia,MAAJ8P,OACE/pB,KAAAia,MAAA8P,MAAAuD,SAGFttB,KAAAwZ,SAAc,CAAEuQ,MAAO/pB,KAAAutB,SAAcvtB,KAAAmE,QAAd+V,MAEvBla,KAAAqtB,WAAgBrtB,KAAAia,MAAhBgS,SAEyBjsB,KAAzB0sB,sBACA9D,oBAIJO,iBAAmB,IAAZpB,EAAY5iB,EAAZ4iB,SACG1E,EAAcrjB,KADL8Z,MAAAuJ,UAGjBrjB,KAAAia,MAAA8P,MAAAyD,OACE9sB,OAAAC,OAAA,GAAAonB,EAA4B,CAC1B1E,kBAKNkK,qBACE,OAAO,IAAA7E,GAAA,EAAAxO,EAELxZ,OAAAC,OAAA,GAAkBX,KAAlBqoB,aAAqC,CACnCza,GAAI5N,KAAA8Z,MAD+BlM,GAEnCvN,SAAUyrB,GAAY9rB,KAAA8Z,MAFakS,MAGnCyB,aAHmC,EAInCC,YAAa1tB,KAAAmE,QAAaupB,kBAKhCL,uBAAgB,IAAAjjB,EAAApK,KACNka,EAAOla,KADDmE,QAAA+V,GAAA2P,EAEkB7pB,KAFlBia,MAEN8P,EAFMF,EAAAE,MAECmD,EAFDrD,EAAAqD,aAIdnC,EACED,GAAU5Q,EAAV4Q,QAAyB,SAAAmB,GACvBlC,cAAkB,CAAE4D,QAAF1B,EAAoB2B,WAAY,IAClDxjB,EAAAoP,SAAc,CAAEyS,eAIlBjsB,KAAAia,MAAA8P,MAAA8D,YAA6B,CAAEF,QAAFT,EAAyBU,WAAY,IAClE5tB,KAAAwZ,SAAc,CAAEyS,QAAS,WAI7BY,8CACE,IAAMiB,EAAS9tB,KAAf+tB,oBAGA,GAFAxD,cAEAuD,EAJ2C,KAAAhJ,EASb9kB,KATa8Z,MASnC5K,EATmC4V,EAAA5V,KAS7BwU,EAT6BoB,EAAApB,YAUnChd,EAAU6jB,EAVyB7jB,MAWvCoC,EAAJ,EACA9C,EAAAkJ,EAAAjJ,EAAAC,MAAAC,QAAAH,GAAAI,EAAA,MAAAJ,EAAAC,EAAAD,IAAAK,OAAAC,cAA0B,KAAAC,EAAA,GAAAN,EAAA,IAAAG,GAAAJ,EAAAzE,OAAA,MAAAgF,EAAAP,EAAAI,SAAA,KAAAA,EAAAJ,EAAAQ,QAAAC,KAAA,MAAAF,EAAAH,EAAAM,MAAA,IAClB6B,EAAWmb,EADOnd,GAExBG,EAAMoC,KAAO8hB,GAAYriB,EAAzB7B,IACAA,EAAMoC,KAAO8hB,GAAYriB,EAAzB7B,UAVA6jB,QAAkB,IAAAyD,aAAlBzD,MAeJwC,uCAAsC,IAAApH,EACQ3lB,KADR8Z,MAC5B5K,EAD4ByW,EAAAzW,KACtBmd,EADsB1G,EAAA0G,OACdC,EADc3G,EAAA2G,SACJC,EADI5G,EAAA4G,QAE5B7lB,EAAgB6jB,EAFY7jB,MAGhCoC,GADoByhB,EAFYlS,KAGpC,GACA4V,EAAA/e,EAAAgf,EAAAhoB,MAAAC,QAAA8nB,GAAAE,EAAA,MAAAF,EAAAC,EAAAD,IAAA5nB,OAAAC,cAA0B,KAAAie,EAAA,GAAA2J,EAAA,IAAAC,GAAAF,EAAA1sB,OAAA,MAAAgjB,EAAA0J,EAAAE,SAAA,KAAAA,EAAAF,EAAAznB,QAAAC,KAAA,MAAA8d,EAAA4J,EAAAznB,MAAA,IAAf+C,EAAe8a,EACxB7d,EAAMoC,KAAOyjB,KAAb7lB,GACAA,EAAMoC,KAAOwjB,KAAb5lB,GACAA,EAAMoC,KAAOujB,KAAb3lB,QAxIiC0nB,KA6IvC5B,yBACAA,uBGjQqB6B,eACnB,SAAAA,EAAArD,GAAuB,gBAAXA,MAAO,IACjBsD,EAAA1hB,KAAA5M,KACEU,OAAAC,OAAA,GAAAqqB,EAAwB,CACtBU,WAAY6C,GAAkBvD,OAHbhrB,wBADoBwuB,MAU7C,SAAAD,GAAAzpB,GAsCE,IAtC8F,IAAA2pB,EAAA3pB,EAAlEvD,cAAkE,IAAAktB,EAAzD,EAAyDA,EAAAC,EAAA5pB,EAAtD6pB,gBAAsD,IAAAD,EAA3C,GAA2CA,EAAAE,EAAA9pB,EAAtC+pB,iBAAsC,IAAAD,EAA1B,IAA0BA,EAAAE,EAAAhqB,EAApBiqB,iBAAoB,IAAAD,EAAR,IAAQA,EACxFE,EAAY,QAKhB,GAAML,EALU,EAMhB,EANgBA,EAAA,EAQhB,GAAMA,EARU,EAShB,EATgBA,EAAA,EAYhB,GAAME,EAZU,EAAAE,EAAA,EAehB,GAAMF,EAfU,EAgBhB,EAhBgBF,EAAA,EAkBhB,GAAME,EAlBU,EAAAE,EAAA,EAsBhB,GAAMF,EAtBU,EAAAE,EAAA,EAyBhB,GAAMF,EAzBU,EA0BhB,EA1BgBF,EAAA,EA4BhB,GAAME,EA5BU,EA6BhB,EA7BgBF,EAAlB,GAoCM5C,EAAY,IAAA7lB,MAAU8oB,EAA5BztB,QACSuH,EAAT,EAAgBA,EAAIkmB,SAApB,EAA0ClmB,IAAK,CAC7C,IAAMmmB,EAAN,EAAWnmB,EACXijB,EAAUkD,EAAVlD,IAAqBiD,EAAUC,EAAVD,GAAD,IAApBjD,EACAA,EAAUkD,EAAVlD,IAAqBiD,EAAUC,EAAVD,GAAD,IAApBjD,EACAA,EAAUkD,EAAVlD,KAEF,MAAO,CACLA,UAAW,IAAAiC,aADNjC,GAELmD,QAAS,IAAAlB,aAZK,qDAlC8E,IA+C5FgB,UAAW,IAAAhB,aAAAgB,kBCzDf,SAAAG,GAAAC,GAGE,IADA,IAAIC,EAAJ,EACSvmB,EAAT,EAAgBA,EAAIsmB,SAApB,EAAwCtmB,IACtCumB,GAAcD,cAAoBA,EAAQtmB,EAA1CumB,IAEF,OAAAA,EAGF,IAAMC,GAAgB,OAAtB,KACMC,GAAoB,CAAEC,SAAF,EAAiBC,UAAU,GAyDrD,SAAAC,GAAAnL,GAA6F,IAA5DoL,EAA4DpL,EAA5DoL,KAAMC,EAAsDrL,EAAtDqL,WAAYP,EAA0C9K,EAA1C8K,WAAYvF,EAA8BvF,EAA9BuF,MAAO9hB,EAAuBuc,EAAvBvc,OAAQ6nB,EAAetL,EAAfsL,YACtEC,EAAgBT,EAAtBO,EACIva,EAAJ,EACI0a,EAAJ,EACIjnB,EAAJ,EACA,IAAKA,EAAL,EAAYA,EAAI6mB,SAAhB,MACEta,GAAmBsa,cAAiBA,EAAK7mB,EAAzCuM,KACAya,GAF+BhnB,IAK/BinB,IAGF,IAIMC,EAAQF,EAAdC,EACME,EALaN,EAAK7mB,EAAL6mB,oBAEPA,EAFOA,IAAnBO,YAKgBC,iBAEJ,IAAAC,GAAA,EAAAJ,EAFIG,QAGTR,EAHP7mB,IAMMoI,EAAQ,KADM,IAAAkf,GAAA,EAAYP,EAAYF,EAAK7mB,EAA7B,KAAAunB,SAA+CR,EAAYF,EAA/E7mB,KACewnB,gBAAsC3jB,KAArD4jB,GAEA,MAAO,CAAEhoB,SAAU,CAAC0nB,EAAD9hB,EAAY8hB,EAAZ7hB,EAAZ,GAAuC8C,MAAvCA,EAA8C4Y,MAA9CA,EAAqD9hB,kCC5FvD,SAAAwoB,GAAA1rB,GAAkE,IAAjC0R,EAAiC1R,EAAjC0R,EAAGlN,EAA8BxE,EAA9BwE,GAAIC,EAA0BzE,EAA1ByE,GAA0BknB,EAAA3rB,EAAtB4rB,mBAAsB,IAAAD,KACjEE,EAAa,IAAAC,GAAA,EAAArnB,GAAA8mB,SAAnB/mB,GACMunB,EAAc,IAAAD,GAAA,EAAApa,GAAA6Z,SAApB/mB,GACIwnB,EAAaH,MAAjBE,GAIA,OAHAH,IACEI,EAAaC,aAAKD,EAAA,EAAlBA,IAEKH,OAAPG,GCDF,IAKME,GAANC,GAEMC,GAA6B,CACjClF,KAAM,IAAAmF,GAAoB,CAAExC,SAP9B,GAOyDE,UANzD,OASMzS,GAAe1b,OAAAC,OAAA,GAAkBynB,GAAlBhM,aAAiD,CACpEgV,YADoEJ,GAEpEK,iBAFoEH,GAIpE7N,UAJoE,IAKpE7G,MALoE,EAOpE8U,iBAPoE,EAQpEC,eARoE,KAUpEC,QAAS,SAAArjB,GAAC,OAAIA,EAAJwhB,MACVnM,SAAU,SAAArV,GAAC,OAAIA,EAAJ2b,OACX2H,eAAgB,SAAAtjB,GAAC,MAAI,OAAJ,MACjBujB,aAAc,SAAAvjB,GAAC,OAAIA,EAAJiC,WACfuhB,qBAAsB,SAAA3pB,EAAAlD,GAAA,OAAAA,EAAAuqB,WAzBxB,GA0B6C,QAAzCA,KAA6D,CADzC,OAIHuC,qGACnBrY,2BACEvZ,KAAAia,MAAa,CACX4X,QADW,GAEX7F,KAAM,IAAAmF,GAAoB,CAAExC,SAhClC,GAgC6DE,UA/B7D,MAgCM3Z,aAAc,SAIlB2a,8BACE,GAAIiC,IAAqBC,IAAzBC,cAA0D,KAAAC,EACvC1lB,sBADuC2lB,GACjDC,EADiDF,EAAA,GAC7CG,EAD6CH,EAAA,GAEjD9jB,EAAQkkB,EAFyC,GAE9CjkB,EAAKikB,EAFyC,GAGxD,OAAO9lB,cAAqB,CAAC4B,EAADgkB,EAASC,EAArChkB,IACK,GAAI0jB,IAAqBC,IAAzBO,eAA2D,KACzDH,EAAUD,EAD+C,GACrDE,EAAMF,EAD+C,GAEzD/jB,EAAQkkB,EAFiD,GAEtDjkB,EAAKikB,EAFiD,GAGhE,OAAO9lB,cAAqB,CAAC4B,EAADokB,EAASH,EAArCI,IAGF,OAAOjmB,cAAP2lB,MAGFrY,wBAA8C,IAAAzP,EAAApK,KAAhC8Z,EAAgC3U,EAAhC2U,MAAOkI,EAAyB7c,EAAzB6c,SAAUjI,EAAe5U,EAAf4U,YAC7B,GAAIA,eAA2BA,EAA/B0Y,sBAAkE,KAAA3N,EAS5D9kB,KAT4D8Z,MAE9D5K,EAF8D4V,EAAA5V,KAG9DsiB,EAH8D1M,EAAA0M,QAI9DE,EAJ8D5M,EAAA4M,aAK9DD,EAL8D3M,EAAA2M,eAM9DE,EAN8D7M,EAAA6M,qBAO9DG,EAP8DhN,EAAAgN,iBAQ9DO,EAR8DvN,EAAAuN,iBAUxD9lB,EAAavM,KAV2CmE,QAAAoI,SAYhEvM,KAAAia,MAAA4X,QF5DS,SAAA/sB,GAOZ,IANDoK,EAMCpK,EANDoK,KAMCwjB,EAAA5tB,EALD0sB,eAKC,IAAAkB,EALS,SAAAvkB,GAAC,OAAIA,EAAJwhB,MAKV+C,EAAAC,EAAA7tB,EAJD4sB,oBAIC,IAAAiB,EAJc,SAAAxkB,GAAC,OAAIA,EAAJiC,WAIfuiB,EAAAC,EAAA9tB,EAHD0e,gBAGC,IAAAoP,EAHU,SAAAzkB,GAAC,OAAA0kB,IAGXD,EAAAE,EAAAhuB,EAFD6sB,4BAEC,IAAAmB,EAFsB,SAAA3kB,GAAC,MAAI,CAAJ,KAEvB2kB,EADDjD,EACC/qB,EADD+qB,YAEMgC,EAAN,GAEA7rB,EAAAkJ,EAAAjJ,EAAAC,MAAAC,QAAAH,GAAAI,EAAA,MAAAJ,EAAAC,EAAAD,IAAAK,OAAAC,cAA2B,KAAAnB,EAAA,GAAAc,EAAA,IAAAG,GAAAJ,EAAAzE,OAAA,MAAA4D,EAAAa,EAAAI,SAAA,KAAAA,EAAAJ,EAAAQ,QAAAC,KAAA,MAAAtB,EAAAiB,EAAAM,MAAA,IAAhBsB,EAAgB7C,EACnBwqB,EAAO6B,EAAbxpB,GACMoI,EAAYshB,MAAlBnC,GACMzF,EAAQtG,EAAdxb,GAEMonB,EAAUO,EAAAlsB,IAAS,SAAA+S,GAAC,OAAI,IAAA4Z,GAAA,EAAJ5Z,KACpBuc,EAAiB3D,WANE4D,UASnB3D,EAAaF,GATMC,GAezBnB,EAHoB0D,EAAoB3pB,EAAS,CAAEqnB,eAGnDnB,EAAAhoB,MAAAC,QAAA8nB,GAAAE,EAAA,MAAAF,EAAAC,EAAAD,IAAA5nB,OAAAC,cAAsC,KAAAC,EAAA,GAAA2nB,EAAA,IAAAC,GAAAF,EAAA1sB,OAAA,MAAAgF,EAAA0nB,EAAAE,SAAA,KAAAA,EAAAF,EAAAznB,QAAAC,KAAA,MAAAF,EAAA4nB,EAAAznB,MAAA,IAA3BkpB,EAA2BrpB,EACpC,GAAI6J,EAAJof,QAAuB,CACrB,IAAMyD,EAASvD,GAAsB,CACnCC,KADmCP,EAEnCQ,WAFmCA,EAGnCP,WAHmCA,EAInCvF,MAJmCA,EAKnC9hB,OALmCA,EAMnC6nB,gBAEFgC,UAGF,GAAIzhB,EAAJqf,SAAwB,CACtB,IAAMwD,EAASvD,GAAsB,CACnCC,KADmCoD,EAEnCnD,WAFmCA,EAGnCP,WAHmCA,EAInCvF,MAJmCA,EAKnC9hB,OALmCA,EAMnC6nB,gBAEFgC,YAKN,OAAAA,EEQyBqB,CAAkB,CACrChkB,KADqCA,EAErCsiB,QAFqCA,EAGrCE,aAHqCA,EAIrClO,SAJqCiO,EAKrCE,qBALqCA,EAMrC9B,YAPkB,SAAA9I,GAAC,OAAI3c,EAAAylB,YAAA9I,EAAAxa,EAAAulB,EAAJO,MASrBryB,KAAAmzB,2BAEEpZ,EAAJqZ,cACMtZ,UAAgBkI,EAApBvY,OACEzJ,KAAAmzB,8BAKNA,oCAA2B,IAAAxN,EACkB3lB,KADlB8Z,MACjByX,EADiB5L,EAAA4L,eACD8B,EADC1N,EAAA0N,eAEzB,GAAI9B,GAAkB8B,GAAtB,EAA2C,CACzC,IAAMrrB,EAAShI,KAAA8Z,MAAA5K,KAAfmkB,GAEQ5pB,EDlFP,SAAAtE,GAAkD,IAAbqR,EAAarR,EAAbqR,EAAG8c,EAAUnuB,EAAVmuB,OAC7C9c,EAAI,IAAAoa,GAAA,EAAJpa,GAIA,IAHA,IAAI+c,EAAJ,KACIC,EAAJC,IACIruB,GAAJ,EACS0D,EAAT,EAAgBA,EAAIwqB,SAApB,IAAAxqB,EAA4C,CAC1C,IAEM4qB,EAAiBlD,GAAsB,CAAEha,EAAFA,EAAKlN,GAFvCgqB,EAAXxqB,GAEsDS,GAD3C+pB,EAAOxqB,EAAlB,KAEM6qB,EAAwBnd,kBAA9Bkd,GACIC,EAAJH,IACEA,IACAD,IACAnuB,KAGJ,MAAO,CACLqE,MADK8pB,EAELnuB,MAFKA,EAGLkE,GAAIgqB,EAHCluB,GAILmE,GAAI+pB,EAAOluB,EAJN,GAKLouB,gBALKA,EAML7f,SAAUhH,cC4DUinB,CAA0B,CAAEN,OAD/BtzB,KAAA8Z,MAAA0X,QAAfxpB,GACsDwO,EAAG+a,IAHhB9nB,MAIzCzJ,KAAAia,MAAA4Z,cAA2B,CACzB,CACEtrB,SAAUkB,SAIdzJ,KAAAia,MAAA4Z,cAAA,MAIJjR,2BAAyB,IAARhb,EAAQrB,EAARqB,KACf,OAAOlH,OAAAC,OAAAiH,EAAoB,CAEzBI,OAASJ,UAAeA,SAAhB+nB,MAAqC/nB,EAAKI,YAItDuZ,wBACE,MAAO,CACL,IAAAuS,GACE9zB,KADF8Z,MAEE9Z,KAAAyhB,iBAAsB,CACpB7T,GADoB,QAGpBsB,KAAMlP,KAAA8Z,MAAW5K,QAGrB,IAAIlP,KAAA8Z,MAAJsX,YACEpxB,KAAAyhB,iBACE/gB,OAAAC,OAAA,GAAkBX,KAAA8Z,MAAlBuX,iBAA+C,CAC7CzjB,GAD6C,UAE7CsB,KAAMlP,KAAAia,MAFuC4X,QAG7CxO,UAAWrjB,KAAA8Z,MAHkCuJ,UAI7C7G,KAAMxc,KAAA8Z,MAJuC0C,KAK7CD,UAL6C,EAM7C0G,WAAY,CACV8Q,OADU,EAEV9J,WAAW,OAKnBjqB,KAAAia,MAAA4Z,eACE,IAAAjQ,EAAA,EAAqB,CACnBhW,GAAO5N,KAAA8Z,MAALlM,GADiB,aAEnBsB,KAAMlP,KAAAia,MAFa4Z,cAGnBrX,KAAMxc,KAAA8Z,MAAW0C,YAzGkBjB,KA+G7CqW,+BACAA,uBClJqBoC,6FASnBzS,wBAAe,IAAAuD,EACgE9kB,KADhE8Z,MACLlM,EADKkX,EAAAlX,GACD2P,EADCuH,EAAAvH,aACa0W,EADbnP,EAAAmP,eAC6BC,EAD7BpP,EAAAoP,eAC6CvS,EAD7CmD,EAAAnD,eAIb,MAAO,CAEL,IAAAiC,EAAA,EAAAljB,OAAAC,OAAA,GACKX,KADL8Z,MAAA,CAEElM,GAAOA,EAFT,QAGEsB,KAAMlP,KAAA8Z,MAHR5K,KAIEsU,SAJFyQ,EAKEtS,eAAcjhB,OAAAC,OAAA,GAAAghB,EAAA,CAEZ6B,SAAU7B,EAAesS,oBAI7B,IAAArQ,EAAA,EAAAljB,OAAAC,OAAA,GACKX,KADL8Z,MAAA,CAEElM,GAAOA,EAFT,SAGEsB,KAAMlP,KAAA8Z,MAHR5K,KAIEsU,SAJFjG,EAKEC,UALF0W,EAME3X,UANF,EAOEoF,eAAcjhB,OAAAC,OAAA,GAAAghB,EAAA,CAEZ6B,SAAU7B,EAFEpE,aAGZC,UAAWmE,EAAeuS,yBApCkB3Y,KAAjCyY,GACZhR,UAAY,2BADAgR,GAEZ5X,8BACF+X,IAAiB/X,cACpBmB,aAAc,SAAAoG,GAAC,MAAI,OAAJ,MACfsQ,eAAgB,SAAAtQ,GAAC,MAAI,aAAJ,MACjBuQ,eAAgB,SAAAvQ,GAAC,YCCrB,IAAayQ,GAAb,SAAAprB,GAIE,SAAAorB,EAAAC,EAAApd,GAAgE,IAAA7M,EAAA,gBAAtB6M,MAAkB,KAC1D7M,EAAApB,EAAA4D,KAAA5M,aACAq0B,WACAjqB,EAAA6M,UAH8D7M,EAJlEjB,IAAAirB,EAAAprB,GAAA,IAAA/I,EAAAm0B,EAAAl0B,UAAA,OAAAD,EAAAq0B,UAUEA,cACE,IAAA9hB,OAD8E,IAAvC+hB,MAA8B,MAGrE,IAAK,IAAIzrB,EAAT,EAAgBA,EAAI9I,KAAAq0B,SAApB9yB,SACEiR,EAASgiB,EAASx0B,KAAAq0B,SAAlB7hB,IACI+hB,GAAaA,EAAH/hB,IAAdA,GAFwC1J,KAO1C,OAAA0J,GApBJvS,EAAAiD,qBAuBEA,YACElD,KAAAq0B,SAAA7gB,QAAsB,SAAAvG,GAAO,OAAIA,uBAAJlN,MAxBjCE,EAAA2D,cA2BEA,YACE5D,KAAAq0B,SAAA7gB,QAAsB,SAAAvG,GAAO,OAAIA,gBAAJpJ,MA5BjC5D,EAAA8D,0BA+BEA,YACE/D,KAAAq0B,SAAA7gB,QAAsB,SAAAvG,GAAO,OAAIA,4BAAJjJ,MAhCjC/D,EAAAgE,iBAmCEA,YACEjE,KAAAq0B,SAAA7gB,QAAsB,SAAAvG,GAAO,OAAIA,mBAAJ9I,MApCjClE,EAAAiH,YAuCEA,YACE,OAAOlH,KAAAs0B,UAAe,SAAArnB,GAAO,OAAIA,cAAJ7F,MAxCjCnH,EAAAqH,kBA2CEA,YACE,OAAOtH,KAAAs0B,UACL,SAAArnB,GAAO,OAAIA,oBAAJ7F,IACP,SAAAoL,GAAM,OAAIA,GAAU3G,QAAQ2G,EAAtBjL,eA9CZtH,EAAAwH,oBAkDEA,YACE,OAAOzH,KAAAs0B,UAAe,SAAArnB,GAAO,OAAIA,sBAAJ7F,MAnDjCnH,EAAAyH,mBAsDEA,YACE,OAAO1H,KAAAs0B,UAAe,SAAArnB,GAAO,OAAIA,qBAAJ7F,MAvDjCnH,EAAAwE,oBA0DEA,WACE,OAAOzE,KAAAs0B,UAAe,SAAArnB,GAAO,OAAIA,EAAJxI,yBA3DjCxE,EAAA2E,eA8DEA,cAIE,OAAO5E,KAAAs0B,UACL,SAAArnB,GAAO,OAAIA,mBAAJ5F,IACP,SAAAiB,GAAO,OAAIpC,kBAA0BoC,SAA9B,KApEbrI,EAAA4E,UAwEEA,YAA2D,IAA/CE,EAA+CD,EAA/CC,WACV,OAAO/E,KAAAs0B,UAAe,SAAArnB,GAAO,OAAIA,EAAApI,UAAkB,CAAEE,kBAzEzDqvB,EAAA,CAAAhrB,8BCF+BqrB,GAAA,IAC5B90B,GAAmB,CAAE6vB,SAAF,EAAkBC,UAAU,GADnBgF,GAE5B90B,GAAsB,CAAE6vB,SAAF,EAAiBC,UAAU,GAFrBgF,GAG5B90B,GAAuB,CAAE6vB,SAAF,EAAkBC,UAAU,GAHvBgF,GAI5B90B,GAAmB,CAAE6vB,SAAF,EAAiBC,UAAU,gDCXpCiF,GAAS,CACpBC,QAAS,CACPpsB,SADO,WAEPqsB,IAFO,GAGPC,KAHO,GAIPC,WAJO,QAKPC,QALO,GAMPC,aANO,EAOPC,OAPO,iBAQP1P,MARO,IASP2P,WATO,+BAUPC,SAAU,QAEZC,WAAY,CACVC,QADU,OAEVC,SAAU,QAEZC,mBAAoB,CAClBF,QADkB,OAElBG,aAFkB,MAGlBF,SAAU,QAEZG,eAAgB,CACdD,aADc,MAEdE,aAAc,kBAEhBC,YAAa,CACXC,UAAW,OAEbC,aAAc,CACZC,cAAe,cAINC,GAAa,SAAAjc,GAAK,OAAIkc,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAOxB,GAAOU,YAAatb,EAApCqc,WAClBC,GAAqB,SAAAtc,GAAK,OACrCkc,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAOxB,GAAOa,oBAAqBzb,EADHqc,WAG1BE,GAAe,SAAAvc,GAAK,OAAIkc,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAOxB,GAAOmB,cAAe/b,EAAtCqc,WACpBG,GAAiB,SAAAxc,GAAK,OAAIkc,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAOxB,GAAOiB,aAAc7b,EAArCqc,WACtBI,GAAiB,SAAAzc,GAAK,OAAIkc,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAOxB,GAAOe,yDCT1D,IAAMf,GAAS,CACb8B,aAAc,CACZC,WADY,UAEZpB,QAFY,OAGZ7P,OAAQ,SAEVkR,SAAU,CACRC,OAAQ,KAINC,GAAkB,CACtB/sB,QADsB,EAEtB2b,OAFsB,EAGtBqR,SAHsB,MAItBC,WAJsB,OAKtBC,MALsB,EAMtBxR,MANsB,EAOtByR,KAAM,IAGFC,GAAY,CAChB,CAAEC,SAAF,OAAoBC,MAAO,UAC3B,CACED,SADF,QAEEC,MAAO,mFAET,CACED,SADF,OAEEC,MAAO,sNAaT,CACED,SADF,YAEEC,MAAO,4BAILC,GAAwB,6JAA9B,2BAWMnY,GAAeve,OAAAC,OACnB,CACE02B,wBAAyB,IAAAC,GAAyB,CAChD,IADgDnX,GAEhD,IAFuBpT,MAK3BuU,gBAPFrC,cAUA,SAAAsY,GAAApb,GACE,OAAQA,EAAR/a,MACE,eACE,MAAO,WAAP,KACF,WACE,MAAO,WAAP,KACF,mBACA,QACE,MAAO,OAAP,UAIeo2B,eAanB,SAAAA,IAAc,IAAAptB,EAAA,OACZA,EAAAqtB,EAAA7qB,KAAA5M,aADY03B,kBAuBM,SAAAnrB,GAClBnC,EAAAoP,SAAc,CACZjN,SAAQ7L,OAAAC,OAAA,GAAOyJ,EAAA6P,MAAP1N,eAzBEnC,EAAAutB,cA6BE,SAAA/vB,GACdd,2BAD6Bc,GAGzB,SAAAwC,EAAA6P,MAAAoC,MAA8BjS,EAAA6P,MAAlC2d,gBAKAhwB,GACEd,sCAAsCc,EAD9BxC,OAIRgF,EAAAoP,SAAc,CAAE1N,uBAAwB,CAAClE,EAADxC,WAExC0B,YADK,4BAGLsD,EAAAoP,SAAc,CAAE1N,uBAAwB,QA7C9B1B,EAAAytB,QAiDJ,WACRztB,EAAA0tB,eAlDY1tB,EAAA2tB,YAqDA,SAAA32B,GACZ,UAAIA,EACFgJ,EAAAoP,SAAc,CACZwe,aADYC,GAEZnsB,uBAAwB,KAErB,YAAI1K,GACTgJ,EAAAoP,SAAc,CACZwe,aAAc,CACZ52B,KADY,oBAEZd,SAAU,CACR6W,IAAO,SAAD,SAAsB,CAAEH,MAAO,MACrCG,IAAO,SAAD,SAAsB,CAAEH,MAAO,MACrCG,IAAO,SAAD,SAAsB,CAAEH,MAAO,MACrCG,IAAO,SAAD,SAAsB,CAAEH,MAAO,QAGzClL,uBAAwB,MAnE5B1B,EAAA6P,MAAa,CACX1N,SADWqqB,GAEXoB,aAFWC,GAGX5b,KAHW,cAIXxY,WAJW,KAKXq0B,iBALW,EAMXpsB,uBANW,GAOXzD,eAPW,QAQXuvB,cAAe,MAXLxtB,sCAed+tB,6BACEC,8BAAkCp4B,KAAlCo4B,YAGFC,gCACED,iCAAqCp4B,KAArCo4B,YAuDFE,2CAAiE,IAAAzpB,EAAA7O,KACvD8L,EAA2B9L,KAD4Bia,MAAAnO,uBAE/D,OACEkqB,EAAAvtB,EAAAwtB,cAAAsC,GAAA,CAAcC,IAAKpzB,GACjB4wB,EAAAvtB,EAAAwtB,cAAA,aACED,EAAAvtB,EAAAwtB,cAAA,SACEC,MAAOxB,GADTgC,SAEEt1B,KAFF,WAGEq3B,QAAS3sB,WAHX1G,GAIEszB,SAAU,WACJ5sB,WAAJ1G,GACEyJ,EAAA2K,SAAc,CACZ1N,uBAAwBA,EAAAkD,OAA8B,SAAAkX,GAAC,OAAIA,IAAJ9gB,MAGzDyJ,EAAA2K,SAAc,CACZ1N,uBAAsB,GAAAzJ,OAAAyJ,EAAA,CAAA1G,SAZhCA,EAAA,KAFJuzB,OA2BFC,0CAKE,IAL+B,IAEbt4B,EACdN,KAH2Bia,MAAA+d,aAAA13B,SAIzBu4B,EAAN,GACS/vB,EAAT,EAAgBA,EAAIxI,EAApBiB,SAAAuH,EACE+vB,OAAgB74B,KAAAs4B,6BAAAxvB,EAAqCxI,cAArDu4B,OAEF,OAAAA,KAGFC,2CAAkC,IAAAC,EAAA/4B,KAEhC,OACEg2B,EAAAvtB,EAAAwtB,cAAA+C,GAAA,CAAYR,IAAI,qBACdxC,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,iDAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KAJe,sBAAnB,gBAKOx1B,IAAe,SAAAy1B,GAAS,OACvBlD,EAAAvtB,EAAAwtB,cAAA,UACEuC,IADFU,EAEEhD,MAAO,CACLiD,gBACEJ,EAAA9e,MAAApW,YAAyBk1B,EAAA9e,MAAApW,WAAAgD,mBAAzBqyB,EAAA,UAEI,IAERE,QAAS,WACHL,EAAA9e,MAAApW,YAAyBk1B,EAAA9e,MAAApW,WAAAgD,mBAA7BqyB,EACEH,EAAAvf,SAAc,CAAE3V,WAAY,OAE5Bk1B,EAAAvf,SAAc,CAAE3V,WAAY,CAAEgD,iBAAkBqyB,OAb/BA,UAyBjCG,6CAAoC,IAAAC,EAAAt5B,KAClC,OACEg2B,EAAAvtB,EAAAwtB,cAAA+C,GAAA,CAAYR,IAAI,kBACdxC,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,4BAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,WAEEq3B,QAAS5sB,QAAQ7L,KAAAia,MAAApW,YAAyB7D,KAAAia,MAAApW,WAF5C0O,aAGEmmB,SAAU,SAAAtxB,GAAK,OACbkyB,EAAA9f,SAAc,CACZ3V,WAAY,CACV0O,YAAa1G,QAAQzE,SAADqxB,oBAUpCc,qCAA4B,IAAAC,EAAAx5B,KAC1B,OACEg2B,EAAAvtB,EAAAwtB,cAAA+C,GAAA,CAAYR,IAAI,UACdxC,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,yBAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,WAEEq3B,QAASz4B,KAAAia,MAFXie,gBAGEQ,SAAU,kBAAMc,EAAAhgB,SAAc,CAAE0e,iBAAkBsB,EAAAvf,MAAWie,0BAOvEuB,oCAA2B,IAAAC,EAAA15B,KACzB,OACEg2B,EAAAvtB,EAAAwtB,cAAA+C,GAAA,CAAYR,IAAI,SACdxC,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,oBAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,WAEEq3B,QAAS5sB,QAAQ7L,KAAAia,MAAApW,YAAyB7D,KAAAia,MAAApW,WAF5C8Q,cAGE+jB,SAAU,SAAAtxB,GAAK,OACbsyB,EAAAlgB,SAAc,CAAE3V,WAAY,CAAE8Q,aAAc9I,QAAQzE,SAADqxB,oBAQ/DkB,mCAA0B,IAAAC,EAAA55B,KAClB+N,EAAc/N,KAAAia,MAAApW,YAAyB7D,KAAAia,MAAApW,WAA1BkK,YAAnB,EACA,OACEioB,EAAAvtB,EAAAwtB,cAAA,OAAKuC,IAAI,QACPxC,EAAAvtB,EAAAwtB,cAAA+C,GAAA,KACEhD,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,mBAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,WAEEq3B,QAAS5sB,QAAQ7L,KAAAia,MAAApW,YAAyB7D,KAAAia,MAAApW,WAF5CuL,gBAGEspB,SAAU,SAAAtxB,GACR,IAAMvD,EAAUnD,OAAAC,OAAA,GACXi5B,EAAA3f,MADWpW,WAAA,CAEdkK,WAFcA,EAGdqB,eAAgBvD,QAAQzE,SAADqxB,WAEzBmB,EAAApgB,SAAc,CAAE3V,oBAMxBmyB,EAAAvtB,EAAAwtB,cAAA+C,GAAA,KACEhD,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,eAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,QAEE+K,IAFF,IAGEE,IAHF,KAIEwtB,KAJF,IAKEnzB,MALFqH,EAME2qB,SAAU,SAAAtxB,GACRwyB,EAAApgB,SAAc,CACZ3V,WAAUnD,OAAAC,OAAA,GACLi5B,EAAA3f,MADKpW,WAAA,CAERkK,WAAY+rB,WAAW1yB,SAADV,cAK9BsvB,EAAAvtB,EAAAwtB,cAAA,WAtCRloB,SA6CFgsB,qCACE,IAAMC,EAAN,GAkBA,OAhBI5C,WAA8Bp3B,KAAAia,MAA9Bmd,OAAJ,GACE4C,OAAch6B,KAAdg6B,mCAEF,mBAAIh6B,KAAAia,MAAAoC,MACF2d,OAAch6B,KAAdg6B,qCAEF,WAAIh6B,KAAAia,MAAAoC,MACF2d,OAAch6B,KAAdg6B,6BAEF,UAAIh6B,KAAAia,MAAAoC,MACF2d,OAAch6B,KAAdg6B,4BAEF,cAAIh6B,KAAAia,MAAAoC,MACF2d,OAAch6B,KAAdg6B,2BAGFA,KAGFC,0BAAiB,IAAAC,EAAAl6B,KACf,OACEg2B,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAOiE,GAAcxF,SACvBsC,GAAAxzB,IAAc,SAAAyzB,GAAQ,OACrBlB,EAAAvtB,EAAAwtB,cAAAmE,GAAA,CAAoB5B,IAAKtB,EAASA,UAChClB,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAO,CAAEmE,aAAc,QAAUnD,EAAtCA,SADF,UAEGA,EAAAC,MAAA1zB,IAAmB,SAAA4Y,GAAI,OACtB2Z,EAAAvtB,EAAAwtB,cAAA,UACEuC,IADFnc,EAEE6Z,MAAO,CACLS,OADK,MAGLwC,gBAAiBe,EAAAjgB,MAAAoC,SAAA,UAAuC,IAE1D+c,QAAS,WACPc,EAAA1gB,SAAc,CAAE6C,KAAFA,EAAQxY,WAAR,GAAwB+zB,cAAe,SATnCvb,QAiB3Brc,KArBH+5B,4BAsBE/D,EAAAvtB,EAAAwtB,cAAAqE,GAtBF,MAuBEtE,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KAvBF,WAwBEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,YACEroB,GADF,gBAEE2sB,KAFF,EAGErE,MAAO,CAAE3Q,MAAO,QAChB7e,MAAO8zB,eAAex6B,KAAAia,MAJxB+d,cAKEU,SAAU,SAAAtxB,GAAK,OAAI8yB,EAAA1gB,SAAc,CAAEwe,aAAcwC,WAAWpzB,SAAXozB,aAGrDxE,EAAAvtB,EAAAwtB,cAAAqE,GAjCF,MAkCEtE,EAAAvtB,EAAAwtB,cAAA+C,GAAA,KACEhD,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,oBAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,UAAQmD,QAAS,kBAAMc,EAAAnC,YAAN,WADnB,SAEE/B,EAAAvtB,EAAAwtB,cAAA,UAAQmD,QAAS,kBAAMc,EAAAnC,YAAN,aAtCvB,aA0CE/B,EAAAvtB,EAAAwtB,cAAA+C,GAAA,KACEhD,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,aAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,WAEEq3B,QAFF,SAEWz4B,KAAAia,MAAA5R,eACTqwB,SAAU,kBACRwB,EAAA1gB,SAAc,CACZnR,eAAgB,SAAA6xB,EAAAjgB,MAAA5R,eAAA,QAAiD,cAO3E2tB,EAAAvtB,EAAAwtB,cAAA+C,GAAA,KACEhD,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,+BAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,WAEEq3B,QAFF,aAEWz4B,KAAAia,MAAA5R,eACTqwB,SAAU,kBACRwB,EAAA1gB,SAAc,CACZnR,eAAgB,aAAA6xB,EAAAjgB,MAAA5R,eAAA,QAAqD,kBAO/E2tB,EAAAvtB,EAAAwtB,cAAA+C,GAAA,KACEhD,EAAAvtB,EAAAwtB,cAAAsC,GAAA,KADF,mBAEEvC,EAAAvtB,EAAAwtB,cAAAgD,GAAA,KACEjD,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,SAEEsF,MAFF,QAGE0yB,QAAS,kBACPc,EAAA1gB,SAAc,CAAE1N,uBAAF,GAA8B8rB,cAAeh4B,OAG/Do2B,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,SAEEsF,MAFF,OAGE0yB,QAAS,kBACPc,EAAA1gB,SAAc,CAAE6C,KAAF,OAAgBub,cAAeh4B,OAGjDo2B,EAAAvtB,EAAAwtB,cAAA,SACE70B,KADF,SAEEsF,MAFF,QAGE0yB,QAAS,kBAAMc,EAAA1gB,SAAc,CAAE6C,KAAF,OAAgBub,cAAeh4B,SAIlEo2B,EAAAvtB,EAAAwtB,cAAAmE,GAAA,KAAqBp6B,KAjGzB44B,sCAsGF6B,4BACE,OAAOzE,EAAAvtB,EAAAwtB,cAAAyE,EAAA,EAAPnuB,MAGFouB,gCAEAnN,kBAAS,IAAAoN,EAAA56B,KAAA6pB,EAC4D7pB,KAD5Dia,MACC+d,EADDnO,EAAAmO,aACelsB,EADf+d,EAAA/d,uBACuCuQ,EADvCwN,EAAAxN,KAC6CxY,EAD7CgmB,EAAAhmB,WAGD0I,EAAQ7L,OAAAC,OAAA,GACTX,KAAAia,MADS1N,SAAA,CAEZiZ,OAAQ4S,IAFIyC,YAGZtV,MAAO6S,IAAO0C,aAGVC,EAAuB,IAAArU,GAAyB,CACpD9Y,GADoD,UAEpDsB,KAFoD8oB,EAGpDlsB,uBAHoDA,EAIpDmT,aAJoDA,GAKpD5C,KALoDA,EAMpDxY,WANoDA,EAOpDugB,eAPoD,EAUpD9H,OAAQ,SAAAxX,GAA4D,IAAzDU,EAAyDV,EAAzDU,YAAaE,EAA4CZ,EAA5CY,SAAUC,EAAkCb,EAAlCa,eAAgBC,EAAkBd,EAAlBc,YAC5Co1B,EAAgCJ,EAAA3gB,MAApCnO,uBAEG,gEAAAtB,SADH9E,IAKEoB,6BAEEpB,sBAAkCk1B,EAAA3gB,MAAtCie,mBAKIxyB,kBAAJ,cAAiC2W,IAE/B2e,EAA6B,GAAA34B,OAAOu4B,EAAA3gB,MAAPnO,uBAA7BkvB,IAEFJ,EAAAphB,SAAc,CACZwe,aADYxyB,EAEZsG,uBAAwBkvB,MAK5B3yB,eACE,aAAArI,KAAAia,MAAA5R,eAAA4yB,GAEIj7B,KAAAia,MAtC8C5R,eAuCpDqW,oBAvCoDwc,GAAAzyB,EAwCpDkW,sBAAuB,CACrBwc,aAAc,CACZhtB,EADY,EAEZC,EAFY,EAGZmX,MAHY,GAIZC,OAJY,GAKZ4V,MAAM,GAERC,SAAU,CACRltB,EADQ,GAERC,EAFQ,EAGRmX,MAHQ,GAIRC,OAJQ,GAKR4V,MAAM,IAGVvc,kBAAmB,SAAA8E,GAAC,OAAIA,EAAJviB,MACpB0d,sBAzDoD,GA0DpDC,uBA1DoDwY,GA6DpD3a,mBA7DoD,EA8DpDM,qBA9DoD,EA+DpDU,iBAAkB,iBAAM,GAAN,IAGlBL,aAAc,SAAA/a,EAAA8a,GACZ,OAAOA,EAAa,WAAH,KAA8B,UAA/C,KAEFD,aAAc,SAAA7a,EAAA8a,GACZ,OAAOA,EAAa,UAAH,KAA8B,UAA/C,MAIFkB,wBA1EoD+Y,GA2EpDpZ,2BA3EoD,EA8EpDN,0BAA2B,iBAAM,GAAN,IAC3BC,sBAAuB,iBAAM,aAAN,MAEvBmF,WAAY,CACVgH,WADU,EAEVqR,WAFU,EAIVvH,OAJU,EAKV7J,cAAenB,IALLwS,SAMVC,UAAW,CAACzS,IAAD0S,UAAe1S,IAAf2S,wBAIThuB,EAAS,CAAfqtB,GAsBA,OApBI/6B,KAAAia,MAAJ2d,eACElqB,OACE,IAAAiuB,GAAmB,CACjB/tB,GADiB,YAEjB4W,cAAexkB,KAAAia,MAFE2d,cAGjBnT,SAAU,SAAAtf,GAAsB,IAAnBkgB,EAAmBlgB,EAAnBkgB,aACXuV,EAAAphB,SAAc,CAAE1N,uBAAwBuZ,EAAA5hB,IAAiB,SAAAm4B,GAAE,OAAIA,EAAJx2B,WAE7DiJ,SAAU,CANO,WAQjB0P,sBAAuB,iBAAM,WAAN,MACvBD,sBAAuB,iBAAM,SAAN,MACvBD,0BAA2B,iBAAM,GAAN,IAC3BjB,mBAAoB,KAK1B5c,KAAA26B,gBAAAjtB,GAGEsoB,EAAAvtB,EAAAwtB,cAAA,OAAKC,MAAOxB,GAAO8B,cACjBR,EAAAvtB,EAAAwtB,cAAA,QAAM4F,KAAN,4DAAuEC,IAAI,eAC3E9F,EAAAvtB,EAAAwtB,cAAA8F,EAAA,GACEC,UADFzvB,EAEE1H,UAAWk2B,iBAFbA,GAGErtB,OAHFA,EAIEuuB,MACE,IAAAC,EAAA,EAAY,CACVtuB,GADU,UAEVuuB,WAAY,CACV/6B,KADU86B,EAAA,EAEVE,gBAAiB,SAAAp8B,KAAAia,MAAAoC,OAA+Brc,KAAAia,MAAW2d,iBAIjEwB,QAASp5B,KAbX23B,cAcE0E,kBAAmB,SAAA91B,GAAA,IAAGy1B,EAAHz1B,EAAAy1B,UAAA,OAAmBpB,EAAAphB,SAAc,CAAEjN,SAAUyvB,MAE/Dh8B,KAAAy6B,gBAlBLluB,IAoBGvM,KArBLi6B,sBAhgBiCqC,izHClHrCC,EAAAC,QAAA","file":"component---examples-deck-example-js-33759d8dc5342988f791.js","sourcesContent":["// @flow\n// Describes the arrow style of polylines\nexport const ArrowStyles = {\n  NONE: 0,\n  FORWARD: 1,\n  BACKWARD: 2,\n  BOTH: 3\n};\n\nexport const DEFAULT_ARROWS = 1;\nexport const MAX_ARROWS = 3;\n\nexport const DEFAULT_STYLE = {\n  arrowColor: [0, 0, 0, 1],\n  arrowCount: DEFAULT_ARROWS,\n  arrowStyle: ArrowStyles.NONE,\n  fillColor: [0, 0, 0, 1],\n  lineColor: [0, 0, 0, 1],\n  lineWidthMeters: 5,\n  outlineRadiusMeters: 0,\n  opacity: 1,\n  zLevel: 0\n};\n","// @flow\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { point, polygon } from '@turf/helpers';\nimport turfBbox from '@turf/bbox';\nimport turfBboxPolygon from '@turf/bbox-polygon';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\nimport turfDistance from '@turf/distance';\n\nconst POLYGON_LINE_COLOR = [0, 255, 0, 255];\nconst POLYGON_FILL_COLOR = [255, 255, 255, 90];\nconst POLYGON_LINE_WIDTH = 2;\nconst POLYGON_DASHES = [20, 20];\nconst POLYGON_THRESHOLD = 0.01;\nconst EXPANSION_KM = 10;\nconst LAYER_ID_VIEW = 'DeckDrawerView';\nconst LAYER_ID_PICK = 'DeckDrawerPick';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nexport default class DeckDrawer {\n  nebula: Object;\n  usePolygon: boolean;\n  validPolygon: boolean;\n  landPoints: [number, number][];\n  mousePoints: [number, number][];\n\n  constructor(nebula: Object) {\n    this.nebula = nebula;\n    this.usePolygon = false;\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _getLayerIds() {\n    // TODO: sort by mouse priority\n    return this.nebula.deckgl.props.layers\n      .filter(l => l && l.props && l.props.nebulaLayer && l.props.nebulaLayer.enableSelection)\n      .map(l => l.id);\n  }\n\n  _selectFromPickingInfos(pickingInfos: Object[]) {\n    const objects = pickingInfos.map(\n      ({ layer, index, object }) =>\n        object.original || layer.props.nebulaLayer.deckCache.originals[index]\n    );\n    this.nebula.props.onSelection(objects);\n  }\n\n  _getBoundingBox(): Object {\n    const { mousePoints } = this;\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    return { x, y, width: maxX - x, height: maxY - y };\n  }\n\n  _selectRectangleObjects() {\n    if (this.landPoints.length !== 2) return;\n\n    const [x1, y1] = this.mousePoints[0];\n    const [x2, y2] = this.mousePoints[1];\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds: this._getLayerIds()\n    });\n\n    this._selectFromPickingInfos(pickingInfos);\n  }\n\n  _selectPolygonObjects() {\n    const pickingInfos = this.nebula.deckgl.pickObjects({\n      ...this._getBoundingBox(),\n      layerIds: [LAYER_ID_PICK, ...this._getLayerIds()]\n    });\n\n    this._selectFromPickingInfos(pickingInfos.filter(item => item.layer.id !== LAYER_ID_PICK));\n  }\n\n  _getMousePosFromEvent(event: Object): [number, number] {\n    const { offsetX, offsetY } = event;\n    return [offsetX, offsetY];\n  }\n\n  handleEvent(\n    event: Object,\n    lngLat: [number, number],\n    selectionType: number\n  ): { redraw: boolean, deactivate: boolean } {\n    // capture all events (mouse-up is needed to prevent us stuck in moving map)\n    if (event.type !== 'mouseup') event.stopPropagation();\n\n    this.usePolygon = selectionType === SELECTION_TYPE.POLYGON;\n\n    let redraw = false;\n    let deactivate = false;\n\n    const { usePolygon, landPoints, mousePoints } = this;\n\n    if (event.type === 'mousedown') {\n      if (usePolygon && landPoints.length) {\n        // if landPoints.length is zero we want to insert two points (so we let it run the else)\n        // also don't insert if polygon is invalid\n        if (this.landPoints.length < 3 || this.validPolygon) {\n          landPoints.push(lngLat);\n          mousePoints.push(this._getMousePosFromEvent(event));\n        }\n      } else {\n        this.landPoints = [lngLat, lngLat];\n        const m = this._getMousePosFromEvent(event);\n        this.mousePoints = [m, m];\n      }\n      redraw = true;\n    } else if (event.type === 'mousemove' && landPoints.length) {\n      // update last point\n      landPoints[landPoints.length - 1] = lngLat;\n      mousePoints[mousePoints.length - 1] = this._getMousePosFromEvent(event);\n      redraw = true;\n    } else if (event.type === 'mouseup') {\n      if (usePolygon) {\n        // check to see if completed\n        // TODO: Maybe double-click to finish?\n        if (\n          landPoints.length > 4 &&\n          turfDistance(landPoints[0], landPoints[landPoints.length - 1]) < POLYGON_THRESHOLD &&\n          this.validPolygon\n        ) {\n          this._selectPolygonObjects();\n          this.reset();\n          redraw = true;\n          deactivate = true;\n        }\n      } else {\n        this._selectRectangleObjects();\n        this.reset();\n        redraw = true;\n        deactivate = true;\n      }\n    }\n\n    return { redraw, deactivate };\n  }\n\n  reset() {\n    this.landPoints = [];\n    this.mousePoints = [];\n  }\n\n  _makeStartPointHighlight(center: [number, number]): number[] {\n    const buffer = turfBuffer(point(center), POLYGON_THRESHOLD / 4.0);\n    return turfBboxPolygon(turfBbox(buffer)).geometry.coordinates;\n  }\n\n  render() {\n    const data = [];\n    const dataPick = [];\n\n    if (!this.usePolygon && this.landPoints.length === 2) {\n      // Use mouse points instead of land points so we get the right shape\n      // no matter what bearing is.\n      const [[x1, y1], [x2, y2]] = this.mousePoints;\n      const selPolygon = [[x1, y1], [x1, y2], [x2, y2], [x2, y1], [x1, y1]].map(mousePos =>\n        this.nebula.unprojectMousePosition(mousePos)\n      );\n      data.push({\n        polygon: selPolygon,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n    } else if (this.usePolygon && this.landPoints.length) {\n      data.push({\n        polygon: this.landPoints,\n        lineColor: POLYGON_LINE_COLOR,\n        fillColor: POLYGON_FILL_COLOR\n      });\n\n      // Hack: use a polygon to hide the outside, because pickObjects()\n      // does not support polygons\n      if (this.landPoints.length >= 3) {\n        const landPointsPoly = polygon([[...this.landPoints, this.landPoints[0]]]);\n        const bigBuffer = turfBuffer(point(this.landPoints[0]), EXPANSION_KM);\n        let bigPolygon;\n        try {\n          // turfDifference throws an exception if the polygon\n          // intersects with itself\n          bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n          dataPick.push({\n            polygon: bigPolygon.geometry.coordinates,\n            fillColor: [0, 0, 0, 1]\n          });\n          this.validPolygon = true;\n        } catch (e) {\n          // invalid selection polygon\n          this.validPolygon = false;\n        }\n      }\n    }\n\n    if (this.landPoints.length) {\n      // highlight start point\n      data.push({\n        polygon: this._makeStartPointHighlight(this.landPoints[0]),\n        lineColor: [0, 0, 0, 0],\n        fillColor: POLYGON_LINE_COLOR\n      });\n    }\n\n    // Hack to make the PolygonLayer() stay active,\n    // otherwise it takes 3 seconds (!) to init!\n    // TODO: fix this\n    data.push({ polygon: [[0, 0]] });\n    dataPick.push({ polygon: [[0, 0]] });\n\n    return [\n      new PolygonLayer({\n        id: LAYER_ID_VIEW,\n        data,\n        fp64: false,\n        opacity: 1.0,\n        pickable: false,\n        lineWidthMinPixels: POLYGON_LINE_WIDTH,\n        lineWidthMaxPixels: POLYGON_LINE_WIDTH,\n        lineDashJustified: true,\n        getLineDashArray: x => POLYGON_DASHES,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        getPolygon: o => o.polygon\n      }),\n      new PolygonLayer({\n        id: LAYER_ID_PICK,\n        data: dataPick,\n        getLineColor: obj => obj.lineColor || [0, 0, 0, 255],\n        getFillColor: obj => obj.fillColor || [0, 0, 0, 255],\n        fp64: false,\n        opacity: 1.0,\n        stroked: false,\n        pickable: true,\n        getPolygon: o => o.polygon\n      })\n    ];\n  }\n}\n","// @flow\nimport EventEmitter from 'events';\nimport uuid from 'uuid';\n\nimport Feature from './feature';\n\nexport default class NebulaLayer extends EventEmitter {\n  getData: () => Object[];\n  toNebulaFeature: (data: Object) => Feature;\n  id: string;\n  helperLayers: Object[];\n\n  // flags\n  usesMapEvents: boolean = false;\n  enablePicking: boolean = false;\n  enableSelection: boolean = false;\n  //\n\n  constructor({ getData, on, toNebulaFeature }: Object) {\n    super();\n    this.id = uuid.v4();\n    this.getData = getData;\n    this.toNebulaFeature = toNebulaFeature;\n    this.helperLayers = [];\n\n    if (on) {\n      Object.keys(on).forEach(key => this.on(key, on[key]));\n    }\n  }\n\n  render(config: Object): mixed {\n    return null;\n  }\n}\n","// @flow\n\nimport type {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  Polygon,\n  MultiLineString,\n  MultiPolygon,\n  Position,\n  PolygonCoordinates\n} from './geojson-types.js';\n\nexport class ImmutableFeatureCollection {\n  featureCollection: FeatureCollection;\n\n  constructor(featureCollection: FeatureCollection) {\n    this.featureCollection = featureCollection;\n  }\n\n  getObject() {\n    return this.featureCollection;\n  }\n\n  /**\n   * Replaces the position deeply nested withing the given feature's geometry.\n   * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position to replace\n   * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n   */\n  replacePosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    updatedPosition: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyReplacePosition(\n        geometry.coordinates,\n        positionIndexes,\n        updatedPosition,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion to remove\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  removePosition(featureIndex: number, positionIndexes: number[]): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw Error(`Can't remove a position from a Point or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'MultiPoint' &&\n      // only 1 point left\n      geometry.coordinates.length < 2\n    ) {\n      throw Error(`Can't remove the last point of a MultiPoint or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'LineString' &&\n      // only 2 positions\n      geometry.coordinates.length < 3\n    ) {\n      throw Error(`Can't remove position. LineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'Polygon' &&\n      // outer ring is a triangle\n      geometry.coordinates[0].length < 5 &&\n      // trying to remove from outer ring\n      positionIndexes[0] === 0\n    ) {\n      throw Error(`Can't remove position. Polygon's outer ring must have at least four positions`);\n    }\n    if (\n      geometry.type === 'MultiLineString' &&\n      // only 1 LineString left\n      geometry.coordinates.length === 1 &&\n      // only 2 positions\n      geometry.coordinates[0].length < 3\n    ) {\n      throw Error(`Can't remove position. MultiLineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'MultiPolygon' &&\n      // only 1 polygon left\n      geometry.coordinates.length === 1 &&\n      // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 &&\n      // trying to remove from first polygon\n      positionIndexes[0] === 0 &&\n      // trying to remove from outer ring\n      positionIndexes[1] === 0\n    ) {\n      throw Error(\n        `Can't remove position. MultiPolygon's outer ring must have at least four positions`\n      );\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)\n    };\n\n    // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n    pruneGeometryIfNecessary(updatedGeometry);\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion that will preceed the new position\n   * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  addPosition(\n    featureIndex: number,\n    positionIndexes: number[],\n    positionToAdd: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw new Error('Unable to add a position to a Point feature');\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyAddPosition(\n        geometry.coordinates,\n        positionIndexes,\n        positionToAdd,\n        isPolygonal\n      )\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  replaceGeometry(featureIndex: number, geometry: Geometry): ImmutableFeatureCollection {\n    const updatedFeature: any = {\n      ...this.featureCollection.features[featureIndex],\n      geometry\n    };\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [\n        ...this.featureCollection.features.slice(0, featureIndex),\n        updatedFeature,\n        ...this.featureCollection.features.slice(featureIndex + 1)\n      ]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  addFeature(feature: Feature): ImmutableFeatureCollection {\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [...this.featureCollection.features, feature]\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n}\n\nfunction getUpdatedPosition(updatedPosition: Position, previousPosition: Position): Position {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    const elevation = (previousPosition: any)[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  updatedPosition: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyReplacePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      updatedPosition,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyRemovePosition(\n  coordinates: any,\n  positionIndexes: number[],\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      ...coordinates.slice(positionIndexes[0] + 1)\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyRemovePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction immutablyAddPosition(\n  coordinates: any,\n  positionIndexes: number[],\n  positionToAdd: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      positionToAdd,\n      ...coordinates.slice(positionIndexes[0])\n    ];\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyAddPosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      positionToAdd,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1)\n  ];\n}\n\nfunction pruneGeometryIfNecessary(geometry: Geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry: Polygon) {\n  const polygon = geometry.coordinates;\n\n  // If any hole is no longer a polygon, remove the hole entirely\n  for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry: MultiLineString) {\n  for (let lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    const lineString = geometry.coordinates[lineStringIndex];\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1);\n      // Keep the index the same\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry: MultiPolygon) {\n  for (let polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    const polygon = geometry.coordinates[polygonIndex];\n    const outerRing = polygon[0];\n\n    // If the outer ring is no longer a polygon, remove the whole polygon\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1);\n      // It was removed, so keep the index the same\n      polygonIndex--;\n    }\n\n    for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon: PolygonCoordinates, holeIndex: number) {\n  const hole = polygon[holeIndex];\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n  return false;\n}\n","// @flow\n\nimport turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\n\nimport type { FeatureCollection, Feature, Polygon, Geometry, Position } from '../geojson-types.js';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DeckGLPick\n} from '../event-types.js';\nimport { ImmutableFeatureCollection } from '../immutable-feature-collection.js';\n\nexport type EditHandleType = 'existing' | 'intermediate' | 'snap';\n\nexport type EditHandle = {\n  position: Position,\n  positionIndexes: number[],\n  featureIndex: number,\n  type: EditHandleType\n};\n\nexport type EditAction = {\n  updatedData: FeatureCollection,\n  editType: string,\n  featureIndexes: number[],\n  editContext: any\n};\n\nexport class ModeHandler {\n  // TODO: add underscore\n  featureCollection: ImmutableFeatureCollection;\n  _tentativeFeature: ?Feature;\n  _modeConfig: any = null;\n  _selectedFeatureIndexes: number[] = [];\n  _clickSequence: Position[] = [];\n  _context: Object;\n  _layerId: string;\n\n  constructor(featureCollection?: FeatureCollection) {\n    if (featureCollection) {\n      this.setFeatureCollection(featureCollection);\n    }\n  }\n\n  getFeatureCollection(): FeatureCollection {\n    return this.featureCollection.getObject();\n  }\n\n  getImmutableFeatureCollection(): ImmutableFeatureCollection {\n    return this.featureCollection;\n  }\n\n  getSelectedFeature(): ?Feature {\n    if (this._selectedFeatureIndexes.length === 1) {\n      return this.featureCollection.getObject().features[this._selectedFeatureIndexes[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(): ?Geometry {\n    const feature = this.getSelectedFeature();\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(): FeatureCollection {\n    const { features } = this.featureCollection.getObject();\n    const selectedFeatures = this.getSelectedFeatureIndexes().map(\n      selectedIndex => features[selectedIndex]\n    );\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures\n    };\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.featureCollection = new ImmutableFeatureCollection(featureCollection);\n  }\n\n  getModeConfig(): any {\n    return this._modeConfig;\n  }\n\n  setModeConfig(modeConfig: any): void {\n    if (this._modeConfig === modeConfig) {\n      return;\n    }\n\n    this._modeConfig = modeConfig;\n    this._setTentativeFeature(null);\n  }\n\n  getSelectedFeatureIndexes(): number[] {\n    return this._selectedFeatureIndexes;\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    if (this._selectedFeatureIndexes === indexes) {\n      return;\n    }\n\n    this._selectedFeatureIndexes = indexes;\n    this._setTentativeFeature(null);\n  }\n\n  setDeckGlContext(context: Object) {\n    this._context = context;\n  }\n\n  setLayerId(layerId: string) {\n    this._layerId = layerId;\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._tentativeFeature;\n  }\n\n  // TODO: remove the underscore\n  _setTentativeFeature(tentativeFeature: ?Feature): void {\n    this._tentativeFeature = tentativeFeature;\n    if (!tentativeFeature) {\n      // Reset the click sequence\n      this._clickSequence = [];\n    }\n  }\n\n  /**\n   * Returns a flat array of positions for the given feature along with their indexes into the feature's geometry's coordinates.\n   *\n   * @param featureIndex The index of the feature to get edit handles\n   */\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    return [];\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return 'cell';\n  }\n\n  isSelectionPicked(picks: DeckGLPick[]): boolean {\n    if (!picks.length) return false;\n    const pickedIndexes = picks.map(({ index }) => index);\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    return selectedFeatureIndexes.some(index => pickedIndexes.includes(index));\n  }\n\n  getAddFeatureAction(geometry: Geometry): EditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const geometryAsAny: any = geometry;\n\n    const updatedData = this.getImmutableFeatureCollection()\n      .addFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: geometryAsAny\n      })\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      featureIndexes: [updatedData.features.length - 1],\n      editContext: null\n    };\n  }\n\n  getAddManyFeaturesAction(featureCollection: FeatureCollection): EditAction {\n    const features = featureCollection.features;\n    let updatedData = this.getImmutableFeatureCollection();\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of features) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      featureIndexes: updatedIndexes,\n      editContext: null\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(geometry: Polygon): ?EditAction {\n    const selectedFeature = this.getSelectedFeature();\n    const modeConfig = this.getModeConfig();\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature = {\n        type: 'Feature',\n        geometry\n      };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = this.getSelectedFeatureIndexes()[0];\n\n      const updatedData = this.getImmutableFeatureCollection()\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: EditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        featureIndexes: [featureIndex],\n        editContext: null\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(geometry);\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    this._clickSequence.push(event.groundCoords);\n\n    return null;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    return { editAction: null, cancelMapPan: false };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    return null;\n  }\n}\n\nexport function getPickedEditHandle(picks: ?(any[])): ?EditHandle {\n  const info = picks && picks.find(pick => pick.isEditingHandle);\n  if (info) {\n    return info.object;\n  }\n  return null;\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0\n  ];\n  return intermediatePosition;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n) {\n  let handles: EditHandle[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          position: geometry.coordinates,\n          positionIndexes: [],\n          featureIndex,\n          type: editHandleType\n        }\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n      break;\n    default:\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandle[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      position,\n      positionIndexes: [...positionIndexPrefix, i],\n      featureIndex,\n      type: editHandleType\n    });\n  }\n  return editHandles;\n}\n","// @flow\n\nimport type { Position } from '../geojson-types.js';\nimport type { EditHandle } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class ViewHandler extends ModeHandler {\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    return [];\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { point } from '@turf/helpers';\nimport type { Position, LineString } from './geojson-types.js';\n\nexport function toDeckColor(\n  color?: ?[number, number, number, number],\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  groundCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  const pt = point(groundCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n","// @flow\n\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { point, lineString as toLineString } from '@turf/helpers';\nimport { recursivelyTraverseNestedArrays } from '../utils.js';\nimport type { Position } from '../geojson-types.js';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class ModifyHandler extends ModeHandler {\n  _lastPointerMovePicks: *;\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = [];\n    const { features } = this.featureCollection.getObject();\n\n    for (const index of this.getSelectedFeatureIndexes()) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index));\n      } else {\n        console.warn(`selectedFeatureIndexes out of range ${index}`); // eslint-disable-line no-console,no-undef\n      }\n    }\n\n    // intermediate edit handle\n    if (picks && picks.length && groundCoords) {\n      const existingEditHandle = picks.find(\n        pick => pick.isEditingHandle && pick.object && pick.object.type === 'existing'\n      );\n      // don't show intermediate point when too close to an existing edit handle\n      const featureAsPick = !existingEditHandle && picks.find(pick => !pick.isEditingHandle);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        !featureAsPick.object.geometry.type.includes('Point') &&\n        this.getSelectedFeatureIndexes().includes(featureAsPick.index)\n      ) {\n        let intermediatePoint = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(groundCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.nearestPointOnLine(\n              lineStringFeature,\n              referencePoint\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index }\n          } = intermediatePoint;\n          handles = [\n            ...handles,\n            {\n              position,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n              featureIndex: featureAsPick.index,\n              type: 'intermediate'\n            }\n          ];\n        }\n      }\n    }\n\n    return handles;\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  nearestPointOnLine(line: any, inPoint: any): any {\n    // TODO: implement 3D nearestPointOnLine\n    return nearestPointOnLine(line, inPoint);\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const clickedEditHandle = getPickedEditHandle(event.picks);\n\n    if (clickedEditHandle && clickedEditHandle.featureIndex >= 0) {\n      if (clickedEditHandle.type === 'existing') {\n        let updatedData;\n        try {\n          updatedData = this.getImmutableFeatureCollection()\n            .removePosition(clickedEditHandle.featureIndex, clickedEditHandle.positionIndexes)\n            .getObject();\n        } catch (ignored) {\n          // This happens if user attempts to remove the last point\n        }\n\n        if (updatedData) {\n          editAction = {\n            updatedData,\n            editType: 'removePosition',\n            featureIndexes: [clickedEditHandle.featureIndex],\n            editContext: {\n              positionIndexes: clickedEditHandle.positionIndexes,\n              position: clickedEditHandle.position\n            }\n          };\n        }\n      } else if (clickedEditHandle.type === 'intermediate') {\n        const updatedData = this.getImmutableFeatureCollection()\n          .addPosition(\n            clickedEditHandle.featureIndex,\n            clickedEditHandle.positionIndexes,\n            clickedEditHandle.position\n          )\n          .getObject();\n\n        if (updatedData) {\n          editAction = {\n            updatedData,\n            editType: 'addPosition',\n            featureIndexes: [clickedEditHandle.featureIndex],\n            editContext: {\n              positionIndexes: clickedEditHandle.positionIndexes,\n              position: clickedEditHandle.position\n            }\n          };\n        }\n      }\n    }\n    return editAction;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    this._lastPointerMovePicks = event.picks;\n\n    let editAction: ?EditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const updatedData = this.getImmutableFeatureCollection()\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'movePosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n\n    return { editAction, cancelMapPan };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle && editHandle.type === 'intermediate') {\n      const updatedData = this.getImmutableFeatureCollection()\n        .addPosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const updatedData = this.getImmutableFeatureCollection()\n        .replacePosition(editHandle.featureIndex, editHandle.positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'finishMovePosition',\n        featureIndexes: [editHandle.featureIndex],\n        editContext: {\n          positionIndexes: editHandle.positionIndexes,\n          position: event.groundCoords\n        }\n      };\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    const picks = this._lastPointerMovePicks;\n\n    if (picks && picks.length > 0) {\n      const handlePicked = picks.some(pick => pick.isEditingHandle);\n      if (handlePicked) {\n        return 'cell';\n      }\n    }\n\n    return isDragging ? 'grabbing' : 'grab';\n  }\n}\n","// @flow\nimport type { PointerMoveEvent, StopDraggingEvent } from '../event-types.js';\nimport type { Position } from '../geojson-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { getPickedEditHandle } from './mode-handler.js';\nimport { ModifyHandler } from './modify-handler.js';\n\nexport class ElevationHandler extends ModifyHandler {\n  makeElevatedEvent(event: PointerMoveEvent | StopDraggingEvent, position: Position): Object {\n    const { min = 0, max = 20000 } = this._modeConfig || {};\n\n    const [, yBot] = this._context.viewport.project([position[0], position[1], 0]);\n    const [, yTop] = this._context.viewport.project([position[0], position[1], 1000]);\n    const [, y] = event.screenCoords;\n\n    let elevation = ((yBot - y) * 1000.0) / (yBot - yTop);\n    elevation = Math.min(elevation, max);\n    elevation = Math.max(elevation, min);\n\n    return Object.assign({}, event, {\n      groundCoords: [position[0], position[1], elevation]\n    });\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n    const position = editHandle ? editHandle.position : event.groundCoords;\n    return super.handlePointerMove(this.makeElevatedEvent(event, position));\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    const editHandle = getPickedEditHandle(event.picks);\n    const position = editHandle ? editHandle.position : event.groundCoords;\n    return super.handleStopDragging(this.makeElevatedEvent(event, position));\n  }\n\n  getCursor(params: { isDragging: boolean }): string {\n    let cursor = super.getCursor(params);\n    if (cursor === 'cell') {\n      cursor = 'ns-resize';\n    }\n    return cursor;\n  }\n}\n","// @flow\n\nimport type { FeatureCollection, Position } from '../geojson-types.js';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditHandle, EditAction } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nconst DEFAULT_SNAP_PIXELS = 5;\n\ntype HandlePicks = { pickedHandle?: EditHandle, potentialSnapHandle?: EditHandle };\n\nexport class SnappableHandler extends ModeHandler {\n  _handler: ModeHandler;\n  _editHandlePicks: ?HandlePicks;\n  _startDragSnapHandlePosition: Position;\n  _isSnapped: boolean;\n\n  constructor(handler: ModeHandler) {\n    super();\n    this._handler = handler;\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this._handler.setFeatureCollection(featureCollection);\n  }\n\n  setModeConfig(modeConfig: any): void {\n    this._modeConfig = modeConfig;\n    this._handler.setModeConfig(modeConfig);\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    this._handler.setSelectedFeatureIndexes(indexes);\n  }\n\n  setDeckGlContext(context: Object) {\n    super.setDeckGlContext(context);\n    this._handler.setDeckGlContext(context);\n  }\n\n  _getSnappedMouseEvent(event: Object, snapPoint: Position): PointerMoveEvent {\n    return Object.assign({}, event, {\n      groundCoords: snapPoint,\n      screenCoords: this._context.viewport.project(snapPoint),\n      pointerDownGroundCoords: this._startDragSnapHandlePosition\n    });\n  }\n\n  _getEditHandleLayerId() {\n    // TODO: This is hacky, find a better way!\n    const { layers } = this._context.layerManager;\n    const layer = layers.find(l => l.id.endsWith('-edit-handles'));\n    return layer ? layer.id : '';\n  }\n\n  _getEditHandlePicks(event: PointerMoveEvent): HandlePicks {\n    const { screenCoords } = event;\n    const { snapPixels = DEFAULT_SNAP_PIXELS } = this._modeConfig || {};\n    const picks = this._context.layerManager.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this._getEditHandleLayerId()],\n      radius: snapPixels,\n      depth: 2\n    });\n    const potentialSnapHandle = picks.find(\n      pick => pick.object && pick.object.type === 'intermediate'\n    );\n    const handles = { potentialSnapHandle: potentialSnapHandle && potentialSnapHandle.object };\n\n    const pickedHandle = getPickedEditHandle(event.pointerDownPicks);\n    if (pickedHandle) {\n      return { ...handles, pickedHandle };\n    }\n\n    return handles;\n  }\n\n  _updatePickedHandlePosition(editAction: EditAction) {\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle && editAction) {\n      const { featureIndexes, updatedData } = editAction;\n\n      for (let i = 0; i < featureIndexes.length; i++) {\n        const selectedIndex = featureIndexes[i];\n        const updatedFeature = updatedData.features[selectedIndex];\n\n        const { positionIndexes, featureIndex } = pickedHandle;\n        if (selectedIndex >= 0 && featureIndex === selectedIndex) {\n          const { coordinates } = updatedFeature.geometry;\n          // $FlowFixMe\n          pickedHandle.position = positionIndexes.reduce(\n            (a: any[], b: number) => a[b],\n            coordinates\n          );\n        }\n      }\n    }\n  }\n\n  // If layerIdsToSnapTo is present in modeConfig and is populated, this\n  // method will return the features from the specified layers along with the features\n  // that live in the current layer. Otherwise, this method will simply return the\n  // features from the current layer\n  _getFeaturesFromRelevantLayers(): Object[] {\n    const features = [...this._handler.featureCollection.getObject().features];\n    const { layerIdsToSnapTo } = this._modeConfig || {};\n\n    if (layerIdsToSnapTo && layerIdsToSnapTo.length) {\n      const otherLayersToSnapTo = this._context.layerManager.layers.filter(layer => {\n        const shouldPickFromLayer = layerIdsToSnapTo && layerIdsToSnapTo.includes(layer.id);\n\n        // Filter out the current layer since the current layer's features are\n        // already populated in the features array.\n        return shouldPickFromLayer && layer.id !== this._layerId;\n      });\n\n      const featuresFromAdditionalLayers = otherLayersToSnapTo\n        .map(otherLayer => otherLayer.props.data)\n        .reduce((a, b) => [...a, ...b], []);\n\n      features.push(...featuresFromAdditionalLayers);\n    }\n    return features;\n  }\n\n  _getNonPickedIntermediateHandles(): EditHandle[] {\n    const handles = [];\n    const features = this._getFeaturesFromRelevantLayers();\n\n    for (let i = 0; i < features.length; i++) {\n      // Filter out the currently selected feature(s)\n      const isCurrentIndexFeatureNotSelected =\n        i < features.length && !this._handler.getSelectedFeatureIndexes().includes(i);\n\n      if (isCurrentIndexFeatureNotSelected) {\n        const { geometry } = features[i];\n        handles.push(...getEditHandlesForGeometry(geometry, i, 'intermediate'));\n      }\n    }\n    return handles;\n  }\n\n  // If no snap handle has been picked, only display the edit handles of the\n  // selected feature. If a snap handle has been picked, display said snap handle\n  // along with all snappable points on all non-selected features.\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): any[] {\n    const { enableSnapping } = this._modeConfig || {};\n    const handles = this._handler.getEditHandles(picks, groundCoords);\n\n    if (!enableSnapping) return handles;\n    const { pickedHandle } = this._editHandlePicks || {};\n\n    if (pickedHandle) {\n      handles.push(...this._getNonPickedIntermediateHandles(), pickedHandle);\n      return handles;\n    }\n\n    const { features } = this._handler.featureCollection.getObject();\n    for (const index of this._handler.getSelectedFeatureIndexes()) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index, 'snap'));\n      }\n    }\n\n    return handles.filter(Boolean);\n  }\n\n  _performSnapIfRequired() {\n    if (this._isSnapped) return;\n    const { pickedHandle, potentialSnapHandle } = this._editHandlePicks || {};\n    if (pickedHandle && potentialSnapHandle) {\n      this._isSnapped = true;\n    }\n  }\n\n  // Unsnapping only occurs after the user snaps two polygons but continues to drag the\n  // cursor past the point of resistance.\n  _performUnsnapIfRequired() {\n    if (!this._isSnapped) return;\n\n    const { potentialSnapHandle } = this._editHandlePicks || {};\n    if (!potentialSnapHandle) {\n      this._isSnapped = false;\n    }\n  }\n\n  _getSnapAwareEvent(event: Object): Object {\n    const { potentialSnapHandle } = this._editHandlePicks || {};\n\n    return potentialSnapHandle && potentialSnapHandle.position\n      ? this._getSnappedMouseEvent(event, potentialSnapHandle.position)\n      : event;\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    this._startDragSnapHandlePosition = (getPickedEditHandle(event.picks) || {}).position;\n    return this._handler.handleStartDragging(event);\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    const modeActionSummary = this._handler.handleStopDragging(this._getSnapAwareEvent(event));\n\n    this._editHandlePicks = null;\n    this._isSnapped = false;\n    return modeActionSummary;\n  }\n\n  getCursor(event: { isDragging: boolean }): string {\n    return this._handler.getCursor(event);\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const { enableSnapping } = this._handler.getModeConfig() || {};\n\n    if (enableSnapping) {\n      this._editHandlePicks = this._getEditHandlePicks(event);\n      if (this._editHandlePicks) {\n        this._performSnapIfRequired();\n        this._performUnsnapIfRequired();\n      }\n    }\n\n    const modeActionSummary = this._handler.handlePointerMove(this._getSnapAwareEvent(event));\n    const { editAction } = modeActionSummary;\n    if (editAction) {\n      this._updatePickedHandlePosition(editAction);\n    }\n\n    return modeActionSummary;\n  }\n}\n","// @flow\n\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfTransformTranslate from '@turf/transform-translate';\nimport { point } from '@turf/helpers';\nimport type { FeatureCollection, Position } from '../geojson-types.js';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class TranslateHandler extends ModeHandler {\n  _geometryBeforeTranslate: ?FeatureCollection;\n  _isTranslatable: boolean;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isTranslatable =\n      Boolean(this._geometryBeforeTranslate) || this.isSelectionPicked(event.picks);\n\n    if (!this._isTranslatable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'translating'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeforeTranslate) {\n      // Translate the geometry\n      editAction = this.getTranslateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'translated'\n      );\n      this._geometryBeforeTranslate = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isTranslatable) {\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getTranslateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string\n  ): ?EditAction {\n    if (!this._geometryBeforeTranslate) {\n      return null;\n    }\n    const p1 = point(startDragPoint);\n    const p2 = point(currentPoint);\n\n    const distanceMoved = turfDistance(p1, p2);\n    const direction = turfBearing(p1, p2);\n\n    const movedFeatures = turfTransformTranslate(\n      this._geometryBeforeTranslate,\n      distanceMoved,\n      direction\n    );\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = movedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n","// @flow\n\nimport type { StartDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TranslateHandler } from './translate-handler';\n\nexport class DuplicateHandler extends TranslateHandler {\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isTranslatable) {\n      return null;\n    }\n\n    this._geometryBeforeTranslate = this.getSelectedFeaturesAsFeatureCollection();\n\n    return this._geometryBeforeTranslate\n      ? this.getAddManyFeaturesAction(this._geometryBeforeTranslate)\n      : null;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isTranslatable) {\n      return 'copy';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport turfTransformRotate from '@turf/transform-rotate';\nimport type { FeatureCollection, Position } from '../geojson-types.js';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class RotateHandler extends ModeHandler {\n  _isRotatable: boolean;\n  _geometryBeingRotated: ?FeatureCollection;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isRotatable = Boolean(this._geometryBeingRotated) || this.isSelectionPicked(event.picks);\n\n    if (!this._isRotatable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'rotating'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isRotatable) {\n      return null;\n    }\n\n    this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeingRotated) {\n      // Rotate the geometry\n      editAction = this.getRotateAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'rotated'\n      );\n      this._geometryBeingRotated = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isRotatable) {\n      // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getRotateAction(startDragPoint: Position, currentPoint: Position, editType: string): EditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingRotated);\n    const angle = getRotationAngle(centroid, startPosition, currentPoint);\n\n    const rotatedFeatures = turfTransformRotate(this._geometryBeingRotated, angle);\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = rotatedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n\nfunction getRotationAngle(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const bearing1 = turfBearing(centroid, startDragPoint);\n  const bearing2 = turfBearing(centroid, currentPoint);\n  return bearing2 - bearing1;\n}\n","// @flow\n\nimport turfCentroid from '@turf/centroid';\nimport turfDistance from '@turf/distance';\nimport turfTransformScale from '@turf/transform-scale';\nimport type { FeatureCollection, Position } from '../geojson-types.js';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class ScaleHandler extends ModeHandler {\n  _isScalable: boolean;\n  _geometryBeingScaled: ?FeatureCollection;\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    let editAction: ?EditAction = null;\n\n    this._isScalable = Boolean(this._geometryBeingScaled) || this.isSelectionPicked(event.picks);\n\n    if (!this._isScalable || !event.pointerDownGroundCoords) {\n      // Nothing to do\n      return { editAction: null, cancelMapPan: false };\n    }\n\n    if (event.isDragging && this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(\n        event.pointerDownGroundCoords,\n        event.groundCoords,\n        'scaling'\n      );\n    }\n\n    return { editAction, cancelMapPan: true };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    if (!this._isScalable) {\n      return null;\n    }\n\n    this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection();\n    return null;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    if (this._geometryBeingScaled) {\n      // Scale the geometry\n      editAction = this.getScaleAction(event.pointerDownGroundCoords, event.groundCoords, 'scaled');\n      this._geometryBeingScaled = null;\n    }\n\n    return editAction;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    if (this._isScalable) {\n      // TODO: look at doing SVG cursors to get a better \"scale\" cursor\n      return 'move';\n    }\n    return isDragging ? 'grabbing' : 'grab';\n  }\n\n  getScaleAction(startDragPoint: Position, currentPoint: Position, editType: string): EditAction {\n    const startPosition = startDragPoint;\n    const centroid = turfCentroid(this._geometryBeingScaled);\n    const factor = getScaleFactor(centroid, startPosition, currentPoint);\n    const scaledFeatures = turfTransformScale(this._geometryBeingScaled, factor, {\n      origin: centroid\n    });\n\n    let updatedData = this.getImmutableFeatureCollection();\n\n    const selectedIndexes = this.getSelectedFeatureIndexes();\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = scaledFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      featureIndexes: selectedIndexes,\n      editContext: null\n    };\n  }\n}\n\nfunction getScaleFactor(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const startDistance = turfDistance(centroid, startDragPoint);\n  const endDistance = turfDistance(centroid, currentPoint);\n  return endDistance / startDistance;\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class DrawPointHandler extends ModeHandler {\n  handleClick({ groundCoords }: ClickEvent): ?EditAction {\n    const geometry = {\n      type: 'Point',\n      coordinates: groundCoords\n    };\n\n    return this.getAddFeatureAction(geometry);\n  }\n}\n","// @flow\n\nimport type { Position, LineString } from '../geojson-types.js';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class DrawLineStringHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    let editAction: ?EditAction = null;\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const selectedGeometry = this.getSelectedGeometry();\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      console.warn(`drawLineString mode only supported for single LineString selection`); // eslint-disable-line\n      this.resetClickSequence();\n      return null;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Extend the LineString\n      const lineString: LineString = selectedGeometry;\n\n      let positionIndexes = [lineString.coordinates.length];\n\n      const modeConfig = this.getModeConfig();\n      if (modeConfig && modeConfig.drawAtFront) {\n        positionIndexes = [0];\n      }\n      const featureIndex = selectedFeatureIndexes[0];\n      const updatedData = this.getImmutableFeatureCollection()\n        .addPosition(featureIndex, positionIndexes, event.groundCoords)\n        .getObject();\n\n      editAction = {\n        updatedData,\n        editType: 'addPosition',\n        featureIndexes: [featureIndex],\n        editContext: {\n          positionIndexes,\n          position: event.groundCoords\n        }\n      };\n\n      this.resetClickSequence();\n    } else if (clickSequence.length === 2 && tentativeFeature) {\n      // Add a new LineString\n      const geometry: any = tentativeFeature.geometry;\n      editAction = this.getAddFeatureAction(geometry);\n\n      this.resetClickSequence();\n    }\n\n    return editAction;\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n\n    const clickSequence = this.getClickSequence();\n    const groundCoords = event.groundCoords;\n\n    let startPosition: ?Position = null;\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const selectedGeometry = this.getSelectedGeometry();\n\n    if (\n      selectedFeatureIndexes.length > 1 ||\n      (selectedGeometry && selectedGeometry.type !== 'LineString')\n    ) {\n      // unsupported\n      return result;\n    }\n\n    if (selectedGeometry && selectedGeometry.type === 'LineString') {\n      // Draw an extension line starting from one end of the selected LineString\n      startPosition = selectedGeometry.coordinates[selectedGeometry.coordinates.length - 1];\n\n      const modeConfig = this.getModeConfig();\n      if (modeConfig && modeConfig.drawAtFront) {\n        startPosition = selectedGeometry.coordinates[0];\n      }\n    } else if (clickSequence.length === 1) {\n      startPosition = clickSequence[0];\n    }\n\n    if (startPosition) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        properties: {},\n        geometry: {\n          type: 'LineString',\n          coordinates: [startPosition, groundCoords]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport type { Polygon, Position } from '../geojson-types.js';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class DrawPolygonHandler extends ModeHandler {\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandles(picks, groundCoords);\n\n    if (this._tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(this._tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (this._tentativeFeature && this._tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (this._tentativeFeature && this._tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?EditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (clickedEditHandle) {\n      // User clicked an edit handle.\n      // Remove it from the click sequence, so it isn't added as a new point.\n      const clickSequence = this.getClickSequence();\n      clickSequence.splice(clickSequence.length - 1, 1);\n    }\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n\n        // Remove the hovered position\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: [[...polygon.coordinates[0].slice(0, -2), polygon.coordinates[0][0]]]\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      groundCoords: event.groundCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownGroundCoords: null,\n      sourceEvent: null\n    };\n    this.handlePointerMove(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, groundCoords]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, groundCoords, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport lineIntersect from '@turf/line-intersect';\nimport turfDistance from '@turf/distance';\nimport { point, lineString } from '@turf/helpers';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { Polygon, Position } from '../geojson-types.js';\nimport type { EditAction, EditHandle } from './mode-handler.js';\nimport { ModeHandler, getPickedEditHandle, getEditHandlesForGeometry } from './mode-handler.js';\n\nexport class Draw90DegreePolygonHandler extends ModeHandler {\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    let handles = super.getEditHandles(picks, groundCoords);\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature) {\n      handles = handles.concat(getEditHandlesForGeometry(tentativeFeature.geometry, -1));\n      // Slice off the handles that are are next to the pointer\n      if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      } else if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n        // Remove the last existing handle\n        handles = handles.slice(0, -1);\n      }\n    }\n\n    return handles;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const tentativeFeature = this.getTentativeFeature();\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[0][clickSequence.length - 1];\n    } else if (tentativeFeature && tentativeFeature.geometry.type === 'LineString') {\n      clickSequence[clickSequence.length - 1] =\n        tentativeFeature.geometry.coordinates[clickSequence.length - 1];\n    }\n\n    let p3;\n    if (clickSequence.length === 1) {\n      p3 = groundCoords;\n    } else {\n      const p1 = clickSequence[clickSequence.length - 2];\n      const p2 = clickSequence[clickSequence.length - 1];\n      [p3] = generatePointsParallelToLinePoints(p1, p2, groundCoords);\n    }\n\n    if (clickSequence.length < 3) {\n      // Draw a LineString connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [...clickSequence, p3]\n        }\n      });\n    } else {\n      // Draw a Polygon connecting all the clicked points with the hovered point\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [[...clickSequence, p3, clickSequence[0]]]\n        }\n      });\n    }\n\n    return result;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const { picks } = event;\n    const tentativeFeature = this.getTentativeFeature();\n\n    let editAction: ?EditAction = null;\n    const clickedEditHandle = getPickedEditHandle(picks);\n\n    if (tentativeFeature && tentativeFeature.geometry.type === 'Polygon') {\n      const polygon: Polygon = tentativeFeature.geometry;\n\n      if (\n        clickedEditHandle &&\n        clickedEditHandle.featureIndex === -1 &&\n        (clickedEditHandle.positionIndexes[1] === 0 ||\n          clickedEditHandle.positionIndexes[1] === polygon.coordinates[0].length - 3)\n      ) {\n        // They clicked the first or last point (or double-clicked), so complete the polygon\n        const polygonToAdd: Polygon = {\n          type: 'Polygon',\n          coordinates: this.finalizedCoordinates([...polygon.coordinates[0]])\n        };\n\n        this.resetClickSequence();\n        this._setTentativeFeature(null);\n        editAction = this.getAddFeatureOrBooleanPolygonAction(polygonToAdd);\n      }\n    }\n\n    // Trigger pointer move right away in order for it to update edit handles (to support double-click)\n    const fakePointerMoveEvent = {\n      screenCoords: [-1, -1],\n      groundCoords: event.groundCoords,\n      picks: [],\n      isDragging: false,\n      pointerDownPicks: null,\n      pointerDownScreenCoords: null,\n      pointerDownGroundCoords: null,\n      sourceEvent: null\n    };\n    this.handlePointerMove(fakePointerMoveEvent);\n\n    return editAction;\n  }\n\n  finalizedCoordinates(coords: Position[]) {\n    // Remove the hovered position\n    let coordinates = [[...coords.slice(0, -2), coords[0]]];\n    let pt = this.getIntermediatePoint([...coords]);\n    if (!pt) {\n      // if intermediate point with 90 degree not available\n      // try remove the last clicked point and get the intermediate point.\n      const tc = [...coords];\n      tc.splice(-3, 1);\n      pt = this.getIntermediatePoint([...tc]);\n      if (pt) {\n        coordinates = [[...coords.slice(0, -3), pt, coords[0]]];\n      }\n    } else {\n      coordinates = [[...coords.slice(0, -2), pt, coords[0]]];\n    }\n    return coordinates;\n  }\n\n  getIntermediatePoint(coordinates: Position[]) {\n    let pt;\n    if (coordinates.length > 4) {\n      const [p1, p2] = [...coordinates];\n      const angle1 = bearing(p1, p2);\n      const p3 = coordinates[coordinates.length - 3];\n      const p4 = coordinates[coordinates.length - 4];\n      const angle2 = bearing(p3, p4);\n\n      const angles = { first: [], second: [] };\n      // calculate 3 right angle points for first and last points in lineString\n      [1, 2, 3].forEach(factor => {\n        const newAngle1 = angle1 + factor * 90;\n        // convert angles to 0 to -180 for anti-clock and 0 to 180 for clock wise\n        angles.first.push(newAngle1 > 180 ? newAngle1 - 360 : newAngle1);\n        const newAngle2 = angle2 + factor * 90;\n        angles.second.push(newAngle2 > 180 ? newAngle2 - 360 : newAngle2);\n      });\n\n      const distance = turfDistance(point(p1), point(p3));\n      // Draw imaginary right angle lines for both first and last points in lineString\n      // If there is intersection point for any 2 lines, will be the 90 degree point.\n      [0, 1, 2].forEach(indexFirst => {\n        const line1 = lineString([\n          p1,\n          destination(p1, distance, angles.first[indexFirst]).geometry.coordinates\n        ]);\n        [0, 1, 2].forEach(indexSecond => {\n          const line2 = lineString([\n            p3,\n            destination(p3, distance, angles.second[indexSecond]).geometry.coordinates\n          ]);\n          const fc = lineIntersect(line1, line2);\n          if (fc && fc.features.length) {\n            // found the intersect point\n            pt = fc.features[0].geometry.coordinates;\n          }\n        });\n      });\n    }\n    return pt;\n  }\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport { ModeHandler } from './mode-handler.js';\nimport type { EditAction } from './mode-handler.js';\n\nexport class TwoClickPolygonHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 1 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\n\nexport class DrawRectangleHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.groundCoords;\n    this._setTentativeFeature(bboxPolygon([corner1[0], corner1[1], corner2[0], corner2[1]]));\n\n    return result;\n  }\n}\n","// @flow\n\nimport booleanPointInPolygon from '@turf/boolean-point-in-polygon';\nimport turfDifference from '@turf/difference';\nimport turfBuffer from '@turf/buffer';\nimport lineIntersect from '@turf/line-intersect';\nimport { lineString } from '@turf/helpers';\nimport turfBearing from '@turf/bearing';\nimport turfDistance from '@turf/distance';\nimport turfDestination from '@turf/destination';\nimport turfPolygonToLine from '@turf/polygon-to-line';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { ClickEvent, PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ModeHandler } from './mode-handler.js';\n\nexport class SplitPolygonHandler extends ModeHandler {\n  calculateGroundCoords(clickSequence: any, groundCoords: any) {\n    const modeConfig = this.getModeConfig();\n    if (!modeConfig || !modeConfig.lock90Degree || !clickSequence.length) {\n      return groundCoords;\n    }\n    if (clickSequence.length === 1) {\n      // if first point is clicked, then find closest polygon point and build ~90deg vector\n      const firstPoint = clickSequence[0];\n      const selectedGeometry = this.getSelectedGeometry();\n      const feature = turfPolygonToLine(selectedGeometry);\n\n      const lines = feature.type === 'FeatureCollection' ? feature.features : [feature];\n      let minDistance = Number.MAX_SAFE_INTEGER;\n      let closestPoint = null;\n      // If Multipolygon, then we should find nearest polygon line and stick split to it.\n      lines.forEach(line => {\n        const snapPoint = nearestPointOnLine(line, firstPoint);\n        const distanceFromOrigin = turfDistance(snapPoint, firstPoint);\n        if (minDistance > distanceFromOrigin) {\n          minDistance = distanceFromOrigin;\n          closestPoint = snapPoint;\n        }\n      });\n\n      if (closestPoint) {\n        // closest point is used as 90degree entry to the polygon\n        const lastBearing = turfBearing(firstPoint, closestPoint);\n        const currentDistance = turfDistance(firstPoint, groundCoords, { units: 'meters' });\n        return turfDestination(firstPoint, currentDistance, lastBearing, {\n          units: 'meters'\n        }).geometry.coordinates;\n      }\n      return groundCoords;\n    }\n    // Allow only 90 degree turns\n    const lastPoint = clickSequence[clickSequence.length - 1];\n    const [approximatePoint] = generatePointsParallelToLinePoints(\n      clickSequence[clickSequence.length - 2],\n      lastPoint,\n      groundCoords\n    );\n    // align point with current ground\n    const nearestPt = nearestPointOnLine(lineString([lastPoint, approximatePoint]), groundCoords)\n      .geometry.coordinates;\n    return nearestPt;\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick({\n      ...event,\n      groundCoords: this.calculateGroundCoords(this.getClickSequence(), event.groundCoords)\n    });\n    const editAction: ?EditAction = null;\n    const tentativeFeature = this.getTentativeFeature();\n    const selectedGeometry = this.getSelectedGeometry();\n    const clickSequence = this.getClickSequence();\n\n    if (!selectedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('A polygon must be selected for splitting');\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n    const pt = {\n      type: 'Point',\n      coordinates: clickSequence[clickSequence.length - 1]\n    };\n    const isPointInPolygon = booleanPointInPolygon(pt, selectedGeometry);\n    if (clickSequence.length > 1 && tentativeFeature && !isPointInPolygon) {\n      this.resetClickSequence();\n      const isLineInterectingWithPolygon = lineIntersect(tentativeFeature, selectedGeometry);\n      if (isLineInterectingWithPolygon.features.length === 0) {\n        this._setTentativeFeature(null);\n        return editAction;\n      }\n      return this.splitPolygon();\n    }\n\n    return editAction;\n  }\n\n  handlePointerMove({\n    groundCoords\n  }: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const clickSequence = this.getClickSequence();\n    const result = { editAction: null, cancelMapPan: false };\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    this._setTentativeFeature({\n      type: 'Feature',\n      geometry: {\n        type: 'LineString',\n        coordinates: [...clickSequence, this.calculateGroundCoords(clickSequence, groundCoords)]\n      }\n    });\n\n    return result;\n  }\n\n  splitPolygon() {\n    const selectedGeometry = this.getSelectedGeometry();\n    const tentativeFeature = this.getTentativeFeature();\n    const featureIndex = this.getSelectedFeatureIndexes()[0];\n    const modeConfig = this.getModeConfig() || {};\n\n    // Default gap in between the polygon\n    let { gap = 0.1, units = 'centimeters' } = modeConfig;\n    if (gap === 0) {\n      gap = 0.1;\n      units = 'centimeters';\n    }\n\n    const buffer = turfBuffer(tentativeFeature, gap, { units });\n    const updatedGeometry = turfDifference(selectedGeometry, buffer);\n    this._setTentativeFeature(null);\n    if (!updatedGeometry) {\n      // eslint-disable-next-line no-console,no-undef\n      console.warn('Canceling edit. Split Polygon erased');\n      return null;\n    }\n\n    const { type, coordinates } = updatedGeometry.geometry;\n    let updatedCoordinates = [];\n    if (type === 'Polygon') {\n      // Update the coordinates as per Multipolygon\n      updatedCoordinates = coordinates.map(c => [c]);\n    } else {\n      // Handle Case when Multipolygon has holes\n      updatedCoordinates = coordinates.reduce((agg, prev) => {\n        prev.forEach(p => {\n          agg.push([p]);\n        });\n        return agg;\n      }, []);\n    }\n\n    // Update the type to Mulitpolygon\n    const updatedData = this.getImmutableFeatureCollection().replaceGeometry(featureIndex, {\n      type: 'MultiPolygon',\n      coordinates: updatedCoordinates\n    });\n\n    const editAction: EditAction = {\n      updatedData: updatedData.getObject(),\n      editType: 'split',\n      featureIndexes: [featureIndex],\n      editContext: null\n    };\n\n    return editAction;\n  }\n}\n","// @flow\n\nimport type { ClickEvent } from '../event-types.js';\nimport { ModeHandler } from './mode-handler.js';\nimport type { EditAction } from './mode-handler.js';\n\nexport class ThreeClickPolygonHandler extends ModeHandler {\n  handleClick(event: ClickEvent): ?EditAction {\n    super.handleClick(event);\n\n    const tentativeFeature = this.getTentativeFeature();\n    const clickSequence = this.getClickSequence();\n\n    if (\n      clickSequence.length > 2 &&\n      tentativeFeature &&\n      tentativeFeature.geometry.type === 'Polygon'\n    ) {\n      const editAction = this.getAddFeatureOrBooleanPolygonAction(tentativeFeature.geometry);\n      this.resetClickSequence();\n      this._setTentativeFeature(null);\n      return editAction;\n    }\n\n    return null;\n  }\n}\n","// @flow\n\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { LineString } from '../geojson-types.js';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ThreeClickPolygonHandler } from './three-click-polygon-handler.js';\n\nexport class DrawRectangleUsingThreePointsHandler extends ThreeClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const groundCoords = event.groundCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], groundCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const lineString: LineString = {\n        type: 'LineString',\n        coordinates: clickSequence\n      };\n      const [p1, p2] = clickSequence;\n      const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, groundCoords);\n\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'Polygon',\n          coordinates: [\n            [\n              // Draw a polygon containing all the points of the LineString,\n              // then the points orthogonal to the lineString,\n              // then back to the starting position\n              ...lineString.coordinates,\n              p3,\n              p4,\n              p1\n            ]\n          ]\n        }\n      });\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\n\nexport class DrawCircleFromCenterHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = this.getModeConfig() || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const centerCoordinates = clickSequence[0];\n    const radius = Math.max(distance(centerCoordinates, event.groundCoords), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawCircleByBoundingBoxHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const modeConfig = this.getModeConfig() || {};\n    // Default turf value for circle is 64\n    const { steps = 64 } = modeConfig;\n    const options = { steps };\n\n    if (steps < 4) {\n      console.warn(`Minimum steps to draw a circle is 4 `); // eslint-disable-line no-console,no-undef\n      options.steps = 4;\n    }\n\n    const firstClickedPoint = clickSequence[0];\n    const centerCoordinates = getIntermediatePosition(firstClickedPoint, event.groundCoords);\n    const radius = Math.max(distance(firstClickedPoint, centerCoordinates), 0.001);\n    this._setTentativeFeature(circle(centerCoordinates, radius, options));\n\n    return result;\n  }\n}\n","// @flow\n\nimport bboxPolygon from '@turf/bbox-polygon';\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { TwoClickPolygonHandler } from './two-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawEllipseByBoundingBoxHandler extends TwoClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const corner1 = clickSequence[0];\n    const corner2 = event.groundCoords;\n\n    const minX = Math.min(corner1[0], corner2[0]);\n    const minY = Math.min(corner1[1], corner2[1]);\n    const maxX = Math.max(corner1[0], corner2[0]);\n    const maxY = Math.max(corner1[1], corner2[1]);\n\n    const polygonPoints = bboxPolygon([minX, minY, maxX, maxY]).geometry.coordinates[0];\n    const centerCoordinates = getIntermediatePosition(corner1, corner2);\n\n    const xSemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[1])), 0.001);\n    const ySemiAxis = Math.max(distance(point(polygonPoints[0]), point(polygonPoints[3])), 0.001);\n\n    this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis));\n\n    return result;\n  }\n}\n","// @flow\n\nimport distance from '@turf/distance';\nimport ellipse from '@turf/ellipse';\nimport bearing from '@turf/bearing';\nimport { point } from '@turf/helpers';\nimport type { PointerMoveEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { ThreeClickPolygonHandler } from './three-click-polygon-handler.js';\nimport { getIntermediatePosition } from './mode-handler.js';\n\nexport class DrawEllipseUsingThreePointsHandler extends ThreeClickPolygonHandler {\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    const result = { editAction: null, cancelMapPan: false };\n    const clickSequence = this.getClickSequence();\n\n    if (clickSequence.length === 0) {\n      // nothing to do yet\n      return result;\n    }\n\n    const groundCoords = event.groundCoords;\n\n    if (clickSequence.length === 1) {\n      this._setTentativeFeature({\n        type: 'Feature',\n        geometry: {\n          type: 'LineString',\n          coordinates: [clickSequence[0], groundCoords]\n        }\n      });\n    } else if (clickSequence.length === 2) {\n      const [p1, p2] = clickSequence;\n\n      const centerCoordinates = getIntermediatePosition(p1, p2);\n      const xSemiAxis = Math.max(distance(centerCoordinates, point(groundCoords)), 0.001);\n      const ySemiAxis = Math.max(distance(p1, p2), 0.001) / 2;\n      const options = { angle: bearing(p1, p2) };\n\n      this._setTentativeFeature(ellipse(centerCoordinates, xSemiAxis, ySemiAxis, options));\n    }\n\n    return result;\n  }\n}\n","// @flow\n\nimport bearing from '@turf/bearing';\nimport { generatePointsParallelToLinePoints } from '../utils';\nimport type { PointerMoveEvent, StartDraggingEvent, StopDraggingEvent } from '../event-types.js';\nimport type { EditAction } from './mode-handler.js';\nimport { getPickedEditHandle } from './mode-handler.js';\nimport { ModifyHandler } from './modify-handler';\n\nexport class ExtrudeHandler extends ModifyHandler {\n  isPointAdded: boolean = false;\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    this._lastPointerMovePicks = event.picks;\n\n    let editAction: ?EditAction = null;\n\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (event.isDragging && editHandle) {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, editHandle.featureIndex);\n      if (p1 && p2) {\n        // p3 and p4 are end points for moving (extruding) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.groundCoords);\n\n        const updatedData = this.getImmutableFeatureCollection()\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruding',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: this.nextPositionIndexes(editHandle.positionIndexes, size),\n            position: p3\n          }\n        };\n      }\n    }\n\n    // Cancel map panning if pointer went down on an edit handle\n    const cancelMapPan = Boolean(editHandle);\n\n    return { editAction, cancelMapPan };\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle && editHandle.type === 'intermediate') {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(editHandle.positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(\n        editHandle.positionIndexes,\n        editHandle.featureIndex\n      );\n\n      if (p1 && p2) {\n        let updatedData = this.getImmutableFeatureCollection();\n        if (!this.isOrthogonal(editHandle.positionIndexes, editHandle.featureIndex, size)) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p2\n          );\n        }\n        if (\n          !this.isOrthogonal(\n            this.prevPositionIndexes(editHandle.positionIndexes, size),\n            editHandle.featureIndex,\n            size\n          )\n        ) {\n          updatedData = updatedData.addPosition(\n            editHandle.featureIndex,\n            editHandle.positionIndexes,\n            p1\n          );\n          this.isPointAdded = true;\n        }\n\n        editAction = {\n          updatedData: updatedData.getObject(),\n          editType: 'startExtruding',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: editHandle.positionIndexes,\n            position: p1\n          }\n        };\n      }\n    }\n\n    return editAction;\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    let editAction: ?EditAction = null;\n\n    const selectedFeatureIndexes = this.getSelectedFeatureIndexes();\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const size = this.coordinatesSize(editHandle.positionIndexes, editHandle.featureIndex);\n      const positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(editHandle.positionIndexes, size)\n        : editHandle.positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        editHandle.featureIndex\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, editHandle.featureIndex);\n\n      if (p1 && p2) {\n        // p3 and p4 are end points for new moved (extruded) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.groundCoords);\n\n        const updatedData = this.getImmutableFeatureCollection()\n          .replacePosition(\n            editHandle.featureIndex,\n            this.prevPositionIndexes(positionIndexes, size),\n            p4\n          )\n          .replacePosition(editHandle.featureIndex, positionIndexes, p3)\n          .getObject();\n\n        editAction = {\n          updatedData,\n          editType: 'extruded',\n          featureIndexes: [editHandle.featureIndex],\n          editContext: {\n            positionIndexes: editHandle.positionIndexes,\n            position: p3\n          }\n        };\n      }\n    }\n    this.isPointAdded = false;\n\n    return editAction;\n  }\n\n  coordinatesSize(positionIndexes: number[], featureIndex: number) {\n    let size = 0;\n    const feature = this.getImmutableFeatureCollection().getObject().features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        size = coordinates[a][b].length;\n      }\n    } else {\n      const [b] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        size = coordinates[b].length;\n      }\n    }\n    return size;\n  }\n\n  getBearing(p1: any, p2: any) {\n    const angle = bearing(p1, p2);\n    if (angle < 0) {\n      return Math.floor(360 + angle);\n    }\n    return Math.floor(angle);\n  }\n\n  isOrthogonal(positionIndexes: number[], featureIndex: number, size: number) {\n    if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n      positionIndexes[positionIndexes.length - 1] = 0;\n    }\n    const prevPoint = this.getPointForPositionIndexes(\n      this.prevPositionIndexes(positionIndexes, size),\n      featureIndex\n    );\n    const nextPoint = this.getPointForPositionIndexes(\n      this.nextPositionIndexes(positionIndexes, size),\n      featureIndex\n    );\n    const currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex);\n    const prevAngle = this.getBearing(currentPoint, prevPoint);\n    const nextAngle = this.getBearing(currentPoint, nextPoint);\n    return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n  }\n\n  nextPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const next = [...positionIndexes];\n    if (next.length) {\n      next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n    }\n    return next;\n  }\n\n  prevPositionIndexes(positionIndexes: number[], size: number): number[] {\n    const prev = [...positionIndexes];\n    if (prev.length) {\n      prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n    }\n    return prev;\n  }\n\n  getPointForPositionIndexes(positionIndexes: number[], featureIndex: number) {\n    let p1;\n    const feature = this.getImmutableFeatureCollection().getObject().features[featureIndex];\n    const coordinates: any = feature.geometry.coordinates;\n    // for Multi polygons, length will be 3\n    if (positionIndexes.length === 3) {\n      const [a, b, c] = positionIndexes;\n      if (coordinates.length && coordinates[a].length) {\n        p1 = coordinates[a][b][c];\n      }\n    } else {\n      const [b, c] = positionIndexes;\n      if (coordinates.length && coordinates[b].length) {\n        p1 = coordinates[b][c];\n      }\n    }\n    return p1;\n  }\n}\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent,\n  DoubleClickEvent\n} from '../event-types.js';\n\n// Minimum number of pixels the pointer must move from the original pointer down to be considered dragging\nconst MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS = 7;\n\nexport default class EditableLayer extends CompositeLayer {\n  // Overridable interaction event handlers\n  onLayerClick(event: ClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onDoubleClick(event: DoubleClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    // default implementation - do nothing\n  }\n\n  // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  initializeState() {\n    this.setState({\n      _editableLayerState: {\n        // Pointer event handlers\n        pointerHandlers: null,\n        // Picked objects at the time the pointer went down\n        pointerDownPicks: null,\n        // Screen coordinates where the pointer went down\n        pointerDownScreenCoords: null,\n        // Ground coordinates where the pointer went down\n        pointerDownGroundCoords: null,\n        // Is the pointer dragging (pointer down + moved at least MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS)\n        isDragging: false\n      }\n    });\n  }\n\n  finalizeState() {\n    this._removePointerHandlers();\n  }\n\n  updateState({ props, changeFlags }: Object) {\n    // unsubscribe previous layer instance's handlers\n    this._removePointerHandlers();\n    this._addPointerHandlers();\n  }\n\n  _removePointerHandlers() {\n    if (this.state._editableLayerState.pointerHandlers) {\n      this.context.gl.canvas.removeEventListener(\n        'pointermove',\n        this.state._editableLayerState.pointerHandlers.onPointerMove\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerdown',\n        this.state._editableLayerState.pointerHandlers.onPointerDown\n      );\n      this.context.gl.canvas.removeEventListener(\n        'pointerup',\n        this.state._editableLayerState.pointerHandlers.onPointerUp\n      );\n      this.context.gl.canvas.removeEventListener(\n        'dblclick',\n        this.state._editableLayerState.pointerHandlers.onDoubleClick\n      );\n    }\n    this.state._editableLayerState.pointerHandlers = null;\n  }\n\n  _addPointerHandlers() {\n    this.state._editableLayerState.pointerHandlers = {\n      onPointerMove: this._onPointerMove.bind(this),\n      onPointerDown: this._onPointerDown.bind(this),\n      onPointerUp: this._onPointerUp.bind(this),\n      onDoubleClick: this._onDoubleClick.bind(this)\n    };\n\n    this.context.gl.canvas.addEventListener(\n      'pointermove',\n      this.state._editableLayerState.pointerHandlers.onPointerMove\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerdown',\n      this.state._editableLayerState.pointerHandlers.onPointerDown\n    );\n    this.context.gl.canvas.addEventListener(\n      'pointerup',\n      this.state._editableLayerState.pointerHandlers.onPointerUp\n    );\n    this.context.gl.canvas.addEventListener(\n      'dblclick',\n      this.state._editableLayerState.pointerHandlers.onDoubleClick\n    );\n  }\n\n  _onDoubleClick(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n    this.onDoubleClick({\n      groundCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerDown(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: 10,\n      depth: 2\n    });\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: screenCoords,\n        pointerDownGroundCoords: groundCoords,\n        pointerDownPicks: picks,\n        isDragging: false\n      }\n    });\n  }\n\n  _onPointerMove(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords\n    } = this.state._editableLayerState;\n\n    let { isDragging } = this.state._editableLayerState;\n\n    if (pointerDownScreenCoords) {\n      // Pointer went down and is moving\n\n      // Did it move enough to consider it a drag\n      if (!isDragging && this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n        // OK, this is considered dragging\n\n        // Fire the start dragging event\n        this.onStartDragging({\n          picks: pointerDownPicks,\n          screenCoords,\n          groundCoords,\n          pointerDownScreenCoords,\n          pointerDownGroundCoords,\n          sourceEvent: event\n        });\n\n        isDragging = true;\n        this.setState({\n          _editableLayerState: {\n            ...this.state._editableLayerState,\n            isDragging\n          }\n        });\n      }\n    }\n\n    const picks = this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: 10,\n      depth: 2\n    });\n\n    this.onPointerMove({\n      screenCoords,\n      groundCoords,\n      picks,\n      isDragging,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords,\n      sourceEvent: event\n    });\n  }\n\n  _onPointerUp(event: Object) {\n    const screenCoords = this.getScreenCoords(event);\n    const groundCoords = this.getGroundCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownGroundCoords,\n      isDragging\n    } = this.state._editableLayerState;\n\n    if (!pointerDownScreenCoords) {\n      // This is a pointer up without a pointer down (e.g. user pointer downed elsewhere), so ignore\n      return;\n    }\n\n    if (isDragging) {\n      this.onStopDragging({\n        picks: pointerDownPicks,\n        screenCoords,\n        groundCoords,\n        pointerDownScreenCoords,\n        pointerDownGroundCoords,\n        sourceEvent: event\n      });\n    } else if (!this.movedEnoughForDrag(pointerDownScreenCoords, screenCoords)) {\n      this.onLayerClick({\n        picks: pointerDownPicks,\n        screenCoords,\n        groundCoords,\n        sourceEvent: event\n      });\n    }\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: null,\n        pointerDownGroundCoords: null,\n        pointerDownPicks: null,\n        isDragging: false\n      }\n    });\n  }\n\n  getScreenCoords(pointerEvent: Object) {\n    return [\n      pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().x,\n      pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().y\n    ];\n  }\n\n  getGroundCoords(screenCoords: number[]) {\n    return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n  }\n\n  movedEnoughForDrag(screenCoords1: number[], screenCoords2: number[]) {\n    return (\n      Math.abs(screenCoords1[0] - screenCoords2[0]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS ||\n      Math.abs(screenCoords1[1] - screenCoords2[1]) > MINIMUM_POINTER_MOVE_THRESHOLD_PIXELS\n    );\n  }\n}\n\nEditableLayer.layerName = 'EditableLayer';\n","// @flow\n/* eslint-env browser */\n\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer } from '@deck.gl/layers';\nimport { ModeHandler } from '../mode-handlers/mode-handler.js';\nimport { ViewHandler } from '../mode-handlers/view-handler.js';\nimport { ModifyHandler } from '../mode-handlers/modify-handler.js';\nimport { ElevationHandler } from '../mode-handlers/elevation-handler.js';\nimport { SnappableHandler } from '../mode-handlers/snappable-handler.js';\nimport { TranslateHandler } from '../mode-handlers/translate-handler.js';\nimport { DuplicateHandler } from '../mode-handlers/duplicate-handler';\nimport { RotateHandler } from '../mode-handlers/rotate-handler.js';\nimport { ScaleHandler } from '../mode-handlers/scale-handler.js';\nimport { DrawPointHandler } from '../mode-handlers/draw-point-handler.js';\nimport { DrawLineStringHandler } from '../mode-handlers/draw-line-string-handler.js';\nimport { DrawPolygonHandler } from '../mode-handlers/draw-polygon-handler.js';\nimport { Draw90DegreePolygonHandler } from '../mode-handlers/draw-90degree-polygon-handler.js';\nimport { DrawRectangleHandler } from '../mode-handlers/draw-rectangle-handler.js';\nimport { SplitPolygonHandler } from '../mode-handlers/split-polygon-handler.js';\nimport { DrawRectangleUsingThreePointsHandler } from '../mode-handlers/draw-rectangle-using-three-points-handler.js';\nimport { DrawCircleFromCenterHandler } from '../mode-handlers/draw-circle-from-center-handler.js';\nimport { DrawCircleByBoundingBoxHandler } from '../mode-handlers/draw-circle-by-bounding-box-handler.js';\nimport { DrawEllipseByBoundingBoxHandler } from '../mode-handlers/draw-ellipse-by-bounding-box-handler.js';\nimport { DrawEllipseUsingThreePointsHandler } from '../mode-handlers/draw-ellipse-using-three-points-handler.js';\n\nimport type { EditAction } from '../mode-handlers/mode-handler.js';\nimport type { Position } from '../geojson-types.js';\nimport type {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  PointerMoveEvent\n} from '../event-types.js';\nimport { ExtrudeHandler } from '../mode-handlers/extrude-handler.js';\nimport EditableLayer from './editable-layer.js';\n\nconst DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\n\nfunction getEditHandleColor(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.type) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nconst defaultProps = {\n  mode: 'modify',\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: 1,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'meters',\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineDashJustified: false,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: f =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: f => (f && f.properties && f.properties.lineWidth) || 1,\n  getLineDashArray: (feature, isSelected, mode) =>\n    isSelected && mode !== 'view' ? [7, 4] : [0, 0],\n\n  // Tentative feature rendering\n  getTentativeLineDashArray: (f, mode) => [7, 4],\n  getTentativeLineColor: (f, mode) => DEFAULT_SELECTED_LINE_COLOR,\n  getTentativeFillColor: (f, mode) => DEFAULT_SELECTED_FILL_COLOR,\n  getTentativeLineWidth: (f, mode) => (f && f.properties && f.properties.lineWidth) || 1,\n\n  editHandleType: 'point',\n  editHandleParameters: {},\n  editHandleLayerProps: {},\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: false,\n  editHandlePointStrokeWidth: 1,\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  getEditHandleIcon: handle => handle.type,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // Mode handlers\n  modeHandlers: {\n    view: new ViewHandler(),\n    modify: new ModifyHandler(),\n    elevation: new ElevationHandler(),\n    extrude: new ExtrudeHandler(),\n    rotate: new RotateHandler(),\n    translate: new SnappableHandler(new TranslateHandler()),\n    duplicate: new DuplicateHandler(),\n    scale: new ScaleHandler(),\n    drawPoint: new DrawPointHandler(),\n    drawLineString: new DrawLineStringHandler(),\n    drawPolygon: new DrawPolygonHandler(),\n    draw90DegreePolygon: new Draw90DegreePolygonHandler(),\n    split: new SplitPolygonHandler(),\n    drawRectangle: new DrawRectangleHandler(),\n    drawRectangleUsing3Points: new DrawRectangleUsingThreePointsHandler(),\n    drawCircleFromCenter: new DrawCircleFromCenterHandler(),\n    drawCircleByBoundingBox: new DrawCircleByBoundingBoxHandler(),\n    drawEllipseByBoundingBox: new DrawEllipseByBoundingBoxHandler(),\n    drawEllipseUsing3Points: new DrawEllipseUsingThreePointsHandler()\n  }\n};\n\ntype Props = {\n  mode: string,\n  modeHandlers: { [mode: string]: ModeHandler },\n  onEdit: EditAction => void,\n  // TODO: type the rest\n  [string]: any\n};\n\n// type State = {\n//   modeHandler: EditableFeatureCollection,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nexport default class EditableGeoJsonLayer extends EditableLayer {\n  // state: State;\n  // props: Props;\n  // setState: ($Shape<State>) => void;\n\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      lineDashJustified: this.props.lineDashJustified,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n      getLineDashArray: this.selectionAwareAccessor(this.props.getLineDashArray),\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineDashArray: [this.props.selectedFeatureIndexes, this.props.mode]\n      }\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createTentativeLayers());\n    layers = layers.concat(this.createEditHandleLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      selectedFeatures: [],\n      editHandles: []\n    });\n  }\n\n  // TODO: figure out how to properly update state from an outside event handler\n  shouldUpdateState({ props, oldProps, context, oldContext, changeFlags }: Object) {\n    if (changeFlags.stateChanged) {\n      return true;\n    }\n    return true;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags\n  }: {\n    props: Props,\n    oldProps: Props,\n    changeFlags: any\n  }) {\n    super.updateState({ props, changeFlags });\n\n    let modeHandler: ModeHandler = this.state.modeHandler;\n    if (changeFlags.propsOrDataChanged) {\n      if (props.modeHandlers !== oldProps.modeHandlers || props.mode !== oldProps.mode) {\n        modeHandler = props.modeHandlers[props.mode];\n\n        if (!modeHandler) {\n          console.warn(`No handler configured for mode ${props.mode}`); // eslint-disable-line no-console,no-undef\n          // Use default mode handler\n          modeHandler = new ModeHandler();\n        }\n\n        if (modeHandler !== this.state.modeHandler) {\n          this.setState({ modeHandler });\n        }\n\n        modeHandler.setFeatureCollection(props.data);\n      } else if (changeFlags.dataChanged) {\n        modeHandler.setFeatureCollection(props.data);\n      }\n\n      modeHandler.setModeConfig(props.modeConfig);\n      modeHandler.setSelectedFeatureIndexes(props.selectedFeatureIndexes);\n      modeHandler.setDeckGlContext(this.context);\n      modeHandler.setLayerId(props.id);\n      this.updateTentativeFeature();\n      this.updateEditHandles();\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map(elem => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Object) => accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Object) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Object) {\n    if (sourceLayer.id.endsWith('-edit-handles')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isEditingHandle = true;\n    }\n\n    return info;\n  }\n\n  createEditHandleLayers() {\n    if (!this.state.editHandles.length) {\n      return [];\n    }\n\n    const sharedProps = {\n      id: `${this.props.editHandleType.layerName || this.props.editHandleType}-edit-handles`,\n      data: this.state.editHandles,\n      fp64: this.props.fp64,\n\n      parameters: this.props.editHandleParameters,\n      ...this.props.editHandleLayerProps\n    };\n\n    let layer;\n\n    switch (this.props.editHandleType) {\n      case 'icon':\n        layer = new IconLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n            iconAtlas: this.props.editHandleIconAtlas,\n            iconMapping: this.props.editHandleIconMapping,\n            sizeScale: this.props.editHandleIconSizeScale,\n            getIcon: this.props.getEditHandleIcon,\n            getSize: this.props.getEditHandleIconSize,\n            getColor: this.props.getEditHandleIconColor,\n            getAngle: this.props.getEditHandleIconAngle,\n\n            getPosition: d => d.position\n          })\n        );\n        break;\n\n      case 'point':\n        layer = new ScatterplotLayer(\n          this.getSubLayerProps({\n            ...sharedProps,\n\n            // Proxy editing point props\n            radiusScale: this.props.editHandlePointRadiusScale,\n            outline: this.props.editHandlePointOutline,\n            strokeWidth: this.props.editHandlePointStrokeWidth,\n            radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n            radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n            getRadius: this.props.getEditHandlePointRadius,\n            getColor: this.props.getEditHandlePointColor\n          })\n        );\n        break;\n\n      default:\n        if (typeof this.props.editHandleType === 'function') {\n          const EditHandleType = this.props.editHandleType;\n          layer = new EditHandleType(\n            this.getSubLayerProps({\n              ...sharedProps,\n\n              // Proxy editing point props\n              radiusScale: this.props.editHandlePointRadiusScale,\n              outline: this.props.editHandlePointOutline,\n              strokeWidth: this.props.editHandlePointStrokeWidth,\n              radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n              radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n              getRadius: this.props.getEditHandlePointRadius,\n              getColor: this.props.getEditHandlePointColor\n            })\n          );\n        }\n        break;\n    }\n\n    return [layer];\n  }\n\n  createTentativeLayers() {\n    if (!this.state.tentativeFeature) {\n      return [];\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: 'tentative',\n        data: this.state.tentativeFeature,\n        fp64: this.props.fp64,\n        pickable: false,\n        stroked: true,\n        autoHighlight: false,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        pointRadiusScale: this.props.editHandlePointRadiusScale,\n        outline: this.props.editHandlePointOutline,\n        strokeWidth: this.props.editHandlePointStrokeWidth,\n        pointRadiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        pointRadiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: this.props.getEditHandlePointRadius,\n        getLineColor: feature => this.props.getTentativeLineColor(feature, this.props.mode),\n        getLineWidth: feature => this.props.getTentativeLineWidth(feature, this.props.mode),\n        getFillColor: feature => this.props.getTentativeFillColor(feature, this.props.mode),\n        getLineDashArray: feature =>\n          this.props.getTentativeLineDashArray(\n            feature,\n            this.state.selectedFeatures[0],\n            this.props.mode\n          )\n      })\n    );\n\n    return [layer];\n  }\n\n  updateTentativeFeature() {\n    const tentativeFeature = this.state.modeHandler.getTentativeFeature();\n    if (tentativeFeature !== this.state.tentativeFeature) {\n      this.setState({ tentativeFeature });\n      this.setLayerNeedsUpdate();\n    }\n  }\n\n  updateEditHandles(picks?: Array<Object>, groundCoords?: Position) {\n    const editHandles = this.state.modeHandler.getEditHandles(picks, groundCoords);\n    if (editHandles !== this.state.editHandles) {\n      this.setState({ editHandles });\n      this.setLayerNeedsUpdate();\n    }\n  }\n\n  onLayerClick(event: ClickEvent) {\n    const editAction = this.state.modeHandler.handleClick(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    const editAction = this.state.modeHandler.handleStartDragging(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    const editAction = this.state.modeHandler.handleStopDragging(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles();\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    const { groundCoords, picks, sourceEvent } = event;\n\n    const { editAction, cancelMapPan } = this.state.modeHandler.handlePointerMove(event);\n    this.updateTentativeFeature();\n    this.updateEditHandles(picks, groundCoords);\n\n    if (cancelMapPan) {\n      // TODO: find a less hacky way to prevent map panning\n      // Stop propagation to prevent map panning while dragging an edit handle\n      sourceEvent.stopPropagation();\n    }\n\n    if (editAction) {\n      this.props.onEdit(editAction);\n    }\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    return this.state.modeHandler.getCursor({ isDragging });\n  }\n}\n\nEditableGeoJsonLayer.layerName = 'EditableGeoJsonLayer';\nEditableGeoJsonLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\nimport { CompositeLayer } from '@deck.gl/core';\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { polygon } from '@turf/helpers';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\n\nimport EditableGeoJsonLayer from './editable-geojson-layer';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\n\nconst defaultProps = {\n  selectionType: SELECTION_TYPE.RECTANGLE,\n  layerIds: [],\n  onSelect: () => {}\n};\n\nconst EMPTY_DATA = {\n  type: 'FeatureCollection',\n  features: []\n};\n\nconst EXPANSION_KM = 50;\nconst LAYER_ID_GEOJSON = 'selection-geojson';\nconst LAYER_ID_BLOCKER = 'selection-blocker';\n\nconst PASS_THROUGH_PROPS = [\n  'lineWidthScale',\n  'lineWidthMinPixels',\n  'lineWidthMaxPixels',\n  'lineWidthUnits',\n  'lineJointRounded',\n  'lineMiterLimit',\n  'pointRadiusScale',\n  'pointRadiusMinPixels',\n  'pointRadiusMaxPixels',\n  'lineDashJustified',\n  'getLineColor',\n  'getFillColor',\n  'getRadius',\n  'getLineWidth',\n  'getLineDashArray',\n  'getTentativeLineDashArray',\n  'getTentativeLineColor',\n  'getTentativeFillColor',\n  'getTentativeLineWidth'\n];\n\nexport default class SelectionLayer extends CompositeLayer {\n  _selectRectangleObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n\n    const [x1, y1] = this.context.viewport.project(coordinates[0][0]);\n    const [x2, y2] = this.context.viewport.project(coordinates[0][2]);\n\n    const pickingInfos = this.context.deck.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds\n    });\n\n    onSelect({ pickingInfos });\n  }\n\n  _selectPolygonObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n    const mousePoints = coordinates[0].map(c => this.context.viewport.project(c));\n\n    const allX = mousePoints.map(mousePoint => mousePoint[0]);\n    const allY = mousePoints.map(mousePoint => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    // Use a polygon to hide the outside, because pickObjects()\n    // does not support polygons\n    const landPointsPoly = polygon(coordinates);\n    const bigBuffer = turfBuffer(landPointsPoly, EXPANSION_KM);\n    let bigPolygon;\n    try {\n      // turfDifference throws an exception if the polygon\n      // intersects with itself (TODO: check if true in all versions)\n      bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n    } catch (e) {\n      // invalid selection polygon\n      console.log('turfDifference() error', e); // eslint-disable-line\n      return;\n    }\n\n    this.setState({\n      pendingPolygonSelection: {\n        bigPolygon\n      }\n    });\n\n    const blockerId = `${this.props.id}-${LAYER_ID_BLOCKER}`;\n\n    // HACK, find a better way\n    setTimeout(() => {\n      const pickingInfos = this.context.deck.pickObjects({\n        x,\n        y,\n        width: maxX - x,\n        height: maxY - y,\n        layerIds: [blockerId, ...layerIds]\n      });\n\n      onSelect({\n        pickingInfos: pickingInfos.filter(item => item.layer.id !== this.props.id)\n      });\n    }, 250);\n  }\n\n  renderLayers() {\n    const { pendingPolygonSelection } = this.state;\n\n    const mode =\n      {\n        [SELECTION_TYPE.RECTANGLE]: 'drawRectangle',\n        [SELECTION_TYPE.POLYGON]: 'drawPolygon'\n      }[this.props.selectionType] || 'view';\n\n    const inheritedProps = {};\n    PASS_THROUGH_PROPS.forEach(p => {\n      if (this.props[p] !== undefined) inheritedProps[p] = this.props[p];\n    });\n\n    const layers = [\n      new EditableGeoJsonLayer(\n        this.getSubLayerProps({\n          id: LAYER_ID_GEOJSON,\n          pickable: true,\n          mode,\n          selectedFeatureIndexes: [],\n          data: EMPTY_DATA,\n          onEdit: ({ updatedData, editType }) => {\n            if (editType === 'addFeature') {\n              const { coordinates } = updatedData.features[0].geometry;\n\n              if (this.props.selectionType === SELECTION_TYPE.RECTANGLE) {\n                this._selectRectangleObjects(coordinates);\n              } else if (this.props.selectionType === SELECTION_TYPE.POLYGON) {\n                this._selectPolygonObjects(coordinates);\n              }\n            }\n          },\n          ...inheritedProps\n        })\n      )\n    ];\n\n    if (pendingPolygonSelection) {\n      const { bigPolygon } = pendingPolygonSelection;\n      layers.push(\n        new PolygonLayer(\n          this.getSubLayerProps({\n            id: LAYER_ID_BLOCKER,\n            pickable: true,\n            stroked: false,\n            opacity: 1.0,\n            data: [bigPolygon],\n            getLineColor: obj => [0, 0, 0, 1],\n            getFillColor: obj => [0, 0, 0, 1],\n            getPolygon: o => o.geometry.coordinates\n          })\n        )\n      );\n    }\n\n    return layers;\n  }\n\n  shouldUpdateState({ changeFlags: { stateChanged, propsOrDataChanged } }: Object) {\n    return stateChanged || propsOrDataChanged;\n  }\n}\n\nSelectionLayer.layerName = 'SelectionLayer';\nSelectionLayer.defaultProps = defaultProps;\n","// @flow\n/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer, LineLayer } from '@deck.gl/layers';\n\nconst defaultProps = {};\n\nexport default class ElevatedEditHandleLayer extends CompositeLayer {\n  renderLayers() {\n    const handles = new ScatterplotLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-ScatterplotLayer`,\n        data: this.props.data\n      })\n    );\n\n    const lines = new LineLayer(\n      Object.assign({}, this.props, {\n        id: `${this.props.id}-LineLayer`,\n        data: this.props.data,\n        pickable: false,\n        getSourcePosition: ({ position }) => [position[0], position[1], 0],\n        getTargetPosition: ({ position }) => [position[0], position[1], position[2] || 0],\n        getColor: [50, 50, 50, 100],\n        getStrokeWidth: 3\n      })\n    );\n\n    return [handles, lines];\n  }\n}\n\nElevatedEditHandleLayer.layerName = 'ElevatedEditHandleLayer';\nElevatedEditHandleLayer.defaultProps = defaultProps;\n","/* eslint-disable camelcase */\nconst INITIAL_STATE = {\n  outlineEnabled: false,\n  outlineRenderShadowmap: false,\n  outlineShadowmap: null\n};\n\nfunction getUniforms({ outlineEnabled, outlineRenderShadowmap, outlineShadowmap } = INITIAL_STATE) {\n  const uniforms = {};\n  if (outlineEnabled !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uEnabled = outlineEnabled;\n  }\n  if (outlineRenderShadowmap !== undefined) {\n    // ? 1.0 : 0.0;\n    uniforms.outline_uRenderOutlines = outlineRenderShadowmap;\n  }\n  if (outlineShadowmap !== undefined) {\n    uniforms.outline_uShadowmap = outlineShadowmap;\n  }\n  return uniforms;\n}\n\nconst vs = `\\\nattribute float instanceZLevel;\nvarying float outline_vzLevel;\nvarying vec4 outline_vPosition;\n\n// Set the z level for the outline shadowmap rendering\nvoid outline_setZLevel(float zLevel) {\n  outline_vzLevel = zLevel;\n}\n\n// Store an adjusted position for texture2DProj\nvoid outline_setUV(vec4 position) {\n  // mat4(\n  //   0.5, 0.0, 0.0, 0.0,\n  //   0.0, 0.5, 0.0, 0.0,\n  //   0.0, 0.0, 0.5, 0.0,\n  //   0.5, 0.5, 0.5, 1.0\n  // ) * position;\n  outline_vPosition = vec4(position.xyz * 0.5 + position.w * 0.5, position.w);\n}\n`;\n\nconst fs = `\\\nuniform bool outline_uEnabled;\nuniform bool outline_uRenderOutlines;\nuniform sampler2D outline_uShadowmap;\n\nvarying float outline_vzLevel;\n// varying vec2 outline_vUV;\nvarying vec4 outline_vPosition;\n\nconst float OUTLINE_Z_LEVEL_ERROR = 0.01;\n\n// Return a darker color in shadowmap\nvec4 outline_filterShadowColor(vec4 color) {\n  return vec4(outline_vzLevel / 255., outline_vzLevel / 255., outline_vzLevel / 255., 1.);\n}\n\n// Return a darker color if in shadowmap\nvec4 outline_filterDarkenColor(vec4 color) {\n  if (outline_uEnabled) {\n    float maxZLevel;\n    if (outline_vPosition.q > 0.0) {\n      maxZLevel = texture2DProj(outline_uShadowmap, outline_vPosition).r * 255.;\n    } else {\n      discard;\n    }\n    if (maxZLevel < outline_vzLevel + OUTLINE_Z_LEVEL_ERROR) {\n      vec4(color.rgb * 0.5, color.a);\n    } else {\n      discard;\n    }\n  }\n  return color;\n}\n\n// if enabled and rendering outlines - Render depth to shadowmap\n// if enabled and rendering colors - Return a darker color if in shadowmap\n// if disabled, just return color\nvec4 outline_filterColor(vec4 color) {\n  if (outline_uEnabled) {\n    return outline_uRenderOutlines ?\n      outline_filterShadowColor(color) :\n      outline_filterDarkenColor(color);\n  }\n  return color;\n}\n`;\n\nexport default {\n  name: 'outline',\n  vs,\n  fs,\n  getUniforms\n};\n","import { PathLayer } from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport { Framebuffer, Texture2D } from '@luma.gl/core';\nimport outline from '../../shaderlib/outline/outline';\n\n// TODO - this should be built into assembleShaders\nfunction injectShaderCode({ source, code = '' }) {\n  const INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nconst VS_CODE = `\\\n  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n`;\n\nconst FS_CODE = `\\\n  gl_FragColor = outline_filterColor(gl_FragColor);\n`;\n\nconst defaultProps = {\n  getZLevel: { type: 'accessor', value: 0 }\n};\n\nexport default class PathOutlineLayer extends PathLayer {\n  // Override getShaders to inject the outline module\n  getShaders() {\n    const shaders = super.getShaders();\n    return Object.assign({}, shaders, {\n      modules: shaders.modules.concat([outline]),\n      vs: injectShaderCode({ source: shaders.vs, code: VS_CODE }),\n      fs: injectShaderCode({ source: shaders.fs, code: FS_CODE })\n    });\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    // Create an outline \"shadow\" map\n    // TODO - we should create a single outlineMap for all layers\n    this.setState({\n      outlineFramebuffer: new Framebuffer(context.gl),\n      dummyTexture: new Texture2D(context.gl)\n    });\n\n    // Create an attribute manager\n    this.state.attributeManager.addInstanced({\n      instanceZLevel: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateZLevels,\n        accessor: 'getZLevel'\n      }\n    });\n  }\n\n  // Override draw to add render module\n  draw({ moduleParameters = {}, parameters, uniforms, context }) {\n    // Need to calculate same uniforms as base layer\n    const {\n      rounded,\n      miterLimit,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n      dashJustified\n    } = this.props;\n\n    uniforms = Object.assign({}, uniforms, {\n      jointType: Number(rounded),\n      alignMode: Number(dashJustified),\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels\n    });\n\n    // Render the outline shadowmap (based on segment z orders)\n    const { outlineFramebuffer, dummyTexture } = this.state;\n    outlineFramebuffer.resize();\n    outlineFramebuffer.clear({ color: true, depth: true });\n\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: true,\n      outlineShadowmap: dummyTexture\n    });\n\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: 0,\n        widthScale: this.props.widthScale * 1.3\n      }),\n      parameters: {\n        depthTest: false,\n        // Biggest value needs to go into buffer\n        blendEquation: GL.MAX\n      },\n      framebuffer: outlineFramebuffer\n    });\n\n    // Now use the outline shadowmap to render the lines (with outlines)\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: false,\n      outlineShadowmap: outlineFramebuffer\n    });\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        widthScale: this.props.widthScale\n      }),\n      parameters: {\n        depthTest: false\n      }\n    });\n  }\n\n  calculateZLevels(attribute) {\n    const { getZLevel } = this.props;\n    const { pathTesselator } = this.state;\n\n    attribute.value = pathTesselator._updateAttribute({\n      target: attribute.value,\n      size: 1,\n      getValue: (object, index) => [getZLevel(object, index) || 0]\n    });\n  }\n}\n\nPathOutlineLayer.layerName = 'PathOutlineLayer';\nPathOutlineLayer.defaultProps = defaultProps;\n","// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport { Layer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport { Model, Geometry, loadTextures, Texture2D, fp64 } from '@luma.gl/core';\nconst { fp64LowPart } = fp64;\n\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nconst RADIAN_PER_DEGREE = Math.PI / 180;\n\n// Replacement for the external assert method to reduce bundle size\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(`deck.gl: ${message}`);\n  }\n}\n\n/*\n * Load image data into luma.gl Texture2D objects\n * @param {WebGLContext} gl\n * @param {String|Texture2D|HTMLImageElement|Uint8ClampedArray} src - source of image data\n *   can be url string, Texture2D object, HTMLImageElement or pixel array\n * @returns {Promise} resolves to an object with name -> texture mapping\n */\nfunction getTexture(gl, src, opts) {\n  if (typeof src === 'string') {\n    // Url, load the image\n    return loadTextures(gl, Object.assign({ urls: [src] }, opts))\n      .then(textures => textures[0])\n      .catch(error => {\n        throw new Error(`Could not load texture from ${src}: ${error}`);\n      });\n  }\n  return new Promise(resolve => resolve(getTextureFromData(gl, src, opts)));\n}\n\n/*\n * Convert image data into texture\n * @returns {Texture2D} texture\n */\nfunction getTextureFromData(gl, data, opts) {\n  if (data instanceof Texture2D) {\n    return data;\n  }\n  return new Texture2D(gl, Object.assign({ data }, opts));\n}\n\nfunction validateGeometryAttributes(attributes) {\n  assert(attributes.positions && attributes.normals && attributes.texCoords);\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data) {\n  if (data instanceof Geometry) {\n    validateGeometryAttributes(data.attributes);\n    return data;\n  } else if (data.positions) {\n    validateGeometryAttributes(data);\n    return new Geometry({\n      attributes: data\n    });\n  }\n  throw Error('Invalid mesh');\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  mesh: null,\n  texture: null,\n  sizeScale: { type: 'number', value: 1, min: 0 },\n\n  // TODO - parameters should be merged, not completely overridden\n  parameters: {\n    depthTest: true,\n    depthFunc: GL.LEQUAL\n  },\n  fp64: false,\n  // Optional settings for 'lighting' shader module\n  lightSettings: {},\n\n  getPosition: { type: 'accessor', value: x => x.position },\n  getColor: { type: 'accessor', value: DEFAULT_COLOR },\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  getYaw: { type: 'accessor', value: x => x.yaw || x.angle || 0 },\n  getPitch: { type: 'accessor', value: x => x.pitch || 0 },\n  getRoll: { type: 'accessor', value: x => x.roll || 0 }\n};\n\nexport default class MeshLayer extends Layer {\n  getShaders() {\n    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n    return { vs, fs, modules: [projectModule, 'lighting', 'picking'] };\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instancePositions64xy: {\n        size: 2,\n        accessor: 'getPosition',\n        update: this.calculateInstancePositions64xyLow\n      },\n      instanceRotations: {\n        size: 3,\n        accessor: ['getYaw', 'getPitch', 'getRoll'],\n        update: this.calculateInstanceRotations\n      },\n      instanceColors: {\n        size: 4,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      }\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    const attributeManager = this.getAttributeManager();\n\n    // super.updateState({props, oldProps, changeFlags});\n    if (changeFlags.dataChanged) {\n      attributeManager.invalidateAll();\n    }\n\n    this._updateFP64(props, oldProps);\n\n    if (props.texture !== oldProps.texture) {\n      this.setTexture(props.texture);\n    }\n  }\n\n  _updateFP64(props, oldProps) {\n    if (props.fp64 !== oldProps.fp64) {\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n\n      this.setState({ model: this.getModel(this.context.gl) });\n\n      this.setTexture(this.state.texture);\n\n      const attributeManager = this.getAttributeManager();\n      attributeManager.invalidateAll();\n    }\n  }\n\n  draw({ uniforms }) {\n    const { sizeScale } = this.props;\n\n    this.state.model.render(\n      Object.assign({}, uniforms, {\n        sizeScale\n      })\n    );\n  }\n\n  getModel(gl) {\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: getGeometry(this.props.mesh),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      })\n    );\n  }\n\n  setTexture(src) {\n    const { gl } = this.context;\n    const { model, emptyTexture } = this.state;\n\n    if (src) {\n      getTexture(gl, src).then(texture => {\n        model.setUniforms({ sampler: texture, hasTexture: 1 });\n        this.setState({ texture });\n      });\n    } else {\n      // reset\n      this.state.model.setUniforms({ sampler: emptyTexture, hasTexture: 0 });\n      this.setState({ texture: null });\n    }\n  }\n\n  calculateInstancePositions64xyLow(attribute) {\n    const isFP64 = this.use64bitPositions();\n    attribute.constant = !isFP64;\n\n    if (!isFP64) {\n      attribute.value = new Float32Array(2);\n      return;\n    }\n\n    const { data, getPosition } = this.props;\n    const { value } = attribute;\n    let i = 0;\n    for (const point of data) {\n      const position = getPosition(point);\n      value[i++] = fp64LowPart(position[0]);\n      value[i++] = fp64LowPart(position[1]);\n    }\n  }\n\n  // yaw(z), pitch(y) and roll(x) in radians\n  calculateInstanceRotations(attribute) {\n    const { data, getYaw, getPitch, getRoll } = this.props;\n    const { value, size } = attribute;\n    let i = 0;\n    for (const point of data) {\n      value[i++] = getRoll(point) * RADIAN_PER_DEGREE;\n      value[i++] = getPitch(point) * RADIAN_PER_DEGREE;\n      value[i++] = getYaw(point) * RADIAN_PER_DEGREE;\n    }\n  }\n}\n\nMeshLayer.layerName = 'MeshLayer';\nMeshLayer.defaultProps = defaultProps;\n","export default `\n#define SHADER_NAME mesh-layer-vs\n\n// Scale the model\nuniform float sizeScale;\n\n// Primitive attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec2 texCoords;\n\n// Instance attributes\nattribute vec3 instancePositions;\nattribute vec2 instancePositions64xy;\nattribute vec3 instanceRotations;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\n// Outputs to fragment shader\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\n\n// yaw(z) pitch(y) roll(x)\nmat3 getRotationMatrix(vec3 rotation) {\n  float sr = sin(rotation.x);\n  float sp = sin(rotation.y);\n  float sw = sin(rotation.z);\n\n  float cr = cos(rotation.x);\n  float cp = cos(rotation.y);\n  float cw = cos(rotation.z);\n\n  return mat3(\n    cw * cp,                  // 0,0\n    sw * cp,                  // 1,0\n    -sp,                      // 2,0\n    -sw * cr + cw * sp * sr,  // 0,1\n    cw * cr + sw * sp * sr,   // 1,1\n    cp * sr,                  // 2,1\n    sw * sr + cw * sp * cr,   // 0,2\n    -cw * sr + sw * sp * cr,  // 1,2\n    cp * cr                   // 2,2\n  );\n}\n\nvoid main(void) {\n  mat3 rotationMatrix = getRotationMatrix(instanceRotations);\n\n  vec3 pos = rotationMatrix * positions;\n  pos = project_scale(pos * sizeScale);\n  // TODO - backward compatibility, remove in next major release\n  if (project_uPixelsPerMeter.y < 0.0) {\n    pos.y = -pos.y;\n  }\n\n  vec4 worldPosition;\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xy, pos, worldPosition);\n\n  // TODO - transform normals\n\n  picking_setPickingColor(instancePickingColors);\n\n  vTexCoord = texCoords;\n  vColor = instanceColors;\n}\n`;\n","export default `\n#define SHADER_NAME mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\nuniform sampler2D sampler;\nuniform vec4 color;\n\nvarying vec2 vTexCoord;\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = hasTexture ? texture2D(sampler, vTexCoord) : vColor / 255.;\n\n  // use highlight color if this fragment belongs to the selected object.\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n\n  // use picking color if rendering to picking FBO.\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n}\n`;\n","import { Geometry } from '@luma.gl/core';\n\nexport default class Arrow2DGeometry extends Geometry {\n  constructor(opts = {}) {\n    super(\n      Object.assign({}, opts, {\n        attributes: getArrowAttributes(opts)\n      })\n    );\n  }\n}\n\nfunction getArrowAttributes({ length = 1, headSize = 0.2, tailWidth = 0.05, tailStart = 0.05 }) {\n  const texCoords = [\n    // HEAD\n    0.5,\n    1.0,\n    0,\n    0.5 - headSize / 2,\n    1.0 - headSize,\n    0,\n    0.5 + headSize / 2,\n    1.0 - headSize,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    tailStart,\n    0,\n\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 - tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0\n  ];\n\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\n\n  // Center and scale\n  const positions = new Array(texCoords.length);\n  for (let i = 0; i < texCoords.length / 3; i++) {\n    const i3 = i * 3;\n    positions[i3 + 0] = (texCoords[i3 + 0] - 0.5) * length;\n    positions[i3 + 1] = (texCoords[i3 + 1] - 0.5) * length;\n    positions[i3 + 2] = 0;\n  }\n  return {\n    positions: new Float32Array(positions),\n    normals: new Float32Array(normals),\n    texCoords: new Float32Array(texCoords)\n  };\n}\n","import { Vector2 } from 'math.gl';\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  let lineLength = 0;\n  for (let i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n  return lineLength;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_DIRECTION = { forward: true, backward: false };\n\nexport default function createPathMarkers({\n  data,\n  getPath = x => x.path,\n  getDirection = x => x.direction,\n  getColor = x => DEFAULT_COLOR,\n  getMarkerPercentages = x => [0.5],\n  projectFlat\n}) {\n  const markers = [];\n\n  for (const object of data) {\n    const path = getPath(object);\n    const direction = getDirection(object) || DEFAULT_DIRECTION;\n    const color = getColor(object);\n\n    const vPoints = path.map(p => new Vector2(p));\n    const vPointsReverse = vPoints.slice(0).reverse();\n\n    // calculate total length\n    const lineLength = getLineLength(vPoints);\n\n    // Ask for where to put markers\n    const percentages = getMarkerPercentages(object, { lineLength });\n\n    // Create the markers\n    for (const percentage of percentages) {\n      if (direction.forward) {\n        const marker = createMarkerAlongPath({\n          path: vPoints,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n\n      if (direction.backward) {\n        const marker = createMarkerAlongPath({\n          path: vPointsReverse,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat\n        });\n        markers.push(marker);\n      }\n    }\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath({ path, percentage, lineLength, color, object, projectFlat }) {\n  const distanceAlong = lineLength * percentage;\n  let currentDistance = 0;\n  let previousDistance = 0;\n  let i = 0;\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n    previousDistance = currentDistance;\n  }\n\n  const vDirection = path[i + 1]\n    .clone()\n    .subtract(path[i])\n    .normalize();\n  const along = distanceAlong - previousDistance;\n  const vCenter = vDirection\n    .clone()\n    .multiply(new Vector2(along, along))\n    .add(path[i]);\n\n  const vDirection2 = new Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n  const angle = (-vDirection2.verticalAngle() * 180) / Math.PI;\n\n  return { position: [vCenter.x, vCenter.y, 0], angle, color, object };\n}\n","import { Vector3, clamp } from 'math.gl';\n\n// Return the closest point on a line segment\nexport function getClosestPointOnLine({ p, p1, p2, clampToLine = true }) {\n  const lineVector = new Vector3(p2).subtract(p1);\n  const pointVector = new Vector3(p).subtract(p1);\n  let dotProduct = lineVector.dot(pointVector);\n  if (clampToLine) {\n    dotProduct = clamp(dotProduct, 0, 1);\n  }\n  return lineVector.lerp(dotProduct);\n}\n\n// Return the closest point on a line segment\nexport function getClosestPointOnPolyline({ p, points }) {\n  p = new Vector3(p);\n  let pClosest = null;\n  let distanceSquared = Infinity;\n  let index = -1;\n  for (let i = 0; i < points.length - 1; ++i) {\n    const p1 = points[i];\n    const p2 = points[i + 1];\n    const pClosestOnLine = getClosestPointOnLine({ p, p1, p2 });\n    const distanceToLineSquared = p.distanceSquared(pClosestOnLine);\n    if (distanceToLineSquared < distanceSquared) {\n      distanceSquared = distanceToLineSquared;\n      pClosest = pClosestOnLine;\n      index = i;\n    }\n  }\n  return {\n    point: pClosest,\n    index,\n    p1: points[index],\n    p2: points[index + 1],\n    distanceSquared,\n    distance: Math.sqrt(distanceSquared)\n  };\n}\n","import { CompositeLayer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\nimport PathOutlineLayer from '../path-outline-layer/path-outline-layer';\nimport MeshLayer from '../mesh-layer/mesh-layer';\nimport Arrow2DGeometry from './arrow-2d-geometry';\n\nimport createPathMarkers from './create-path-markers';\nimport { getClosestPointOnPolyline } from './polyline';\n\nconst DISTANCE_FOR_MULTI_ARROWS = 0.1;\nconst ARROW_HEAD_SIZE = 0.2;\nconst ARROW_TAIL_WIDTH = 0.05;\n// const ARROW_CENTER_ADJUST = -0.8;\n\nconst DEFAULT_MARKER_LAYER = MeshLayer;\n\nconst DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH })\n};\n\nconst defaultProps = Object.assign({}, PathOutlineLayer.defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n\n  sizeScale: 100,\n  fp64: false,\n\n  hightlightIndex: -1,\n  highlightPoint: null,\n\n  getPath: x => x.path,\n  getColor: x => x.color,\n  getMarkerColor: x => [0, 0, 0, 255],\n  getDirection: x => x.direction,\n  getMarkerPercentages: (object, { lineLength }) =>\n    lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5]\n});\n\nexport default class PathMarkerLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      markers: [],\n      mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n      closestPoint: null\n    };\n  }\n\n  projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n    if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n      const [dx, dy] = viewport.metersToLngLatDelta(xyz);\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    } else if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n      const [dx, dy] = xyz;\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    }\n\n    return viewport.projectFlat(xyz);\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n      const {\n        data,\n        getPath,\n        getDirection,\n        getMarkerColor,\n        getMarkerPercentages,\n        coordinateSystem,\n        coordinateOrigin\n      } = this.props;\n      const { viewport } = this.context;\n      const projectFlat = o => this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n      this.state.markers = createPathMarkers({\n        data,\n        getPath,\n        getDirection,\n        getColor: getMarkerColor,\n        getMarkerPercentages,\n        projectFlat\n      });\n      this._recalculateClosestPoint();\n    }\n    if (changeFlags.propsChanged) {\n      if (props.point !== oldProps.point) {\n        this._recalculateClosestPoint();\n      }\n    }\n  }\n\n  _recalculateClosestPoint() {\n    const { highlightPoint, highlightIndex } = this.props;\n    if (highlightPoint && highlightIndex >= 0) {\n      const object = this.props.data[highlightIndex];\n      const points = this.props.getPath(object);\n      const { point } = getClosestPointOnPolyline({ points, p: highlightPoint });\n      this.state.closestPoints = [\n        {\n          position: point\n        }\n      ];\n    } else {\n      this.state.closestPoints = [];\n    }\n  }\n\n  getPickingInfo({ info }) {\n    return Object.assign(info, {\n      // override object with picked feature\n      object: (info.object && info.object.path) || info.object\n    });\n  }\n\n  renderLayers() {\n    return [\n      new PathOutlineLayer(\n        this.props,\n        this.getSubLayerProps({\n          id: 'paths',\n          // Note: data has to be passed explicitly like this to avoid being empty\n          data: this.props.data\n        })\n      ),\n      new this.props.MarkerLayer(\n        this.getSubLayerProps(\n          Object.assign({}, this.props.markerLayerProps, {\n            id: 'markers',\n            data: this.state.markers,\n            sizeScale: this.props.sizeScale,\n            fp64: this.props.fp64,\n            pickable: false,\n            parameters: {\n              blend: false,\n              depthTest: false\n            }\n          })\n        )\n      ),\n      this.state.closestPoints &&\n        new ScatterplotLayer({\n          id: `${this.props.id}-highlight`,\n          data: this.state.closestPoints,\n          fp64: this.props.fp64\n        })\n    ];\n  }\n}\n\nPathMarkerLayer.layerName = 'PathMarkerLayer';\nPathMarkerLayer.defaultProps = defaultProps;\n","// @flow\nimport { CompositeLayer } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\n\nexport default class JunctionScatterplotLayer extends CompositeLayer {\n  static layerName = 'JunctionScatterplotLayer';\n  static defaultProps = {\n    ...ScatterplotLayer.defaultProps,\n    getFillColor: d => [0, 0, 0, 255],\n    getStrokeColor: d => [255, 255, 255, 255],\n    getInnerRadius: d => 1\n  };\n\n  renderLayers() {\n    const { id, getFillColor, getStrokeColor, getInnerRadius, updateTriggers } = this.props;\n\n    // data needs to be passed explicitly after deck.gl 5.3\n    return [\n      // the full circles\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-full`,\n        data: this.props.data,\n        getColor: getStrokeColor,\n        updateTriggers: {\n          ...updateTriggers,\n          getColor: updateTriggers.getStrokeColor\n        }\n      }),\n      // the inner part\n      new ScatterplotLayer({\n        ...this.props,\n        id: `${id}-inner`,\n        data: this.props.data,\n        getColor: getFillColor,\n        getRadius: getInnerRadius,\n        pickable: false,\n        updateTriggers: {\n          ...updateTriggers,\n          getColor: updateTriggers.getFillColor,\n          getRadius: updateTriggers.getInnerRadius\n        }\n      })\n    ];\n  }\n}\n","// @flow\n\nimport type { FeatureCollection, Feature, Position } from '../geojson-types.js';\nimport type {\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent\n} from '../event-types.js';\nimport { ModeHandler, type EditAction, type EditHandle } from './mode-handler.js';\n\nexport class CompositeModeHandler extends ModeHandler {\n  handlers: Array<ModeHandler>;\n  options: Object;\n\n  constructor(handlers: Array<ModeHandler>, options: Object = {}) {\n    super();\n    this.handlers = handlers;\n    this.options = options;\n  }\n\n  _coalesce<T>(callback: ModeHandler => T, resultEval: ?(T) => boolean = null): T {\n    let result: T;\n\n    for (let i = 0; i < this.handlers.length; i++) {\n      result = callback(this.handlers[i]);\n      if (resultEval ? resultEval(result) : result) {\n        break;\n      }\n    }\n\n    return (result: any);\n  }\n\n  setFeatureCollection(featureCollection: FeatureCollection): void {\n    this.handlers.forEach(handler => handler.setFeatureCollection(featureCollection));\n  }\n\n  setModeConfig(modeConfig: any): void {\n    this.handlers.forEach(handler => handler.setModeConfig(modeConfig));\n  }\n\n  setSelectedFeatureIndexes(indexes: number[]): void {\n    this.handlers.forEach(handler => handler.setSelectedFeatureIndexes(indexes));\n  }\n\n  setDeckGlContext(context: Object) {\n    this.handlers.forEach(handler => handler.setDeckGlContext(context));\n  }\n\n  handleClick(event: ClickEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleClick(event));\n  }\n\n  handlePointerMove(event: PointerMoveEvent): { editAction: ?EditAction, cancelMapPan: boolean } {\n    return this._coalesce(\n      handler => handler.handlePointerMove(event),\n      result => result && Boolean(result.editAction)\n    );\n  }\n\n  handleStartDragging(event: StartDraggingEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleStartDragging(event));\n  }\n\n  handleStopDragging(event: StopDraggingEvent): ?EditAction {\n    return this._coalesce(handler => handler.handleStopDragging(event));\n  }\n\n  getTentativeFeature(): ?Feature {\n    return this._coalesce(handler => handler.getTentativeFeature());\n  }\n\n  getEditHandles(picks?: Array<Object>, groundCoords?: Position): EditHandle[] {\n    // TODO: Combine the handles *BUT* make sure if none of the results have\n    // changed to return the same object so that \"editHandles !== this.state.editHandles\"\n    // in editable-geojson-layer works.\n    return this._coalesce(\n      handler => handler.getEditHandles(picks, groundCoords),\n      handles => Array.isArray(handles) && handles.length > 0\n    );\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }): string {\n    return this._coalesce(handler => handler.getCursor({ isDragging }));\n  }\n}\n","// @flow\nimport { PathMarkerLayer } from '@nebula.gl/layers';\nimport { MAX } from '@luma.gl/constants';\n\nimport { ArrowStyles, DEFAULT_STYLE, MAX_ARROWS } from '../style';\nimport NebulaLayer from '../nebula-layer';\nimport { toDeckColor } from '../utils';\nimport DeckCache from '../deck-renderer/deck-cache';\n\nconst NEBULA_TO_DECK_DIRECTIONS = {\n  [ArrowStyles.NONE]: { forward: false, backward: false },\n  [ArrowStyles.FORWARD]: { forward: true, backward: false },\n  [ArrowStyles.BACKWARD]: { forward: false, backward: true },\n  [ArrowStyles.BOTH]: { forward: true, backward: true }\n};\n\nexport default class SegmentsLayer extends NebulaLayer {\n  deckCache: DeckCache<*, *>;\n  noBlend: boolean;\n  highlightColor: [number, number, number, number];\n  arrowSize: number;\n  rounded: boolean;\n  dashed: boolean;\n  markerLayerProps: ?Object;\n\n  constructor(config: Object) {\n    super(config);\n    this.deckCache = new DeckCache(config.getData, data => config.toNebulaFeature(data));\n    this.enableSelection = true;\n    const {\n      enablePicking = true,\n      noBlend = false,\n      rounded = true,\n      dashed = false,\n      markerLayerProps = null\n    } = config;\n    Object.assign(this, { enablePicking, noBlend, rounded, dashed, markerLayerProps });\n  }\n\n  getMouseOverSegment(): any {\n    // TODO: remove references\n    return null;\n  }\n\n  _calcMarkerPercentages(nf: Object): number[] {\n    const { arrowPercentages } = nf.style;\n    if (arrowPercentages) {\n      return arrowPercentages;\n    }\n\n    const arrowStyle = nf.style.arrowStyle || DEFAULT_STYLE.arrowStyle;\n    if (arrowStyle === ArrowStyles.NONE) return [];\n\n    const arrowCount = Math.min(nf.style.arrowCount || DEFAULT_STYLE.arrowCount, MAX_ARROWS);\n    return [[0.5], [0.33, 0.66], [0.25, 0.5, 0.75]][arrowCount - 1];\n  }\n\n  _getHighlightedObjectIndex({ nebula }: Object): number {\n    const { deckglMouseOverInfo } = nebula;\n    if (deckglMouseOverInfo) {\n      const { originalLayer, index } = deckglMouseOverInfo;\n      if (originalLayer === this) {\n        return index;\n      }\n    }\n\n    // no object\n    return -1;\n  }\n\n  render({ nebula }: Object) {\n    const defaultColor = [0x0, 0x0, 0x0, 0xff];\n    const { objects, updateTrigger } = this.deckCache;\n\n    return new PathMarkerLayer({\n      id: `segments-${this.id}`,\n      data: objects,\n      opacity: 1,\n      fp64: false,\n      rounded: this.rounded,\n      pickable: true,\n      sizeScale: this.arrowSize || 6,\n      parameters: {\n        depthTest: false,\n        blend: !this.noBlend,\n        blendEquation: MAX\n      },\n      getPath: nf => nf.geoJson.geometry.coordinates,\n      getColor: nf => toDeckColor(nf.style.lineColor, defaultColor),\n      getWidth: nf => nf.style.lineWidthMeters || 1,\n      getZLevel: nf => nf.style.zLevel * 255,\n      getDirection: nf => NEBULA_TO_DECK_DIRECTIONS[nf.style.arrowStyle],\n      getMarkerColor: nf => toDeckColor(nf.style.arrowColor, defaultColor),\n      getMarkerPercentages: this._calcMarkerPercentages,\n      updateTriggers: { all: updateTrigger },\n\n      highlightedObjectIndex: this._getHighlightedObjectIndex({ nebula }),\n      highlightColor: toDeckColor(this.highlightColor),\n\n      dashJustified: this.dashed,\n      getDashArray: this.dashed ? nf => nf.style.dashArray : null,\n      markerLayerProps:\n        this.markerLayerProps || (PathMarkerLayer: Object).defaultProps.markerLayerProps,\n\n      nebulaLayer: this\n    });\n  }\n}\n","import React from 'react';\n\nexport const styles = {\n  toolbox: {\n    position: 'absolute',\n    top: 12,\n    left: 12,\n    background: 'white',\n    padding: 10,\n    borderRadius: 4,\n    border: '1px solid gray',\n    width: 350,\n    fontFamily: 'Arial, Helvetica, sans-serif',\n    fontSize: '13px'\n  },\n  toolboxRow: {\n    display: 'flex',\n    flexWrap: 'wrap'\n  },\n  toolboxRowWrapping: {\n    display: 'flex',\n    marginBottom: '5px',\n    flexWrap: 'wrap'\n  },\n  toolboxDivider: {\n    marginBottom: '5px',\n    borderBottom: '1px solid gray'\n  },\n  toolboxItem: {\n    flexBasis: '50%'\n  },\n  toolboxLabel: {\n    textTransform: 'uppercase'\n  }\n};\n\nexport const ToolboxRow = props => <div style={styles.toolboxRow}>{props.children}</div>;\nexport const ToolboxRowWrapping = props => (\n  <div style={styles.toolboxRowWrapping}>{props.children}</div>\n);\nexport const ToolboxLabel = props => <div style={styles.toolboxLabel}>{props.children}</div>;\nexport const ToolboxControl = props => <div style={styles.toolboxItem}>{props.children}</div>;\nexport const ToolboxDivider = props => <div style={styles.toolboxDivider} />;\n","// @flow\n\nimport window from 'global/window';\nimport React, { Component } from 'react';\nimport DeckGL from '@deck.gl/react';\nimport { MapView, MapController } from '@deck.gl/core';\nimport { StaticMap } from 'react-map-gl';\nimport GL from '@luma.gl/constants';\nimport circle from '@turf/circle';\n\nimport {\n  EditableGeoJsonLayer,\n  SelectionLayer,\n  CompositeModeHandler,\n  ModifyHandler,\n  DrawLineStringHandler,\n  ElevatedEditHandleLayer,\n  SELECTION_TYPE\n} from 'nebula.gl';\n\nimport sampleGeoJson from '../data/sample-geojson.json';\n\nimport iconSheet from '../data/edit-handles.png';\n\nimport {\n  ToolboxControl,\n  ToolboxDivider,\n  ToolboxLabel,\n  ToolboxRow,\n  ToolboxRowWrapping,\n  styles as ToolboxStyles\n} from './toolbox';\n\nconst styles = {\n  mapContainer: {\n    alignItems: 'stretch',\n    display: 'flex',\n    height: '100vh'\n  },\n  checkbox: {\n    margin: 10\n  }\n};\n\nconst initialViewport = {\n  bearing: 0,\n  height: 0,\n  latitude: 37.76,\n  longitude: -122.44,\n  pitch: 0,\n  width: 0,\n  zoom: 11\n};\n\nconst ALL_MODES = [\n  { category: 'View', modes: ['view'] },\n  {\n    category: 'Alter',\n    modes: ['modify', 'elevation', 'translate', 'rotate', 'scale', 'duplicate', 'extrude', 'split']\n  },\n  {\n    category: 'Draw',\n    modes: [\n      'drawPoint',\n      'drawLineString',\n      'drawPolygon',\n      'draw90DegreePolygon',\n      'drawRectangle',\n      'drawRectangleUsing3Points',\n      'drawCircleFromCenter',\n      'drawCircleByBoundingBox',\n      'drawEllipseByBoundingBox',\n      'drawEllipseUsing3Points'\n    ]\n  },\n  {\n    category: 'Composite',\n    modes: ['drawLineString+modify']\n  }\n];\n\nconst POLYGON_DRAWING_MODES = [\n  'drawPolygon',\n  'draw90DegreePolygon',\n  'drawRectangle',\n  'drawRectangleUsing3Points',\n  'drawCircleFromCenter',\n  'drawCircleByBoundingBox',\n  'drawEllipseByBoundingBox',\n  'drawEllipseUsing3Points'\n];\n\nconst modeHandlers = Object.assign(\n  {\n    'drawLineString+modify': new CompositeModeHandler([\n      new DrawLineStringHandler(),\n      new ModifyHandler()\n    ])\n  },\n  EditableGeoJsonLayer.defaultProps.modeHandlers\n);\n\nfunction getEditHandleColor(handle: Object) {\n  switch (handle.type) {\n    case 'existing':\n      return [0xff, 0x80, 0x00, 0xff];\n    case 'snap':\n      return [0x7c, 0x00, 0xc0, 0xff];\n    case 'intermediate':\n    default:\n      return [0x0, 0x0, 0x0, 0x80];\n  }\n}\n\nexport default class Example extends Component<\n  {},\n  {\n    viewport: Object,\n    testFeatures: any,\n    mode: string,\n    modeConfig: any,\n    pointsRemovable: boolean,\n    selectedFeatureIndexes: number[],\n    editHandleType: string,\n    selectionTool: ?string\n  }\n> {\n  constructor() {\n    super();\n\n    this.state = {\n      viewport: initialViewport,\n      testFeatures: sampleGeoJson,\n      mode: 'drawPolygon',\n      modeConfig: null,\n      pointsRemovable: true,\n      selectedFeatureIndexes: [],\n      editHandleType: 'point',\n      selectionTool: null\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this._resize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this._resize);\n  }\n\n  _onChangeViewport = (viewport: Object) => {\n    this.setState({\n      viewport: { ...this.state.viewport, ...viewport }\n    });\n  };\n\n  _onLayerClick = (info: any) => {\n    console.log('onLayerClick', info); // eslint-disable-line\n\n    if (this.state.mode !== 'view' || this.state.selectionTool) {\n      // don't change selection while editing\n      return;\n    }\n\n    if (info) {\n      console.log(`select editing feature ${info.index}`); // eslint-disable-line\n      // a feature was clicked\n      // TODO: once https://github.com/uber/deck.gl/pull/1918 lands, this will work since it'll work with Multi* geometry types\n      this.setState({ selectedFeatureIndexes: [info.index] });\n    } else {\n      console.log('deselect editing feature'); // eslint-disable-line\n      // open space was clicked, so stop editing\n      this.setState({ selectedFeatureIndexes: [] });\n    }\n  };\n\n  _resize = () => {\n    this.forceUpdate();\n  };\n\n  _loadSample = (type: string) => {\n    if (type === 'mixed') {\n      this.setState({\n        testFeatures: sampleGeoJson,\n        selectedFeatureIndexes: []\n      });\n    } else if (type === 'complex') {\n      this.setState({\n        testFeatures: {\n          type: 'FeatureCollection',\n          features: [\n            circle([-122.45, 37.81], 4, { steps: 5000 }),\n            circle([-122.33, 37.81], 4, { steps: 5000 }),\n            circle([-122.45, 37.73], 4, { steps: 5000 }),\n            circle([-122.33, 37.73], 4, { steps: 5000 })\n          ]\n        },\n        selectedFeatureIndexes: []\n      });\n    }\n  };\n\n  _renderSelectFeatureCheckbox(index: number, featureType: string) {\n    const { selectedFeatureIndexes } = this.state;\n    return (\n      <ToolboxLabel key={index}>\n        <label>\n          <input\n            style={styles.checkbox}\n            type=\"checkbox\"\n            checked={selectedFeatureIndexes.includes(index)}\n            onChange={() => {\n              if (selectedFeatureIndexes.includes(index)) {\n                this.setState({\n                  selectedFeatureIndexes: selectedFeatureIndexes.filter(e => e !== index)\n                });\n              } else {\n                this.setState({\n                  selectedFeatureIndexes: [...selectedFeatureIndexes, index]\n                });\n              }\n            }}\n          />\n          {index}\n          {': '}\n          {featureType}\n        </label>\n      </ToolboxLabel>\n    );\n  }\n\n  _renderSelectFeatureCheckboxes() {\n    const {\n      testFeatures: { features }\n    } = this.state;\n    const checkboxes = [];\n    for (let i = 0; i < features.length; ++i) {\n      checkboxes.push(this._renderSelectFeatureCheckbox(i, features[i].geometry.type));\n    }\n    return checkboxes;\n  }\n\n  _renderBooleanOperationControls() {\n    const operations = ['union', 'difference', 'intersection'];\n    return (\n      <ToolboxRow key=\"booleanOperations\">\n        <ToolboxLabel>Boolean operation (requires single selection)</ToolboxLabel>\n        <ToolboxControl>\n          {operations.map(operation => (\n            <button\n              key={operation}\n              style={{\n                backgroundColor:\n                  this.state.modeConfig && this.state.modeConfig.booleanOperation === operation\n                    ? '#a0cde8'\n                    : ''\n              }}\n              onClick={() => {\n                if (this.state.modeConfig && this.state.modeConfig.booleanOperation === operation) {\n                  this.setState({ modeConfig: null });\n                } else {\n                  this.setState({ modeConfig: { booleanOperation: operation } });\n                }\n              }}\n            >\n              {operation}\n            </button>\n          ))}\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderDrawLineStringModeControls() {\n    return (\n      <ToolboxRow key=\"drawLineString\">\n        <ToolboxLabel>Draw LineString At Front</ToolboxLabel>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.drawAtFront)}\n            onChange={event =>\n              this.setState({\n                modeConfig: {\n                  drawAtFront: Boolean(event.target.checked)\n                }\n              })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderModifyModeControls() {\n    return (\n      <ToolboxRow key=\"modify\">\n        <ToolboxLabel>Allow removing points</ToolboxLabel>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={this.state.pointsRemovable}\n            onChange={() => this.setState({ pointsRemovable: !this.state.pointsRemovable })}\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSplitModeControls() {\n    return (\n      <ToolboxRow key=\"split\">\n        <ToolboxLabel>Constrain to 90&deg;</ToolboxLabel>\n        <ToolboxControl>\n          <input\n            type=\"checkbox\"\n            checked={Boolean(this.state.modeConfig && this.state.modeConfig.lock90Degree)}\n            onChange={event =>\n              this.setState({ modeConfig: { lock90Degree: Boolean(event.target.checked) } })\n            }\n          />\n        </ToolboxControl>\n      </ToolboxRow>\n    );\n  }\n\n  _renderSnappingControls() {\n    const snapPixels = (this.state.modeConfig && this.state.modeConfig.snapPixels) || 5;\n    return (\n      <div key=\"snap\">\n        <ToolboxRow>\n          <ToolboxLabel>Enable snapping</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={Boolean(this.state.modeConfig && this.state.modeConfig.enableSnapping)}\n              onChange={event => {\n                const modeConfig = {\n                  ...this.state.modeConfig,\n                  snapPixels,\n                  enableSnapping: Boolean(event.target.checked)\n                };\n                this.setState({ modeConfig });\n              }}\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxLabel>Snap pixels</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"50\"\n              step=\"1\"\n              value={snapPixels}\n              onChange={event => {\n                this.setState({\n                  modeConfig: {\n                    ...this.state.modeConfig,\n                    snapPixels: parseFloat(event.target.value)\n                  }\n                });\n              }}\n            />\n            <div>{snapPixels}</div>\n          </ToolboxControl>\n        </ToolboxRow>\n      </div>\n    );\n  }\n\n  _renderModeConfigControls() {\n    const controls = [];\n\n    if (POLYGON_DRAWING_MODES.indexOf(this.state.mode) > -1) {\n      controls.push(this._renderBooleanOperationControls());\n    }\n    if (this.state.mode === 'drawLineString') {\n      controls.push(this._renderDrawLineStringModeControls());\n    }\n    if (this.state.mode === 'modify') {\n      controls.push(this._renderModifyModeControls());\n    }\n    if (this.state.mode === 'split') {\n      controls.push(this._renderSplitModeControls());\n    }\n    if (this.state.mode === 'translate') {\n      controls.push(this._renderSnappingControls());\n    }\n\n    return controls;\n  }\n\n  _renderToolBox() {\n    return (\n      <div style={ToolboxStyles.toolbox}>\n        {ALL_MODES.map(category => (\n          <ToolboxRowWrapping key={category.category}>\n            <div style={{ paddingRight: '4px' }}>{category.category} Modes</div>\n            {category.modes.map(mode => (\n              <button\n                key={mode}\n                style={{\n                  margin: '2px',\n                  // padding: '2px 6px',\n                  backgroundColor: this.state.mode === mode ? '#a0cde8' : ''\n                }}\n                onClick={() => {\n                  this.setState({ mode, modeConfig: {}, selectionTool: null });\n                }}\n              >\n                {mode}\n              </button>\n            ))}\n          </ToolboxRowWrapping>\n        ))}\n        {this._renderModeConfigControls()}\n        <ToolboxDivider />\n        <ToolboxLabel>geoJSON</ToolboxLabel>\n        <ToolboxControl>\n          <textarea\n            id=\"geo-json-text\"\n            rows={5}\n            style={{ width: '100%' }}\n            value={JSON.stringify(this.state.testFeatures)}\n            onChange={event => this.setState({ testFeatures: JSON.parse(event.target.value) })}\n          />\n        </ToolboxControl>\n        <ToolboxDivider />\n        <ToolboxRow>\n          <ToolboxLabel>Load sample data</ToolboxLabel>\n          <ToolboxControl>\n            <button onClick={() => this._loadSample('mixed')}>Mixed</button>\n            <button onClick={() => this._loadSample('complex')}>Complex</button>\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxLabel>Use Icons</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'icon'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'icon' ? 'point' : 'icon'\n                })\n              }\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxLabel>Use ElevatedEditHandleLayer</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"checkbox\"\n              checked={this.state.editHandleType === 'elevated'}\n              onChange={() =>\n                this.setState({\n                  editHandleType: this.state.editHandleType === 'elevated' ? 'point' : 'elevated'\n                })\n              }\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n\n        <ToolboxRow>\n          <ToolboxLabel>Select Features</ToolboxLabel>\n          <ToolboxControl>\n            <input\n              type=\"button\"\n              value=\"Clear\"\n              onClick={() =>\n                this.setState({ selectedFeatureIndexes: [], selectionTool: SELECTION_TYPE.NONE })\n              }\n            />\n            <input\n              type=\"button\"\n              value=\"Rect\"\n              onClick={() =>\n                this.setState({ mode: 'view', selectionTool: SELECTION_TYPE.RECTANGLE })\n              }\n            />\n            <input\n              type=\"button\"\n              value=\"Lasso\"\n              onClick={() => this.setState({ mode: 'view', selectionTool: SELECTION_TYPE.POLYGON })}\n            />\n          </ToolboxControl>\n        </ToolboxRow>\n        <ToolboxRowWrapping>{this._renderSelectFeatureCheckboxes()}</ToolboxRowWrapping>\n      </div>\n    );\n  }\n\n  renderStaticMap(viewport: Object) {\n    return <StaticMap {...viewport} />;\n  }\n\n  customizeLayers(layers: Object[]) {}\n\n  render() {\n    const { testFeatures, selectedFeatureIndexes, mode, modeConfig } = this.state;\n\n    const viewport = {\n      ...this.state.viewport,\n      height: window.innerHeight,\n      width: window.innerWidth\n    };\n\n    const editableGeoJsonLayer = new EditableGeoJsonLayer({\n      id: 'geojson',\n      data: testFeatures,\n      selectedFeatureIndexes,\n      modeHandlers,\n      mode,\n      modeConfig,\n      autoHighlight: false,\n\n      // Editing callbacks\n      onEdit: ({ updatedData, editType, featureIndexes, editContext }) => {\n        let updatedSelectedFeatureIndexes = this.state.selectedFeatureIndexes;\n        if (\n          !['movePosition', 'extruding', 'rotating', 'translating', 'scaling'].includes(editType)\n        ) {\n          // Don't log edits that happen as the pointer moves since they're really chatty\n          // eslint-disable-next-line\n          console.log('onEdit', editType, featureIndexes, editContext);\n        }\n        if (editType === 'removePosition' && !this.state.pointsRemovable) {\n          // This is a simple example of custom handling of edits\n          // reject the edit\n          return;\n        }\n        if (editType === 'addFeature' && mode !== 'duplicate') {\n          // Add the new feature to the selection\n          updatedSelectedFeatureIndexes = [...this.state.selectedFeatureIndexes, ...featureIndexes];\n        }\n        this.setState({\n          testFeatures: updatedData,\n          selectedFeatureIndexes: updatedSelectedFeatureIndexes\n        });\n      },\n\n      // test using icons for edit handles\n      editHandleType:\n        this.state.editHandleType === 'elevated'\n          ? ElevatedEditHandleLayer\n          : this.state.editHandleType,\n      editHandleIconAtlas: iconSheet,\n      editHandleIconMapping: {\n        intermediate: {\n          x: 0,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        },\n        existing: {\n          x: 58,\n          y: 0,\n          width: 58,\n          height: 58,\n          mask: false\n        }\n      },\n      getEditHandleIcon: d => d.type,\n      getEditHandleIconSize: 40,\n      getEditHandleIconColor: getEditHandleColor,\n\n      // Specify the same GeoJsonLayer props\n      lineWidthMinPixels: 2,\n      pointRadiusMinPixels: 5,\n      getLineDashArray: () => [0, 0],\n\n      // Accessors receive an isSelected argument\n      getFillColor: (feature, isSelected) => {\n        return isSelected ? [0x20, 0x40, 0x90, 0x80] : [0x20, 0x20, 0x20, 0x30];\n      },\n      getLineColor: (feature, isSelected) => {\n        return isSelected ? [0x00, 0x20, 0x90, 0xff] : [0x20, 0x20, 0x20, 0xff];\n      },\n\n      // Can customize editing points props\n      getEditHandlePointColor: getEditHandleColor,\n      editHandlePointRadiusScale: 2,\n\n      // customize tentative feature style\n      getTentativeLineDashArray: () => [7, 4],\n      getTentativeLineColor: () => [0x8f, 0x8f, 0x8f, 0xff],\n\n      parameters: {\n        depthTest: true,\n        depthMask: false,\n\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA]\n      }\n    });\n\n    const layers = [editableGeoJsonLayer];\n\n    if (this.state.selectionTool) {\n      layers.push(\n        new SelectionLayer({\n          id: 'selection',\n          selectionType: this.state.selectionTool,\n          onSelect: ({ pickingInfos }) => {\n            this.setState({ selectedFeatureIndexes: pickingInfos.map(pi => pi.index) });\n          },\n          layerIds: ['geojson'],\n\n          getTentativeFillColor: () => [255, 0, 255, 100],\n          getTentativeLineColor: () => [0, 0, 255, 255],\n          getTentativeLineDashArray: () => [0, 0],\n          lineWidthMinPixels: 3\n        })\n      );\n    }\n\n    this.customizeLayers(layers);\n\n    return (\n      <div style={styles.mapContainer}>\n        <link href=\"https://api.mapbox.com/mapbox-gl-js/v0.44.0/mapbox-gl.css\" rel=\"stylesheet\" />\n        <DeckGL\n          viewState={viewport}\n          getCursor={editableGeoJsonLayer.getCursor.bind(editableGeoJsonLayer)}\n          layers={layers}\n          views={\n            new MapView({\n              id: 'basemap',\n              controller: {\n                type: MapController,\n                doubleClickZoom: this.state.mode === 'view' && !this.state.selectionTool\n              }\n            })\n          }\n          onClick={this._onLayerClick}\n          onViewStateChange={({ viewState }) => this.setState({ viewport: viewState })}\n        >\n          {this.renderStaticMap(viewport)}\n        </DeckGL>\n        {this._renderToolBox()}\n      </div>\n    );\n  }\n}\n","module.exports = \"data:image/png;base64,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\""],"sourceRoot":""}